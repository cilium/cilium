// Code generated by protoc-gen-go. DO NOT EDIT.
// source: validate/validate.proto

/*
Package validate is a generated protocol buffer package.

It is generated from these files:
	validate/validate.proto

It has these top-level messages:
	FieldRules
	FloatRules
	DoubleRules
	Int32Rules
	Int64Rules
	UInt32Rules
	UInt64Rules
	SInt32Rules
	SInt64Rules
	Fixed32Rules
	Fixed64Rules
	SFixed32Rules
	SFixed64Rules
	BoolRules
	StringRules
	BytesRules
	EnumRules
	MessageRules
	RepeatedRules
	MapRules
	AnyRules
	DurationRules
	TimestampRules
*/
package validate

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/protoc-gen-go/descriptor"
import google_protobuf1 "github.com/golang/protobuf/ptypes/duration"
import google_protobuf2 "github.com/golang/protobuf/ptypes/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// FieldRules encapsulates the rules for each type of field. Depending on the
// field, the correct set should be used to ensure proper validations.
type FieldRules struct {
	// Types that are valid to be assigned to Type:
	//	*FieldRules_Float
	//	*FieldRules_Double
	//	*FieldRules_Int32
	//	*FieldRules_Int64
	//	*FieldRules_Uint32
	//	*FieldRules_Uint64
	//	*FieldRules_Sint32
	//	*FieldRules_Sint64
	//	*FieldRules_Fixed32
	//	*FieldRules_Fixed64
	//	*FieldRules_Sfixed32
	//	*FieldRules_Sfixed64
	//	*FieldRules_Bool
	//	*FieldRules_String_
	//	*FieldRules_Bytes
	//	*FieldRules_Enum
	//	*FieldRules_Message
	//	*FieldRules_Repeated
	//	*FieldRules_Map
	//	*FieldRules_Any
	//	*FieldRules_Duration
	//	*FieldRules_Timestamp
	Type             isFieldRules_Type `protobuf_oneof:"type"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *FieldRules) Reset()                    { *m = FieldRules{} }
func (m *FieldRules) String() string            { return proto.CompactTextString(m) }
func (*FieldRules) ProtoMessage()               {}
func (*FieldRules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isFieldRules_Type interface {
	isFieldRules_Type()
}

type FieldRules_Float struct {
	Float *FloatRules `protobuf:"bytes,1,opt,name=float,oneof"`
}
type FieldRules_Double struct {
	Double *DoubleRules `protobuf:"bytes,2,opt,name=double,oneof"`
}
type FieldRules_Int32 struct {
	Int32 *Int32Rules `protobuf:"bytes,3,opt,name=int32,oneof"`
}
type FieldRules_Int64 struct {
	Int64 *Int64Rules `protobuf:"bytes,4,opt,name=int64,oneof"`
}
type FieldRules_Uint32 struct {
	Uint32 *UInt32Rules `protobuf:"bytes,5,opt,name=uint32,oneof"`
}
type FieldRules_Uint64 struct {
	Uint64 *UInt64Rules `protobuf:"bytes,6,opt,name=uint64,oneof"`
}
type FieldRules_Sint32 struct {
	Sint32 *SInt32Rules `protobuf:"bytes,7,opt,name=sint32,oneof"`
}
type FieldRules_Sint64 struct {
	Sint64 *SInt64Rules `protobuf:"bytes,8,opt,name=sint64,oneof"`
}
type FieldRules_Fixed32 struct {
	Fixed32 *Fixed32Rules `protobuf:"bytes,9,opt,name=fixed32,oneof"`
}
type FieldRules_Fixed64 struct {
	Fixed64 *Fixed64Rules `protobuf:"bytes,10,opt,name=fixed64,oneof"`
}
type FieldRules_Sfixed32 struct {
	Sfixed32 *SFixed32Rules `protobuf:"bytes,11,opt,name=sfixed32,oneof"`
}
type FieldRules_Sfixed64 struct {
	Sfixed64 *SFixed64Rules `protobuf:"bytes,12,opt,name=sfixed64,oneof"`
}
type FieldRules_Bool struct {
	Bool *BoolRules `protobuf:"bytes,13,opt,name=bool,oneof"`
}
type FieldRules_String_ struct {
	String_ *StringRules `protobuf:"bytes,14,opt,name=string,oneof"`
}
type FieldRules_Bytes struct {
	Bytes *BytesRules `protobuf:"bytes,15,opt,name=bytes,oneof"`
}
type FieldRules_Enum struct {
	Enum *EnumRules `protobuf:"bytes,16,opt,name=enum,oneof"`
}
type FieldRules_Message struct {
	Message *MessageRules `protobuf:"bytes,17,opt,name=message,oneof"`
}
type FieldRules_Repeated struct {
	Repeated *RepeatedRules `protobuf:"bytes,18,opt,name=repeated,oneof"`
}
type FieldRules_Map struct {
	Map *MapRules `protobuf:"bytes,19,opt,name=map,oneof"`
}
type FieldRules_Any struct {
	Any *AnyRules `protobuf:"bytes,20,opt,name=any,oneof"`
}
type FieldRules_Duration struct {
	Duration *DurationRules `protobuf:"bytes,21,opt,name=duration,oneof"`
}
type FieldRules_Timestamp struct {
	Timestamp *TimestampRules `protobuf:"bytes,22,opt,name=timestamp,oneof"`
}

func (*FieldRules_Float) isFieldRules_Type()     {}
func (*FieldRules_Double) isFieldRules_Type()    {}
func (*FieldRules_Int32) isFieldRules_Type()     {}
func (*FieldRules_Int64) isFieldRules_Type()     {}
func (*FieldRules_Uint32) isFieldRules_Type()    {}
func (*FieldRules_Uint64) isFieldRules_Type()    {}
func (*FieldRules_Sint32) isFieldRules_Type()    {}
func (*FieldRules_Sint64) isFieldRules_Type()    {}
func (*FieldRules_Fixed32) isFieldRules_Type()   {}
func (*FieldRules_Fixed64) isFieldRules_Type()   {}
func (*FieldRules_Sfixed32) isFieldRules_Type()  {}
func (*FieldRules_Sfixed64) isFieldRules_Type()  {}
func (*FieldRules_Bool) isFieldRules_Type()      {}
func (*FieldRules_String_) isFieldRules_Type()   {}
func (*FieldRules_Bytes) isFieldRules_Type()     {}
func (*FieldRules_Enum) isFieldRules_Type()      {}
func (*FieldRules_Message) isFieldRules_Type()   {}
func (*FieldRules_Repeated) isFieldRules_Type()  {}
func (*FieldRules_Map) isFieldRules_Type()       {}
func (*FieldRules_Any) isFieldRules_Type()       {}
func (*FieldRules_Duration) isFieldRules_Type()  {}
func (*FieldRules_Timestamp) isFieldRules_Type() {}

func (m *FieldRules) GetType() isFieldRules_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *FieldRules) GetFloat() *FloatRules {
	if x, ok := m.GetType().(*FieldRules_Float); ok {
		return x.Float
	}
	return nil
}

func (m *FieldRules) GetDouble() *DoubleRules {
	if x, ok := m.GetType().(*FieldRules_Double); ok {
		return x.Double
	}
	return nil
}

func (m *FieldRules) GetInt32() *Int32Rules {
	if x, ok := m.GetType().(*FieldRules_Int32); ok {
		return x.Int32
	}
	return nil
}

func (m *FieldRules) GetInt64() *Int64Rules {
	if x, ok := m.GetType().(*FieldRules_Int64); ok {
		return x.Int64
	}
	return nil
}

func (m *FieldRules) GetUint32() *UInt32Rules {
	if x, ok := m.GetType().(*FieldRules_Uint32); ok {
		return x.Uint32
	}
	return nil
}

func (m *FieldRules) GetUint64() *UInt64Rules {
	if x, ok := m.GetType().(*FieldRules_Uint64); ok {
		return x.Uint64
	}
	return nil
}

func (m *FieldRules) GetSint32() *SInt32Rules {
	if x, ok := m.GetType().(*FieldRules_Sint32); ok {
		return x.Sint32
	}
	return nil
}

func (m *FieldRules) GetSint64() *SInt64Rules {
	if x, ok := m.GetType().(*FieldRules_Sint64); ok {
		return x.Sint64
	}
	return nil
}

func (m *FieldRules) GetFixed32() *Fixed32Rules {
	if x, ok := m.GetType().(*FieldRules_Fixed32); ok {
		return x.Fixed32
	}
	return nil
}

func (m *FieldRules) GetFixed64() *Fixed64Rules {
	if x, ok := m.GetType().(*FieldRules_Fixed64); ok {
		return x.Fixed64
	}
	return nil
}

func (m *FieldRules) GetSfixed32() *SFixed32Rules {
	if x, ok := m.GetType().(*FieldRules_Sfixed32); ok {
		return x.Sfixed32
	}
	return nil
}

func (m *FieldRules) GetSfixed64() *SFixed64Rules {
	if x, ok := m.GetType().(*FieldRules_Sfixed64); ok {
		return x.Sfixed64
	}
	return nil
}

func (m *FieldRules) GetBool() *BoolRules {
	if x, ok := m.GetType().(*FieldRules_Bool); ok {
		return x.Bool
	}
	return nil
}

func (m *FieldRules) GetString_() *StringRules {
	if x, ok := m.GetType().(*FieldRules_String_); ok {
		return x.String_
	}
	return nil
}

func (m *FieldRules) GetBytes() *BytesRules {
	if x, ok := m.GetType().(*FieldRules_Bytes); ok {
		return x.Bytes
	}
	return nil
}

func (m *FieldRules) GetEnum() *EnumRules {
	if x, ok := m.GetType().(*FieldRules_Enum); ok {
		return x.Enum
	}
	return nil
}

func (m *FieldRules) GetMessage() *MessageRules {
	if x, ok := m.GetType().(*FieldRules_Message); ok {
		return x.Message
	}
	return nil
}

func (m *FieldRules) GetRepeated() *RepeatedRules {
	if x, ok := m.GetType().(*FieldRules_Repeated); ok {
		return x.Repeated
	}
	return nil
}

func (m *FieldRules) GetMap() *MapRules {
	if x, ok := m.GetType().(*FieldRules_Map); ok {
		return x.Map
	}
	return nil
}

func (m *FieldRules) GetAny() *AnyRules {
	if x, ok := m.GetType().(*FieldRules_Any); ok {
		return x.Any
	}
	return nil
}

func (m *FieldRules) GetDuration() *DurationRules {
	if x, ok := m.GetType().(*FieldRules_Duration); ok {
		return x.Duration
	}
	return nil
}

func (m *FieldRules) GetTimestamp() *TimestampRules {
	if x, ok := m.GetType().(*FieldRules_Timestamp); ok {
		return x.Timestamp
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FieldRules) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FieldRules_OneofMarshaler, _FieldRules_OneofUnmarshaler, _FieldRules_OneofSizer, []interface{}{
		(*FieldRules_Float)(nil),
		(*FieldRules_Double)(nil),
		(*FieldRules_Int32)(nil),
		(*FieldRules_Int64)(nil),
		(*FieldRules_Uint32)(nil),
		(*FieldRules_Uint64)(nil),
		(*FieldRules_Sint32)(nil),
		(*FieldRules_Sint64)(nil),
		(*FieldRules_Fixed32)(nil),
		(*FieldRules_Fixed64)(nil),
		(*FieldRules_Sfixed32)(nil),
		(*FieldRules_Sfixed64)(nil),
		(*FieldRules_Bool)(nil),
		(*FieldRules_String_)(nil),
		(*FieldRules_Bytes)(nil),
		(*FieldRules_Enum)(nil),
		(*FieldRules_Message)(nil),
		(*FieldRules_Repeated)(nil),
		(*FieldRules_Map)(nil),
		(*FieldRules_Any)(nil),
		(*FieldRules_Duration)(nil),
		(*FieldRules_Timestamp)(nil),
	}
}

func _FieldRules_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FieldRules)
	// type
	switch x := m.Type.(type) {
	case *FieldRules_Float:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Float); err != nil {
			return err
		}
	case *FieldRules_Double:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Double); err != nil {
			return err
		}
	case *FieldRules_Int32:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Int32); err != nil {
			return err
		}
	case *FieldRules_Int64:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Int64); err != nil {
			return err
		}
	case *FieldRules_Uint32:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Uint32); err != nil {
			return err
		}
	case *FieldRules_Uint64:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Uint64); err != nil {
			return err
		}
	case *FieldRules_Sint32:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Sint32); err != nil {
			return err
		}
	case *FieldRules_Sint64:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Sint64); err != nil {
			return err
		}
	case *FieldRules_Fixed32:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Fixed32); err != nil {
			return err
		}
	case *FieldRules_Fixed64:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Fixed64); err != nil {
			return err
		}
	case *FieldRules_Sfixed32:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Sfixed32); err != nil {
			return err
		}
	case *FieldRules_Sfixed64:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Sfixed64); err != nil {
			return err
		}
	case *FieldRules_Bool:
		b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Bool); err != nil {
			return err
		}
	case *FieldRules_String_:
		b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.String_); err != nil {
			return err
		}
	case *FieldRules_Bytes:
		b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Bytes); err != nil {
			return err
		}
	case *FieldRules_Enum:
		b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Enum); err != nil {
			return err
		}
	case *FieldRules_Message:
		b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Message); err != nil {
			return err
		}
	case *FieldRules_Repeated:
		b.EncodeVarint(18<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Repeated); err != nil {
			return err
		}
	case *FieldRules_Map:
		b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Map); err != nil {
			return err
		}
	case *FieldRules_Any:
		b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Any); err != nil {
			return err
		}
	case *FieldRules_Duration:
		b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Duration); err != nil {
			return err
		}
	case *FieldRules_Timestamp:
		b.EncodeVarint(22<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Timestamp); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FieldRules.Type has unexpected type %T", x)
	}
	return nil
}

func _FieldRules_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FieldRules)
	switch tag {
	case 1: // type.float
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FloatRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldRules_Float{msg}
		return true, err
	case 2: // type.double
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DoubleRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldRules_Double{msg}
		return true, err
	case 3: // type.int32
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Int32Rules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldRules_Int32{msg}
		return true, err
	case 4: // type.int64
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Int64Rules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldRules_Int64{msg}
		return true, err
	case 5: // type.uint32
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UInt32Rules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldRules_Uint32{msg}
		return true, err
	case 6: // type.uint64
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UInt64Rules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldRules_Uint64{msg}
		return true, err
	case 7: // type.sint32
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SInt32Rules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldRules_Sint32{msg}
		return true, err
	case 8: // type.sint64
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SInt64Rules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldRules_Sint64{msg}
		return true, err
	case 9: // type.fixed32
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Fixed32Rules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldRules_Fixed32{msg}
		return true, err
	case 10: // type.fixed64
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Fixed64Rules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldRules_Fixed64{msg}
		return true, err
	case 11: // type.sfixed32
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SFixed32Rules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldRules_Sfixed32{msg}
		return true, err
	case 12: // type.sfixed64
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SFixed64Rules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldRules_Sfixed64{msg}
		return true, err
	case 13: // type.bool
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BoolRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldRules_Bool{msg}
		return true, err
	case 14: // type.string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StringRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldRules_String_{msg}
		return true, err
	case 15: // type.bytes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BytesRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldRules_Bytes{msg}
		return true, err
	case 16: // type.enum
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EnumRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldRules_Enum{msg}
		return true, err
	case 17: // type.message
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MessageRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldRules_Message{msg}
		return true, err
	case 18: // type.repeated
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RepeatedRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldRules_Repeated{msg}
		return true, err
	case 19: // type.map
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MapRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldRules_Map{msg}
		return true, err
	case 20: // type.any
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AnyRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldRules_Any{msg}
		return true, err
	case 21: // type.duration
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DurationRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldRules_Duration{msg}
		return true, err
	case 22: // type.timestamp
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TimestampRules)
		err := b.DecodeMessage(msg)
		m.Type = &FieldRules_Timestamp{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FieldRules_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FieldRules)
	// type
	switch x := m.Type.(type) {
	case *FieldRules_Float:
		s := proto.Size(x.Float)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldRules_Double:
		s := proto.Size(x.Double)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldRules_Int32:
		s := proto.Size(x.Int32)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldRules_Int64:
		s := proto.Size(x.Int64)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldRules_Uint32:
		s := proto.Size(x.Uint32)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldRules_Uint64:
		s := proto.Size(x.Uint64)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldRules_Sint32:
		s := proto.Size(x.Sint32)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldRules_Sint64:
		s := proto.Size(x.Sint64)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldRules_Fixed32:
		s := proto.Size(x.Fixed32)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldRules_Fixed64:
		s := proto.Size(x.Fixed64)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldRules_Sfixed32:
		s := proto.Size(x.Sfixed32)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldRules_Sfixed64:
		s := proto.Size(x.Sfixed64)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldRules_Bool:
		s := proto.Size(x.Bool)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldRules_String_:
		s := proto.Size(x.String_)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldRules_Bytes:
		s := proto.Size(x.Bytes)
		n += proto.SizeVarint(15<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldRules_Enum:
		s := proto.Size(x.Enum)
		n += proto.SizeVarint(16<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldRules_Message:
		s := proto.Size(x.Message)
		n += proto.SizeVarint(17<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldRules_Repeated:
		s := proto.Size(x.Repeated)
		n += proto.SizeVarint(18<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldRules_Map:
		s := proto.Size(x.Map)
		n += proto.SizeVarint(19<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldRules_Any:
		s := proto.Size(x.Any)
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldRules_Duration:
		s := proto.Size(x.Duration)
		n += proto.SizeVarint(21<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FieldRules_Timestamp:
		s := proto.Size(x.Timestamp)
		n += proto.SizeVarint(22<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// FloatRules describes the constraints applied to `float` values
type FloatRules struct {
	// Const specifies that this field must be exactly the specified value
	Const *float32 `protobuf:"fixed32,1,opt,name=const" json:"const,omitempty"`
	// Lt specifies that this field must be less than the specified value,
	// exclusive
	Lt *float32 `protobuf:"fixed32,2,opt,name=lt" json:"lt,omitempty"`
	// Lte specifies that this field must be less than or equal to the
	// specified value, inclusive
	Lte *float32 `protobuf:"fixed32,3,opt,name=lte" json:"lte,omitempty"`
	// Gt specifies that this field must be greater than the specified value,
	// exclusive. If the value of Gt is larger than a specified Lt or Lte, the
	// range is reversed.
	Gt *float32 `protobuf:"fixed32,4,opt,name=gt" json:"gt,omitempty"`
	// Gte specifies that this field must be greater than or equal to the
	// specified value, inclusive. If the value of Gte is larger than a
	// specified Lt or Lte, the range is reversed.
	Gte *float32 `protobuf:"fixed32,5,opt,name=gte" json:"gte,omitempty"`
	// In specifies that this field must be equal to one of the specified
	// values
	In []float32 `protobuf:"fixed32,6,rep,name=in" json:"in,omitempty"`
	// NotIn specifies that this field cannot be equal to one of the specified
	// values
	NotIn            []float32 `protobuf:"fixed32,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *FloatRules) Reset()                    { *m = FloatRules{} }
func (m *FloatRules) String() string            { return proto.CompactTextString(m) }
func (*FloatRules) ProtoMessage()               {}
func (*FloatRules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *FloatRules) GetConst() float32 {
	if m != nil && m.Const != nil {
		return *m.Const
	}
	return 0
}

func (m *FloatRules) GetLt() float32 {
	if m != nil && m.Lt != nil {
		return *m.Lt
	}
	return 0
}

func (m *FloatRules) GetLte() float32 {
	if m != nil && m.Lte != nil {
		return *m.Lte
	}
	return 0
}

func (m *FloatRules) GetGt() float32 {
	if m != nil && m.Gt != nil {
		return *m.Gt
	}
	return 0
}

func (m *FloatRules) GetGte() float32 {
	if m != nil && m.Gte != nil {
		return *m.Gte
	}
	return 0
}

func (m *FloatRules) GetIn() []float32 {
	if m != nil {
		return m.In
	}
	return nil
}

func (m *FloatRules) GetNotIn() []float32 {
	if m != nil {
		return m.NotIn
	}
	return nil
}

// DoubleRules describes the constraints applied to `double` values
type DoubleRules struct {
	// Const specifies that this field must be exactly the specified value
	Const *float64 `protobuf:"fixed64,1,opt,name=const" json:"const,omitempty"`
	// Lt specifies that this field must be less than the specified value,
	// exclusive
	Lt *float64 `protobuf:"fixed64,2,opt,name=lt" json:"lt,omitempty"`
	// Lte specifies that this field must be less than or equal to the
	// specified value, inclusive
	Lte *float64 `protobuf:"fixed64,3,opt,name=lte" json:"lte,omitempty"`
	// Gt specifies that this field must be greater than the specified value,
	// exclusive. If the value of Gt is larger than a specified Lt or Lte, the
	// range is reversed.
	Gt *float64 `protobuf:"fixed64,4,opt,name=gt" json:"gt,omitempty"`
	// Gte specifies that this field must be greater than or equal to the
	// specified value, inclusive. If the value of Gte is larger than a
	// specified Lt or Lte, the range is reversed.
	Gte *float64 `protobuf:"fixed64,5,opt,name=gte" json:"gte,omitempty"`
	// In specifies that this field must be equal to one of the specified
	// values
	In []float64 `protobuf:"fixed64,6,rep,name=in" json:"in,omitempty"`
	// NotIn specifies that this field cannot be equal to one of the specified
	// values
	NotIn            []float64 `protobuf:"fixed64,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *DoubleRules) Reset()                    { *m = DoubleRules{} }
func (m *DoubleRules) String() string            { return proto.CompactTextString(m) }
func (*DoubleRules) ProtoMessage()               {}
func (*DoubleRules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *DoubleRules) GetConst() float64 {
	if m != nil && m.Const != nil {
		return *m.Const
	}
	return 0
}

func (m *DoubleRules) GetLt() float64 {
	if m != nil && m.Lt != nil {
		return *m.Lt
	}
	return 0
}

func (m *DoubleRules) GetLte() float64 {
	if m != nil && m.Lte != nil {
		return *m.Lte
	}
	return 0
}

func (m *DoubleRules) GetGt() float64 {
	if m != nil && m.Gt != nil {
		return *m.Gt
	}
	return 0
}

func (m *DoubleRules) GetGte() float64 {
	if m != nil && m.Gte != nil {
		return *m.Gte
	}
	return 0
}

func (m *DoubleRules) GetIn() []float64 {
	if m != nil {
		return m.In
	}
	return nil
}

func (m *DoubleRules) GetNotIn() []float64 {
	if m != nil {
		return m.NotIn
	}
	return nil
}

// Int32Rules describes the constraints applied to `int32` values
type Int32Rules struct {
	// Const specifies that this field must be exactly the specified value
	Const *int32 `protobuf:"varint,1,opt,name=const" json:"const,omitempty"`
	// Lt specifies that this field must be less than the specified value,
	// exclusive
	Lt *int32 `protobuf:"varint,2,opt,name=lt" json:"lt,omitempty"`
	// Lte specifies that this field must be less than or equal to the
	// specified value, inclusive
	Lte *int32 `protobuf:"varint,3,opt,name=lte" json:"lte,omitempty"`
	// Gt specifies that this field must be greater than the specified value,
	// exclusive. If the value of Gt is larger than a specified Lt or Lte, the
	// range is reversed.
	Gt *int32 `protobuf:"varint,4,opt,name=gt" json:"gt,omitempty"`
	// Gte specifies that this field must be greater than or equal to the
	// specified value, inclusive. If the value of Gte is larger than a
	// specified Lt or Lte, the range is reversed.
	Gte *int32 `protobuf:"varint,5,opt,name=gte" json:"gte,omitempty"`
	// In specifies that this field must be equal to one of the specified
	// values
	In []int32 `protobuf:"varint,6,rep,name=in" json:"in,omitempty"`
	// NotIn specifies that this field cannot be equal to one of the specified
	// values
	NotIn            []int32 `protobuf:"varint,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Int32Rules) Reset()                    { *m = Int32Rules{} }
func (m *Int32Rules) String() string            { return proto.CompactTextString(m) }
func (*Int32Rules) ProtoMessage()               {}
func (*Int32Rules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Int32Rules) GetConst() int32 {
	if m != nil && m.Const != nil {
		return *m.Const
	}
	return 0
}

func (m *Int32Rules) GetLt() int32 {
	if m != nil && m.Lt != nil {
		return *m.Lt
	}
	return 0
}

func (m *Int32Rules) GetLte() int32 {
	if m != nil && m.Lte != nil {
		return *m.Lte
	}
	return 0
}

func (m *Int32Rules) GetGt() int32 {
	if m != nil && m.Gt != nil {
		return *m.Gt
	}
	return 0
}

func (m *Int32Rules) GetGte() int32 {
	if m != nil && m.Gte != nil {
		return *m.Gte
	}
	return 0
}

func (m *Int32Rules) GetIn() []int32 {
	if m != nil {
		return m.In
	}
	return nil
}

func (m *Int32Rules) GetNotIn() []int32 {
	if m != nil {
		return m.NotIn
	}
	return nil
}

// Int64Rules describes the constraints applied to `int64` values
type Int64Rules struct {
	// Const specifies that this field must be exactly the specified value
	Const *int64 `protobuf:"varint,1,opt,name=const" json:"const,omitempty"`
	// Lt specifies that this field must be less than the specified value,
	// exclusive
	Lt *int64 `protobuf:"varint,2,opt,name=lt" json:"lt,omitempty"`
	// Lte specifies that this field must be less than or equal to the
	// specified value, inclusive
	Lte *int64 `protobuf:"varint,3,opt,name=lte" json:"lte,omitempty"`
	// Gt specifies that this field must be greater than the specified value,
	// exclusive. If the value of Gt is larger than a specified Lt or Lte, the
	// range is reversed.
	Gt *int64 `protobuf:"varint,4,opt,name=gt" json:"gt,omitempty"`
	// Gte specifies that this field must be greater than or equal to the
	// specified value, inclusive. If the value of Gte is larger than a
	// specified Lt or Lte, the range is reversed.
	Gte *int64 `protobuf:"varint,5,opt,name=gte" json:"gte,omitempty"`
	// In specifies that this field must be equal to one of the specified
	// values
	In []int64 `protobuf:"varint,6,rep,name=in" json:"in,omitempty"`
	// NotIn specifies that this field cannot be equal to one of the specified
	// values
	NotIn            []int64 `protobuf:"varint,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Int64Rules) Reset()                    { *m = Int64Rules{} }
func (m *Int64Rules) String() string            { return proto.CompactTextString(m) }
func (*Int64Rules) ProtoMessage()               {}
func (*Int64Rules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Int64Rules) GetConst() int64 {
	if m != nil && m.Const != nil {
		return *m.Const
	}
	return 0
}

func (m *Int64Rules) GetLt() int64 {
	if m != nil && m.Lt != nil {
		return *m.Lt
	}
	return 0
}

func (m *Int64Rules) GetLte() int64 {
	if m != nil && m.Lte != nil {
		return *m.Lte
	}
	return 0
}

func (m *Int64Rules) GetGt() int64 {
	if m != nil && m.Gt != nil {
		return *m.Gt
	}
	return 0
}

func (m *Int64Rules) GetGte() int64 {
	if m != nil && m.Gte != nil {
		return *m.Gte
	}
	return 0
}

func (m *Int64Rules) GetIn() []int64 {
	if m != nil {
		return m.In
	}
	return nil
}

func (m *Int64Rules) GetNotIn() []int64 {
	if m != nil {
		return m.NotIn
	}
	return nil
}

// UInt32Rules describes the constraints applied to `uint32` values
type UInt32Rules struct {
	// Const specifies that this field must be exactly the specified value
	Const *uint32 `protobuf:"varint,1,opt,name=const" json:"const,omitempty"`
	// Lt specifies that this field must be less than the specified value,
	// exclusive
	Lt *uint32 `protobuf:"varint,2,opt,name=lt" json:"lt,omitempty"`
	// Lte specifies that this field must be less than or equal to the
	// specified value, inclusive
	Lte *uint32 `protobuf:"varint,3,opt,name=lte" json:"lte,omitempty"`
	// Gt specifies that this field must be greater than the specified value,
	// exclusive. If the value of Gt is larger than a specified Lt or Lte, the
	// range is reversed.
	Gt *uint32 `protobuf:"varint,4,opt,name=gt" json:"gt,omitempty"`
	// Gte specifies that this field must be greater than or equal to the
	// specified value, inclusive. If the value of Gte is larger than a
	// specified Lt or Lte, the range is reversed.
	Gte *uint32 `protobuf:"varint,5,opt,name=gte" json:"gte,omitempty"`
	// In specifies that this field must be equal to one of the specified
	// values
	In []uint32 `protobuf:"varint,6,rep,name=in" json:"in,omitempty"`
	// NotIn specifies that this field cannot be equal to one of the specified
	// values
	NotIn            []uint32 `protobuf:"varint,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *UInt32Rules) Reset()                    { *m = UInt32Rules{} }
func (m *UInt32Rules) String() string            { return proto.CompactTextString(m) }
func (*UInt32Rules) ProtoMessage()               {}
func (*UInt32Rules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *UInt32Rules) GetConst() uint32 {
	if m != nil && m.Const != nil {
		return *m.Const
	}
	return 0
}

func (m *UInt32Rules) GetLt() uint32 {
	if m != nil && m.Lt != nil {
		return *m.Lt
	}
	return 0
}

func (m *UInt32Rules) GetLte() uint32 {
	if m != nil && m.Lte != nil {
		return *m.Lte
	}
	return 0
}

func (m *UInt32Rules) GetGt() uint32 {
	if m != nil && m.Gt != nil {
		return *m.Gt
	}
	return 0
}

func (m *UInt32Rules) GetGte() uint32 {
	if m != nil && m.Gte != nil {
		return *m.Gte
	}
	return 0
}

func (m *UInt32Rules) GetIn() []uint32 {
	if m != nil {
		return m.In
	}
	return nil
}

func (m *UInt32Rules) GetNotIn() []uint32 {
	if m != nil {
		return m.NotIn
	}
	return nil
}

// UInt64Rules describes the constraints applied to `uint64` values
type UInt64Rules struct {
	// Const specifies that this field must be exactly the specified value
	Const *uint64 `protobuf:"varint,1,opt,name=const" json:"const,omitempty"`
	// Lt specifies that this field must be less than the specified value,
	// exclusive
	Lt *uint64 `protobuf:"varint,2,opt,name=lt" json:"lt,omitempty"`
	// Lte specifies that this field must be less than or equal to the
	// specified value, inclusive
	Lte *uint64 `protobuf:"varint,3,opt,name=lte" json:"lte,omitempty"`
	// Gt specifies that this field must be greater than the specified value,
	// exclusive. If the value of Gt is larger than a specified Lt or Lte, the
	// range is reversed.
	Gt *uint64 `protobuf:"varint,4,opt,name=gt" json:"gt,omitempty"`
	// Gte specifies that this field must be greater than or equal to the
	// specified value, inclusive. If the value of Gte is larger than a
	// specified Lt or Lte, the range is reversed.
	Gte *uint64 `protobuf:"varint,5,opt,name=gte" json:"gte,omitempty"`
	// In specifies that this field must be equal to one of the specified
	// values
	In []uint64 `protobuf:"varint,6,rep,name=in" json:"in,omitempty"`
	// NotIn specifies that this field cannot be equal to one of the specified
	// values
	NotIn            []uint64 `protobuf:"varint,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *UInt64Rules) Reset()                    { *m = UInt64Rules{} }
func (m *UInt64Rules) String() string            { return proto.CompactTextString(m) }
func (*UInt64Rules) ProtoMessage()               {}
func (*UInt64Rules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *UInt64Rules) GetConst() uint64 {
	if m != nil && m.Const != nil {
		return *m.Const
	}
	return 0
}

func (m *UInt64Rules) GetLt() uint64 {
	if m != nil && m.Lt != nil {
		return *m.Lt
	}
	return 0
}

func (m *UInt64Rules) GetLte() uint64 {
	if m != nil && m.Lte != nil {
		return *m.Lte
	}
	return 0
}

func (m *UInt64Rules) GetGt() uint64 {
	if m != nil && m.Gt != nil {
		return *m.Gt
	}
	return 0
}

func (m *UInt64Rules) GetGte() uint64 {
	if m != nil && m.Gte != nil {
		return *m.Gte
	}
	return 0
}

func (m *UInt64Rules) GetIn() []uint64 {
	if m != nil {
		return m.In
	}
	return nil
}

func (m *UInt64Rules) GetNotIn() []uint64 {
	if m != nil {
		return m.NotIn
	}
	return nil
}

// SInt32Rules describes the constraints applied to `sint32` values
type SInt32Rules struct {
	// Const specifies that this field must be exactly the specified value
	Const *int32 `protobuf:"zigzag32,1,opt,name=const" json:"const,omitempty"`
	// Lt specifies that this field must be less than the specified value,
	// exclusive
	Lt *int32 `protobuf:"zigzag32,2,opt,name=lt" json:"lt,omitempty"`
	// Lte specifies that this field must be less than or equal to the
	// specified value, inclusive
	Lte *int32 `protobuf:"zigzag32,3,opt,name=lte" json:"lte,omitempty"`
	// Gt specifies that this field must be greater than the specified value,
	// exclusive. If the value of Gt is larger than a specified Lt or Lte, the
	// range is reversed.
	Gt *int32 `protobuf:"zigzag32,4,opt,name=gt" json:"gt,omitempty"`
	// Gte specifies that this field must be greater than or equal to the
	// specified value, inclusive. If the value of Gte is larger than a
	// specified Lt or Lte, the range is reversed.
	Gte *int32 `protobuf:"zigzag32,5,opt,name=gte" json:"gte,omitempty"`
	// In specifies that this field must be equal to one of the specified
	// values
	In []int32 `protobuf:"zigzag32,6,rep,name=in" json:"in,omitempty"`
	// NotIn specifies that this field cannot be equal to one of the specified
	// values
	NotIn            []int32 `protobuf:"zigzag32,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SInt32Rules) Reset()                    { *m = SInt32Rules{} }
func (m *SInt32Rules) String() string            { return proto.CompactTextString(m) }
func (*SInt32Rules) ProtoMessage()               {}
func (*SInt32Rules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *SInt32Rules) GetConst() int32 {
	if m != nil && m.Const != nil {
		return *m.Const
	}
	return 0
}

func (m *SInt32Rules) GetLt() int32 {
	if m != nil && m.Lt != nil {
		return *m.Lt
	}
	return 0
}

func (m *SInt32Rules) GetLte() int32 {
	if m != nil && m.Lte != nil {
		return *m.Lte
	}
	return 0
}

func (m *SInt32Rules) GetGt() int32 {
	if m != nil && m.Gt != nil {
		return *m.Gt
	}
	return 0
}

func (m *SInt32Rules) GetGte() int32 {
	if m != nil && m.Gte != nil {
		return *m.Gte
	}
	return 0
}

func (m *SInt32Rules) GetIn() []int32 {
	if m != nil {
		return m.In
	}
	return nil
}

func (m *SInt32Rules) GetNotIn() []int32 {
	if m != nil {
		return m.NotIn
	}
	return nil
}

// SInt64Rules describes the constraints applied to `sint64` values
type SInt64Rules struct {
	// Const specifies that this field must be exactly the specified value
	Const *int64 `protobuf:"zigzag64,1,opt,name=const" json:"const,omitempty"`
	// Lt specifies that this field must be less than the specified value,
	// exclusive
	Lt *int64 `protobuf:"zigzag64,2,opt,name=lt" json:"lt,omitempty"`
	// Lte specifies that this field must be less than or equal to the
	// specified value, inclusive
	Lte *int64 `protobuf:"zigzag64,3,opt,name=lte" json:"lte,omitempty"`
	// Gt specifies that this field must be greater than the specified value,
	// exclusive. If the value of Gt is larger than a specified Lt or Lte, the
	// range is reversed.
	Gt *int64 `protobuf:"zigzag64,4,opt,name=gt" json:"gt,omitempty"`
	// Gte specifies that this field must be greater than or equal to the
	// specified value, inclusive. If the value of Gte is larger than a
	// specified Lt or Lte, the range is reversed.
	Gte *int64 `protobuf:"zigzag64,5,opt,name=gte" json:"gte,omitempty"`
	// In specifies that this field must be equal to one of the specified
	// values
	In []int64 `protobuf:"zigzag64,6,rep,name=in" json:"in,omitempty"`
	// NotIn specifies that this field cannot be equal to one of the specified
	// values
	NotIn            []int64 `protobuf:"zigzag64,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SInt64Rules) Reset()                    { *m = SInt64Rules{} }
func (m *SInt64Rules) String() string            { return proto.CompactTextString(m) }
func (*SInt64Rules) ProtoMessage()               {}
func (*SInt64Rules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *SInt64Rules) GetConst() int64 {
	if m != nil && m.Const != nil {
		return *m.Const
	}
	return 0
}

func (m *SInt64Rules) GetLt() int64 {
	if m != nil && m.Lt != nil {
		return *m.Lt
	}
	return 0
}

func (m *SInt64Rules) GetLte() int64 {
	if m != nil && m.Lte != nil {
		return *m.Lte
	}
	return 0
}

func (m *SInt64Rules) GetGt() int64 {
	if m != nil && m.Gt != nil {
		return *m.Gt
	}
	return 0
}

func (m *SInt64Rules) GetGte() int64 {
	if m != nil && m.Gte != nil {
		return *m.Gte
	}
	return 0
}

func (m *SInt64Rules) GetIn() []int64 {
	if m != nil {
		return m.In
	}
	return nil
}

func (m *SInt64Rules) GetNotIn() []int64 {
	if m != nil {
		return m.NotIn
	}
	return nil
}

// Fixed32Rules describes the constraints applied to `fixed32` values
type Fixed32Rules struct {
	// Const specifies that this field must be exactly the specified value
	Const *uint32 `protobuf:"fixed32,1,opt,name=const" json:"const,omitempty"`
	// Lt specifies that this field must be less than the specified value,
	// exclusive
	Lt *uint32 `protobuf:"fixed32,2,opt,name=lt" json:"lt,omitempty"`
	// Lte specifies that this field must be less than or equal to the
	// specified value, inclusive
	Lte *uint32 `protobuf:"fixed32,3,opt,name=lte" json:"lte,omitempty"`
	// Gt specifies that this field must be greater than the specified value,
	// exclusive. If the value of Gt is larger than a specified Lt or Lte, the
	// range is reversed.
	Gt *uint32 `protobuf:"fixed32,4,opt,name=gt" json:"gt,omitempty"`
	// Gte specifies that this field must be greater than or equal to the
	// specified value, inclusive. If the value of Gte is larger than a
	// specified Lt or Lte, the range is reversed.
	Gte *uint32 `protobuf:"fixed32,5,opt,name=gte" json:"gte,omitempty"`
	// In specifies that this field must be equal to one of the specified
	// values
	In []uint32 `protobuf:"fixed32,6,rep,name=in" json:"in,omitempty"`
	// NotIn specifies that this field cannot be equal to one of the specified
	// values
	NotIn            []uint32 `protobuf:"fixed32,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Fixed32Rules) Reset()                    { *m = Fixed32Rules{} }
func (m *Fixed32Rules) String() string            { return proto.CompactTextString(m) }
func (*Fixed32Rules) ProtoMessage()               {}
func (*Fixed32Rules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Fixed32Rules) GetConst() uint32 {
	if m != nil && m.Const != nil {
		return *m.Const
	}
	return 0
}

func (m *Fixed32Rules) GetLt() uint32 {
	if m != nil && m.Lt != nil {
		return *m.Lt
	}
	return 0
}

func (m *Fixed32Rules) GetLte() uint32 {
	if m != nil && m.Lte != nil {
		return *m.Lte
	}
	return 0
}

func (m *Fixed32Rules) GetGt() uint32 {
	if m != nil && m.Gt != nil {
		return *m.Gt
	}
	return 0
}

func (m *Fixed32Rules) GetGte() uint32 {
	if m != nil && m.Gte != nil {
		return *m.Gte
	}
	return 0
}

func (m *Fixed32Rules) GetIn() []uint32 {
	if m != nil {
		return m.In
	}
	return nil
}

func (m *Fixed32Rules) GetNotIn() []uint32 {
	if m != nil {
		return m.NotIn
	}
	return nil
}

// Fixed64Rules describes the constraints applied to `fixed64` values
type Fixed64Rules struct {
	// Const specifies that this field must be exactly the specified value
	Const *uint64 `protobuf:"fixed64,1,opt,name=const" json:"const,omitempty"`
	// Lt specifies that this field must be less than the specified value,
	// exclusive
	Lt *uint64 `protobuf:"fixed64,2,opt,name=lt" json:"lt,omitempty"`
	// Lte specifies that this field must be less than or equal to the
	// specified value, inclusive
	Lte *uint64 `protobuf:"fixed64,3,opt,name=lte" json:"lte,omitempty"`
	// Gt specifies that this field must be greater than the specified value,
	// exclusive. If the value of Gt is larger than a specified Lt or Lte, the
	// range is reversed.
	Gt *uint64 `protobuf:"fixed64,4,opt,name=gt" json:"gt,omitempty"`
	// Gte specifies that this field must be greater than or equal to the
	// specified value, inclusive. If the value of Gte is larger than a
	// specified Lt or Lte, the range is reversed.
	Gte *uint64 `protobuf:"fixed64,5,opt,name=gte" json:"gte,omitempty"`
	// In specifies that this field must be equal to one of the specified
	// values
	In []uint64 `protobuf:"fixed64,6,rep,name=in" json:"in,omitempty"`
	// NotIn specifies that this field cannot be equal to one of the specified
	// values
	NotIn            []uint64 `protobuf:"fixed64,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Fixed64Rules) Reset()                    { *m = Fixed64Rules{} }
func (m *Fixed64Rules) String() string            { return proto.CompactTextString(m) }
func (*Fixed64Rules) ProtoMessage()               {}
func (*Fixed64Rules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *Fixed64Rules) GetConst() uint64 {
	if m != nil && m.Const != nil {
		return *m.Const
	}
	return 0
}

func (m *Fixed64Rules) GetLt() uint64 {
	if m != nil && m.Lt != nil {
		return *m.Lt
	}
	return 0
}

func (m *Fixed64Rules) GetLte() uint64 {
	if m != nil && m.Lte != nil {
		return *m.Lte
	}
	return 0
}

func (m *Fixed64Rules) GetGt() uint64 {
	if m != nil && m.Gt != nil {
		return *m.Gt
	}
	return 0
}

func (m *Fixed64Rules) GetGte() uint64 {
	if m != nil && m.Gte != nil {
		return *m.Gte
	}
	return 0
}

func (m *Fixed64Rules) GetIn() []uint64 {
	if m != nil {
		return m.In
	}
	return nil
}

func (m *Fixed64Rules) GetNotIn() []uint64 {
	if m != nil {
		return m.NotIn
	}
	return nil
}

// SFixed32Rules describes the constraints applied to `sfixed32` values
type SFixed32Rules struct {
	// Const specifies that this field must be exactly the specified value
	Const *int32 `protobuf:"fixed32,1,opt,name=const" json:"const,omitempty"`
	// Lt specifies that this field must be less than the specified value,
	// exclusive
	Lt *int32 `protobuf:"fixed32,2,opt,name=lt" json:"lt,omitempty"`
	// Lte specifies that this field must be less than or equal to the
	// specified value, inclusive
	Lte *int32 `protobuf:"fixed32,3,opt,name=lte" json:"lte,omitempty"`
	// Gt specifies that this field must be greater than the specified value,
	// exclusive. If the value of Gt is larger than a specified Lt or Lte, the
	// range is reversed.
	Gt *int32 `protobuf:"fixed32,4,opt,name=gt" json:"gt,omitempty"`
	// Gte specifies that this field must be greater than or equal to the
	// specified value, inclusive. If the value of Gte is larger than a
	// specified Lt or Lte, the range is reversed.
	Gte *int32 `protobuf:"fixed32,5,opt,name=gte" json:"gte,omitempty"`
	// In specifies that this field must be equal to one of the specified
	// values
	In []int32 `protobuf:"fixed32,6,rep,name=in" json:"in,omitempty"`
	// NotIn specifies that this field cannot be equal to one of the specified
	// values
	NotIn            []int32 `protobuf:"fixed32,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SFixed32Rules) Reset()                    { *m = SFixed32Rules{} }
func (m *SFixed32Rules) String() string            { return proto.CompactTextString(m) }
func (*SFixed32Rules) ProtoMessage()               {}
func (*SFixed32Rules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *SFixed32Rules) GetConst() int32 {
	if m != nil && m.Const != nil {
		return *m.Const
	}
	return 0
}

func (m *SFixed32Rules) GetLt() int32 {
	if m != nil && m.Lt != nil {
		return *m.Lt
	}
	return 0
}

func (m *SFixed32Rules) GetLte() int32 {
	if m != nil && m.Lte != nil {
		return *m.Lte
	}
	return 0
}

func (m *SFixed32Rules) GetGt() int32 {
	if m != nil && m.Gt != nil {
		return *m.Gt
	}
	return 0
}

func (m *SFixed32Rules) GetGte() int32 {
	if m != nil && m.Gte != nil {
		return *m.Gte
	}
	return 0
}

func (m *SFixed32Rules) GetIn() []int32 {
	if m != nil {
		return m.In
	}
	return nil
}

func (m *SFixed32Rules) GetNotIn() []int32 {
	if m != nil {
		return m.NotIn
	}
	return nil
}

// SFixed64Rules describes the constraints applied to `sfixed64` values
type SFixed64Rules struct {
	// Const specifies that this field must be exactly the specified value
	Const *int64 `protobuf:"fixed64,1,opt,name=const" json:"const,omitempty"`
	// Lt specifies that this field must be less than the specified value,
	// exclusive
	Lt *int64 `protobuf:"fixed64,2,opt,name=lt" json:"lt,omitempty"`
	// Lte specifies that this field must be less than or equal to the
	// specified value, inclusive
	Lte *int64 `protobuf:"fixed64,3,opt,name=lte" json:"lte,omitempty"`
	// Gt specifies that this field must be greater than the specified value,
	// exclusive. If the value of Gt is larger than a specified Lt or Lte, the
	// range is reversed.
	Gt *int64 `protobuf:"fixed64,4,opt,name=gt" json:"gt,omitempty"`
	// Gte specifies that this field must be greater than or equal to the
	// specified value, inclusive. If the value of Gte is larger than a
	// specified Lt or Lte, the range is reversed.
	Gte *int64 `protobuf:"fixed64,5,opt,name=gte" json:"gte,omitempty"`
	// In specifies that this field must be equal to one of the specified
	// values
	In []int64 `protobuf:"fixed64,6,rep,name=in" json:"in,omitempty"`
	// NotIn specifies that this field cannot be equal to one of the specified
	// values
	NotIn            []int64 `protobuf:"fixed64,7,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SFixed64Rules) Reset()                    { *m = SFixed64Rules{} }
func (m *SFixed64Rules) String() string            { return proto.CompactTextString(m) }
func (*SFixed64Rules) ProtoMessage()               {}
func (*SFixed64Rules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *SFixed64Rules) GetConst() int64 {
	if m != nil && m.Const != nil {
		return *m.Const
	}
	return 0
}

func (m *SFixed64Rules) GetLt() int64 {
	if m != nil && m.Lt != nil {
		return *m.Lt
	}
	return 0
}

func (m *SFixed64Rules) GetLte() int64 {
	if m != nil && m.Lte != nil {
		return *m.Lte
	}
	return 0
}

func (m *SFixed64Rules) GetGt() int64 {
	if m != nil && m.Gt != nil {
		return *m.Gt
	}
	return 0
}

func (m *SFixed64Rules) GetGte() int64 {
	if m != nil && m.Gte != nil {
		return *m.Gte
	}
	return 0
}

func (m *SFixed64Rules) GetIn() []int64 {
	if m != nil {
		return m.In
	}
	return nil
}

func (m *SFixed64Rules) GetNotIn() []int64 {
	if m != nil {
		return m.NotIn
	}
	return nil
}

// BoolRules describes the constraints applied to `bool` values
type BoolRules struct {
	// Const specifies that this field must be exactly the specified value
	Const            *bool  `protobuf:"varint,1,opt,name=const" json:"const,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *BoolRules) Reset()                    { *m = BoolRules{} }
func (m *BoolRules) String() string            { return proto.CompactTextString(m) }
func (*BoolRules) ProtoMessage()               {}
func (*BoolRules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *BoolRules) GetConst() bool {
	if m != nil && m.Const != nil {
		return *m.Const
	}
	return false
}

// StringRules describe the constraints applied to `string` values
type StringRules struct {
	// Const specifies that this field must be exactly the specified value
	Const *string `protobuf:"bytes,1,opt,name=const" json:"const,omitempty"`
	// MinLen specifies that this field must be the specified number of
	// characters (Unicode code points) at a minimum. Note that the number of
	// characters may differ from the number of bytes in the string.
	MinLen *uint64 `protobuf:"varint,2,opt,name=min_len,json=minLen" json:"min_len,omitempty"`
	// MaxLen specifies that this field must be the specified number of
	// characters (Unicode code points) at a maximum. Note that the number of
	// characters may differ from the number of bytes in the string.
	MaxLen *uint64 `protobuf:"varint,3,opt,name=max_len,json=maxLen" json:"max_len,omitempty"`
	// MinBytes specifies that this field must be the specified number of bytes
	// at a minimum
	MinBytes *uint64 `protobuf:"varint,4,opt,name=min_bytes,json=minBytes" json:"min_bytes,omitempty"`
	// MaxBytes specifies that this field must be the specified number of bytes
	// at a maximum
	MaxBytes *uint64 `protobuf:"varint,5,opt,name=max_bytes,json=maxBytes" json:"max_bytes,omitempty"`
	// Pattern specifes that this field must match against the specified
	// regular expression (RE2 syntax). The included expression should elide
	// any delimiters.
	Pattern *string `protobuf:"bytes,6,opt,name=pattern" json:"pattern,omitempty"`
	// Prefix specifies that this field must have the specified substring at
	// the beginning of the string.
	Prefix *string `protobuf:"bytes,7,opt,name=prefix" json:"prefix,omitempty"`
	// Suffix specifies that this field must have the specified substring at
	// the end of the string.
	Suffix *string `protobuf:"bytes,8,opt,name=suffix" json:"suffix,omitempty"`
	// Contains specifies that this field must have the specified substring
	// anywhere in the string.
	Contains *string `protobuf:"bytes,9,opt,name=contains" json:"contains,omitempty"`
	// In specifies that this field must be equal to one of the specified
	// values
	In []string `protobuf:"bytes,10,rep,name=in" json:"in,omitempty"`
	// NotIn specifies that this field cannot be equal to one of the specified
	// values
	NotIn []string `protobuf:"bytes,11,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
	// WellKnown rules provide advanced constraints against common string
	// patterns
	//
	// Types that are valid to be assigned to WellKnown:
	//	*StringRules_Email
	//	*StringRules_Hostname
	//	*StringRules_Ip
	//	*StringRules_Ipv4
	//	*StringRules_Ipv6
	//	*StringRules_Uri
	//	*StringRules_UriRef
	WellKnown        isStringRules_WellKnown `protobuf_oneof:"well_known"`
	XXX_unrecognized []byte                  `json:"-"`
}

func (m *StringRules) Reset()                    { *m = StringRules{} }
func (m *StringRules) String() string            { return proto.CompactTextString(m) }
func (*StringRules) ProtoMessage()               {}
func (*StringRules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

type isStringRules_WellKnown interface {
	isStringRules_WellKnown()
}

type StringRules_Email struct {
	Email bool `protobuf:"varint,12,opt,name=email,oneof"`
}
type StringRules_Hostname struct {
	Hostname bool `protobuf:"varint,13,opt,name=hostname,oneof"`
}
type StringRules_Ip struct {
	Ip bool `protobuf:"varint,14,opt,name=ip,oneof"`
}
type StringRules_Ipv4 struct {
	Ipv4 bool `protobuf:"varint,15,opt,name=ipv4,oneof"`
}
type StringRules_Ipv6 struct {
	Ipv6 bool `protobuf:"varint,16,opt,name=ipv6,oneof"`
}
type StringRules_Uri struct {
	Uri bool `protobuf:"varint,17,opt,name=uri,oneof"`
}
type StringRules_UriRef struct {
	UriRef bool `protobuf:"varint,18,opt,name=uri_ref,json=uriRef,oneof"`
}

func (*StringRules_Email) isStringRules_WellKnown()    {}
func (*StringRules_Hostname) isStringRules_WellKnown() {}
func (*StringRules_Ip) isStringRules_WellKnown()       {}
func (*StringRules_Ipv4) isStringRules_WellKnown()     {}
func (*StringRules_Ipv6) isStringRules_WellKnown()     {}
func (*StringRules_Uri) isStringRules_WellKnown()      {}
func (*StringRules_UriRef) isStringRules_WellKnown()   {}

func (m *StringRules) GetWellKnown() isStringRules_WellKnown {
	if m != nil {
		return m.WellKnown
	}
	return nil
}

func (m *StringRules) GetConst() string {
	if m != nil && m.Const != nil {
		return *m.Const
	}
	return ""
}

func (m *StringRules) GetMinLen() uint64 {
	if m != nil && m.MinLen != nil {
		return *m.MinLen
	}
	return 0
}

func (m *StringRules) GetMaxLen() uint64 {
	if m != nil && m.MaxLen != nil {
		return *m.MaxLen
	}
	return 0
}

func (m *StringRules) GetMinBytes() uint64 {
	if m != nil && m.MinBytes != nil {
		return *m.MinBytes
	}
	return 0
}

func (m *StringRules) GetMaxBytes() uint64 {
	if m != nil && m.MaxBytes != nil {
		return *m.MaxBytes
	}
	return 0
}

func (m *StringRules) GetPattern() string {
	if m != nil && m.Pattern != nil {
		return *m.Pattern
	}
	return ""
}

func (m *StringRules) GetPrefix() string {
	if m != nil && m.Prefix != nil {
		return *m.Prefix
	}
	return ""
}

func (m *StringRules) GetSuffix() string {
	if m != nil && m.Suffix != nil {
		return *m.Suffix
	}
	return ""
}

func (m *StringRules) GetContains() string {
	if m != nil && m.Contains != nil {
		return *m.Contains
	}
	return ""
}

func (m *StringRules) GetIn() []string {
	if m != nil {
		return m.In
	}
	return nil
}

func (m *StringRules) GetNotIn() []string {
	if m != nil {
		return m.NotIn
	}
	return nil
}

func (m *StringRules) GetEmail() bool {
	if x, ok := m.GetWellKnown().(*StringRules_Email); ok {
		return x.Email
	}
	return false
}

func (m *StringRules) GetHostname() bool {
	if x, ok := m.GetWellKnown().(*StringRules_Hostname); ok {
		return x.Hostname
	}
	return false
}

func (m *StringRules) GetIp() bool {
	if x, ok := m.GetWellKnown().(*StringRules_Ip); ok {
		return x.Ip
	}
	return false
}

func (m *StringRules) GetIpv4() bool {
	if x, ok := m.GetWellKnown().(*StringRules_Ipv4); ok {
		return x.Ipv4
	}
	return false
}

func (m *StringRules) GetIpv6() bool {
	if x, ok := m.GetWellKnown().(*StringRules_Ipv6); ok {
		return x.Ipv6
	}
	return false
}

func (m *StringRules) GetUri() bool {
	if x, ok := m.GetWellKnown().(*StringRules_Uri); ok {
		return x.Uri
	}
	return false
}

func (m *StringRules) GetUriRef() bool {
	if x, ok := m.GetWellKnown().(*StringRules_UriRef); ok {
		return x.UriRef
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StringRules) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StringRules_OneofMarshaler, _StringRules_OneofUnmarshaler, _StringRules_OneofSizer, []interface{}{
		(*StringRules_Email)(nil),
		(*StringRules_Hostname)(nil),
		(*StringRules_Ip)(nil),
		(*StringRules_Ipv4)(nil),
		(*StringRules_Ipv6)(nil),
		(*StringRules_Uri)(nil),
		(*StringRules_UriRef)(nil),
	}
}

func _StringRules_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StringRules)
	// well_known
	switch x := m.WellKnown.(type) {
	case *StringRules_Email:
		t := uint64(0)
		if x.Email {
			t = 1
		}
		b.EncodeVarint(12<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *StringRules_Hostname:
		t := uint64(0)
		if x.Hostname {
			t = 1
		}
		b.EncodeVarint(13<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *StringRules_Ip:
		t := uint64(0)
		if x.Ip {
			t = 1
		}
		b.EncodeVarint(14<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *StringRules_Ipv4:
		t := uint64(0)
		if x.Ipv4 {
			t = 1
		}
		b.EncodeVarint(15<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *StringRules_Ipv6:
		t := uint64(0)
		if x.Ipv6 {
			t = 1
		}
		b.EncodeVarint(16<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *StringRules_Uri:
		t := uint64(0)
		if x.Uri {
			t = 1
		}
		b.EncodeVarint(17<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *StringRules_UriRef:
		t := uint64(0)
		if x.UriRef {
			t = 1
		}
		b.EncodeVarint(18<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("StringRules.WellKnown has unexpected type %T", x)
	}
	return nil
}

func _StringRules_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StringRules)
	switch tag {
	case 12: // well_known.email
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.WellKnown = &StringRules_Email{x != 0}
		return true, err
	case 13: // well_known.hostname
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.WellKnown = &StringRules_Hostname{x != 0}
		return true, err
	case 14: // well_known.ip
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.WellKnown = &StringRules_Ip{x != 0}
		return true, err
	case 15: // well_known.ipv4
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.WellKnown = &StringRules_Ipv4{x != 0}
		return true, err
	case 16: // well_known.ipv6
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.WellKnown = &StringRules_Ipv6{x != 0}
		return true, err
	case 17: // well_known.uri
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.WellKnown = &StringRules_Uri{x != 0}
		return true, err
	case 18: // well_known.uri_ref
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.WellKnown = &StringRules_UriRef{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _StringRules_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StringRules)
	// well_known
	switch x := m.WellKnown.(type) {
	case *StringRules_Email:
		n += proto.SizeVarint(12<<3 | proto.WireVarint)
		n += 1
	case *StringRules_Hostname:
		n += proto.SizeVarint(13<<3 | proto.WireVarint)
		n += 1
	case *StringRules_Ip:
		n += proto.SizeVarint(14<<3 | proto.WireVarint)
		n += 1
	case *StringRules_Ipv4:
		n += proto.SizeVarint(15<<3 | proto.WireVarint)
		n += 1
	case *StringRules_Ipv6:
		n += proto.SizeVarint(16<<3 | proto.WireVarint)
		n += 1
	case *StringRules_Uri:
		n += proto.SizeVarint(17<<3 | proto.WireVarint)
		n += 1
	case *StringRules_UriRef:
		n += proto.SizeVarint(18<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// BytesRules describe the constraints applied to `bytes` values
type BytesRules struct {
	// Const specifies that this field must be exactly the specified value
	Const []byte `protobuf:"bytes,1,opt,name=const" json:"const,omitempty"`
	// MinLen specifies that this field must be the specified number of bytes
	// at a minimum
	MinLen *uint64 `protobuf:"varint,2,opt,name=min_len,json=minLen" json:"min_len,omitempty"`
	// MaxLen specifies that this field must be the specified number of bytes
	// at a maximum
	MaxLen *uint64 `protobuf:"varint,3,opt,name=max_len,json=maxLen" json:"max_len,omitempty"`
	// Pattern specifes that this field must match against the specified
	// regular expression (RE2 syntax). The included expression should elide
	// any delimiters.
	Pattern *string `protobuf:"bytes,4,opt,name=pattern" json:"pattern,omitempty"`
	// Prefix specifies that this field must have the specified bytes at the
	// beginning of the string.
	Prefix []byte `protobuf:"bytes,5,opt,name=prefix" json:"prefix,omitempty"`
	// Suffix specifies that this field must have the specified bytes at the
	// end of the string.
	Suffix []byte `protobuf:"bytes,6,opt,name=suffix" json:"suffix,omitempty"`
	// Contains specifies that this field must have the specified bytes
	// anywhere in the string.
	Contains []byte `protobuf:"bytes,7,opt,name=contains" json:"contains,omitempty"`
	// In specifies that this field must be equal to one of the specified
	// values
	In [][]byte `protobuf:"bytes,8,rep,name=in" json:"in,omitempty"`
	// NotIn specifies that this field cannot be equal to one of the specified
	// values
	NotIn [][]byte `protobuf:"bytes,9,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
	// WellKnown rules provide advanced constraints against common byte
	// patterns
	//
	// Types that are valid to be assigned to WellKnown:
	//	*BytesRules_Ip
	//	*BytesRules_Ipv4
	//	*BytesRules_Ipv6
	WellKnown        isBytesRules_WellKnown `protobuf_oneof:"well_known"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *BytesRules) Reset()                    { *m = BytesRules{} }
func (m *BytesRules) String() string            { return proto.CompactTextString(m) }
func (*BytesRules) ProtoMessage()               {}
func (*BytesRules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

type isBytesRules_WellKnown interface {
	isBytesRules_WellKnown()
}

type BytesRules_Ip struct {
	Ip bool `protobuf:"varint,10,opt,name=ip,oneof"`
}
type BytesRules_Ipv4 struct {
	Ipv4 bool `protobuf:"varint,11,opt,name=ipv4,oneof"`
}
type BytesRules_Ipv6 struct {
	Ipv6 bool `protobuf:"varint,12,opt,name=ipv6,oneof"`
}

func (*BytesRules_Ip) isBytesRules_WellKnown()   {}
func (*BytesRules_Ipv4) isBytesRules_WellKnown() {}
func (*BytesRules_Ipv6) isBytesRules_WellKnown() {}

func (m *BytesRules) GetWellKnown() isBytesRules_WellKnown {
	if m != nil {
		return m.WellKnown
	}
	return nil
}

func (m *BytesRules) GetConst() []byte {
	if m != nil {
		return m.Const
	}
	return nil
}

func (m *BytesRules) GetMinLen() uint64 {
	if m != nil && m.MinLen != nil {
		return *m.MinLen
	}
	return 0
}

func (m *BytesRules) GetMaxLen() uint64 {
	if m != nil && m.MaxLen != nil {
		return *m.MaxLen
	}
	return 0
}

func (m *BytesRules) GetPattern() string {
	if m != nil && m.Pattern != nil {
		return *m.Pattern
	}
	return ""
}

func (m *BytesRules) GetPrefix() []byte {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *BytesRules) GetSuffix() []byte {
	if m != nil {
		return m.Suffix
	}
	return nil
}

func (m *BytesRules) GetContains() []byte {
	if m != nil {
		return m.Contains
	}
	return nil
}

func (m *BytesRules) GetIn() [][]byte {
	if m != nil {
		return m.In
	}
	return nil
}

func (m *BytesRules) GetNotIn() [][]byte {
	if m != nil {
		return m.NotIn
	}
	return nil
}

func (m *BytesRules) GetIp() bool {
	if x, ok := m.GetWellKnown().(*BytesRules_Ip); ok {
		return x.Ip
	}
	return false
}

func (m *BytesRules) GetIpv4() bool {
	if x, ok := m.GetWellKnown().(*BytesRules_Ipv4); ok {
		return x.Ipv4
	}
	return false
}

func (m *BytesRules) GetIpv6() bool {
	if x, ok := m.GetWellKnown().(*BytesRules_Ipv6); ok {
		return x.Ipv6
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*BytesRules) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _BytesRules_OneofMarshaler, _BytesRules_OneofUnmarshaler, _BytesRules_OneofSizer, []interface{}{
		(*BytesRules_Ip)(nil),
		(*BytesRules_Ipv4)(nil),
		(*BytesRules_Ipv6)(nil),
	}
}

func _BytesRules_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*BytesRules)
	// well_known
	switch x := m.WellKnown.(type) {
	case *BytesRules_Ip:
		t := uint64(0)
		if x.Ip {
			t = 1
		}
		b.EncodeVarint(10<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *BytesRules_Ipv4:
		t := uint64(0)
		if x.Ipv4 {
			t = 1
		}
		b.EncodeVarint(11<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *BytesRules_Ipv6:
		t := uint64(0)
		if x.Ipv6 {
			t = 1
		}
		b.EncodeVarint(12<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("BytesRules.WellKnown has unexpected type %T", x)
	}
	return nil
}

func _BytesRules_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*BytesRules)
	switch tag {
	case 10: // well_known.ip
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.WellKnown = &BytesRules_Ip{x != 0}
		return true, err
	case 11: // well_known.ipv4
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.WellKnown = &BytesRules_Ipv4{x != 0}
		return true, err
	case 12: // well_known.ipv6
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.WellKnown = &BytesRules_Ipv6{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _BytesRules_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*BytesRules)
	// well_known
	switch x := m.WellKnown.(type) {
	case *BytesRules_Ip:
		n += proto.SizeVarint(10<<3 | proto.WireVarint)
		n += 1
	case *BytesRules_Ipv4:
		n += proto.SizeVarint(11<<3 | proto.WireVarint)
		n += 1
	case *BytesRules_Ipv6:
		n += proto.SizeVarint(12<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// EnumRules describe the constraints applied to enum values
type EnumRules struct {
	// Const specifies that this field must be exactly the specified value
	Const *int32 `protobuf:"varint,1,opt,name=const" json:"const,omitempty"`
	// DefinedOnly specifies that this field must be only one of the defined
	// values for this enum, failing on any undefined value.
	DefinedOnly *bool `protobuf:"varint,2,opt,name=defined_only,json=definedOnly" json:"defined_only,omitempty"`
	// In specifies that this field must be equal to one of the specified
	// values
	In []int32 `protobuf:"varint,3,rep,name=in" json:"in,omitempty"`
	// NotIn specifies that this field cannot be equal to one of the specified
	// values
	NotIn            []int32 `protobuf:"varint,4,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EnumRules) Reset()                    { *m = EnumRules{} }
func (m *EnumRules) String() string            { return proto.CompactTextString(m) }
func (*EnumRules) ProtoMessage()               {}
func (*EnumRules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *EnumRules) GetConst() int32 {
	if m != nil && m.Const != nil {
		return *m.Const
	}
	return 0
}

func (m *EnumRules) GetDefinedOnly() bool {
	if m != nil && m.DefinedOnly != nil {
		return *m.DefinedOnly
	}
	return false
}

func (m *EnumRules) GetIn() []int32 {
	if m != nil {
		return m.In
	}
	return nil
}

func (m *EnumRules) GetNotIn() []int32 {
	if m != nil {
		return m.NotIn
	}
	return nil
}

// MessageRules describe the constraints applied to embedded message values.
// For message-type fields, validation is performed recursively.
type MessageRules struct {
	// Skip specifies that the validation rules of this field should not be
	// evaluated
	Skip *bool `protobuf:"varint,1,opt,name=skip" json:"skip,omitempty"`
	// Required specifies that this field must be set
	Required         *bool  `protobuf:"varint,2,opt,name=required" json:"required,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *MessageRules) Reset()                    { *m = MessageRules{} }
func (m *MessageRules) String() string            { return proto.CompactTextString(m) }
func (*MessageRules) ProtoMessage()               {}
func (*MessageRules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *MessageRules) GetSkip() bool {
	if m != nil && m.Skip != nil {
		return *m.Skip
	}
	return false
}

func (m *MessageRules) GetRequired() bool {
	if m != nil && m.Required != nil {
		return *m.Required
	}
	return false
}

// RepeatedRules describe the constraints applied to `repeated` values
type RepeatedRules struct {
	// MinItems specifies that this field must have the specified number of
	// items at a minimum
	MinItems *uint64 `protobuf:"varint,1,opt,name=min_items,json=minItems" json:"min_items,omitempty"`
	// MaxItems specifies that this field must have the specified number of
	// items at a maximum
	MaxItems *uint64 `protobuf:"varint,2,opt,name=max_items,json=maxItems" json:"max_items,omitempty"`
	// Unique specifies that all elements in this field must be unique. This
	// contraint is only applicable to scalar and enum types (messages are not
	// supported).
	Unique *bool `protobuf:"varint,3,opt,name=unique" json:"unique,omitempty"`
	// Items specifies the contraints to be applied to each item in the field.
	// Repeated message fields will still execute validation against each item
	// unless skip is specified here.
	Items            *FieldRules `protobuf:"bytes,4,opt,name=items" json:"items,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *RepeatedRules) Reset()                    { *m = RepeatedRules{} }
func (m *RepeatedRules) String() string            { return proto.CompactTextString(m) }
func (*RepeatedRules) ProtoMessage()               {}
func (*RepeatedRules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *RepeatedRules) GetMinItems() uint64 {
	if m != nil && m.MinItems != nil {
		return *m.MinItems
	}
	return 0
}

func (m *RepeatedRules) GetMaxItems() uint64 {
	if m != nil && m.MaxItems != nil {
		return *m.MaxItems
	}
	return 0
}

func (m *RepeatedRules) GetUnique() bool {
	if m != nil && m.Unique != nil {
		return *m.Unique
	}
	return false
}

func (m *RepeatedRules) GetItems() *FieldRules {
	if m != nil {
		return m.Items
	}
	return nil
}

// MapRules describe the constraints applied to `map` values
type MapRules struct {
	// MinPairs specifies that this field must have the specified number of
	// KVs at a minimum
	MinPairs *uint64 `protobuf:"varint,1,opt,name=min_pairs,json=minPairs" json:"min_pairs,omitempty"`
	// MaxPairs specifies that this field must have the specified number of
	// KVs at a maximum
	MaxPairs *uint64 `protobuf:"varint,2,opt,name=max_pairs,json=maxPairs" json:"max_pairs,omitempty"`
	// NoSparse specifies values in this field cannot be unset. This only
	// applies to map's with message value types.
	NoSparse *bool `protobuf:"varint,3,opt,name=no_sparse,json=noSparse" json:"no_sparse,omitempty"`
	// Keys specifies the constraints to be applied to each key in the field.
	Keys *FieldRules `protobuf:"bytes,4,opt,name=keys" json:"keys,omitempty"`
	// Values specifies the constraints to be applied to the value of each key
	// in the field. Message values will still have their validations evaluated
	// unless skip is specified here.
	Values           *FieldRules `protobuf:"bytes,5,opt,name=values" json:"values,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *MapRules) Reset()                    { *m = MapRules{} }
func (m *MapRules) String() string            { return proto.CompactTextString(m) }
func (*MapRules) ProtoMessage()               {}
func (*MapRules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *MapRules) GetMinPairs() uint64 {
	if m != nil && m.MinPairs != nil {
		return *m.MinPairs
	}
	return 0
}

func (m *MapRules) GetMaxPairs() uint64 {
	if m != nil && m.MaxPairs != nil {
		return *m.MaxPairs
	}
	return 0
}

func (m *MapRules) GetNoSparse() bool {
	if m != nil && m.NoSparse != nil {
		return *m.NoSparse
	}
	return false
}

func (m *MapRules) GetKeys() *FieldRules {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *MapRules) GetValues() *FieldRules {
	if m != nil {
		return m.Values
	}
	return nil
}

// AnyRules describe constraints applied exclusively to the
// `google.protobuf.Any` well-known type
type AnyRules struct {
	// Required specifies that this field must be set
	Required *bool `protobuf:"varint,1,opt,name=required" json:"required,omitempty"`
	// In specifies that this field's `type_url` must be equal to one of the
	// specified values.
	In []string `protobuf:"bytes,2,rep,name=in" json:"in,omitempty"`
	// NotIn specifies that this field's `type_url` must not be equal to any of
	// the specified values.
	NotIn            []string `protobuf:"bytes,3,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *AnyRules) Reset()                    { *m = AnyRules{} }
func (m *AnyRules) String() string            { return proto.CompactTextString(m) }
func (*AnyRules) ProtoMessage()               {}
func (*AnyRules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *AnyRules) GetRequired() bool {
	if m != nil && m.Required != nil {
		return *m.Required
	}
	return false
}

func (m *AnyRules) GetIn() []string {
	if m != nil {
		return m.In
	}
	return nil
}

func (m *AnyRules) GetNotIn() []string {
	if m != nil {
		return m.NotIn
	}
	return nil
}

// DurationRules describe the constraints applied exclusively to the
// `google.protobuf.Duration` well-known type
type DurationRules struct {
	// Required specifies that this field must be set
	Required *bool `protobuf:"varint,1,opt,name=required" json:"required,omitempty"`
	// Const specifies that this field must be exactly the specified value
	Const *google_protobuf1.Duration `protobuf:"bytes,2,opt,name=const" json:"const,omitempty"`
	// Lt specifies that this field must be less than the specified value,
	// exclusive
	Lt *google_protobuf1.Duration `protobuf:"bytes,3,opt,name=lt" json:"lt,omitempty"`
	// Lt specifies that this field must be less than the specified value,
	// inclusive
	Lte *google_protobuf1.Duration `protobuf:"bytes,4,opt,name=lte" json:"lte,omitempty"`
	// Gt specifies that this field must be greater than the specified value,
	// exclusive
	Gt *google_protobuf1.Duration `protobuf:"bytes,5,opt,name=gt" json:"gt,omitempty"`
	// Gte specifies that this field must be greater than the specified value,
	// inclusive
	Gte *google_protobuf1.Duration `protobuf:"bytes,6,opt,name=gte" json:"gte,omitempty"`
	// In specifies that this field must be equal to one of the specified
	// values
	In []*google_protobuf1.Duration `protobuf:"bytes,7,rep,name=in" json:"in,omitempty"`
	// NotIn specifies that this field cannot be equal to one of the specified
	// values
	NotIn            []*google_protobuf1.Duration `protobuf:"bytes,8,rep,name=not_in,json=notIn" json:"not_in,omitempty"`
	XXX_unrecognized []byte                       `json:"-"`
}

func (m *DurationRules) Reset()                    { *m = DurationRules{} }
func (m *DurationRules) String() string            { return proto.CompactTextString(m) }
func (*DurationRules) ProtoMessage()               {}
func (*DurationRules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *DurationRules) GetRequired() bool {
	if m != nil && m.Required != nil {
		return *m.Required
	}
	return false
}

func (m *DurationRules) GetConst() *google_protobuf1.Duration {
	if m != nil {
		return m.Const
	}
	return nil
}

func (m *DurationRules) GetLt() *google_protobuf1.Duration {
	if m != nil {
		return m.Lt
	}
	return nil
}

func (m *DurationRules) GetLte() *google_protobuf1.Duration {
	if m != nil {
		return m.Lte
	}
	return nil
}

func (m *DurationRules) GetGt() *google_protobuf1.Duration {
	if m != nil {
		return m.Gt
	}
	return nil
}

func (m *DurationRules) GetGte() *google_protobuf1.Duration {
	if m != nil {
		return m.Gte
	}
	return nil
}

func (m *DurationRules) GetIn() []*google_protobuf1.Duration {
	if m != nil {
		return m.In
	}
	return nil
}

func (m *DurationRules) GetNotIn() []*google_protobuf1.Duration {
	if m != nil {
		return m.NotIn
	}
	return nil
}

// TimestampRules describe the constraints applied exclusively to the
// `google.protobuf.Timestamp` well-known type
type TimestampRules struct {
	// Required specifies that this field must be set
	Required *bool `protobuf:"varint,1,opt,name=required" json:"required,omitempty"`
	// Const specifies that this field must be exactly the specified value
	Const *google_protobuf2.Timestamp `protobuf:"bytes,2,opt,name=const" json:"const,omitempty"`
	// Lt specifies that this field must be less than the specified value,
	// exclusive
	Lt *google_protobuf2.Timestamp `protobuf:"bytes,3,opt,name=lt" json:"lt,omitempty"`
	// Lte specifies that this field must be less than the specified value,
	// inclusive
	Lte *google_protobuf2.Timestamp `protobuf:"bytes,4,opt,name=lte" json:"lte,omitempty"`
	// Gt specifies that this field must be greater than the specified value,
	// exclusive
	Gt *google_protobuf2.Timestamp `protobuf:"bytes,5,opt,name=gt" json:"gt,omitempty"`
	// Gte specifies that this field must be greater than the specified value,
	// inclusive
	Gte *google_protobuf2.Timestamp `protobuf:"bytes,6,opt,name=gte" json:"gte,omitempty"`
	// LtNow specifies that this must be less than the current time. LtNow
	// can only be used with the Within rule.
	LtNow *bool `protobuf:"varint,7,opt,name=lt_now,json=ltNow" json:"lt_now,omitempty"`
	// GtNow specifies that this must be greater than the current time. GtNow
	// can only be used with the Within rule.
	GtNow *bool `protobuf:"varint,8,opt,name=gt_now,json=gtNow" json:"gt_now,omitempty"`
	// Within specifies that this field must be within this duration of the
	// current time. This constraint can be used alone or with the LtNow and
	// GtNow rules.
	Within           *google_protobuf1.Duration `protobuf:"bytes,9,opt,name=within" json:"within,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *TimestampRules) Reset()                    { *m = TimestampRules{} }
func (m *TimestampRules) String() string            { return proto.CompactTextString(m) }
func (*TimestampRules) ProtoMessage()               {}
func (*TimestampRules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *TimestampRules) GetRequired() bool {
	if m != nil && m.Required != nil {
		return *m.Required
	}
	return false
}

func (m *TimestampRules) GetConst() *google_protobuf2.Timestamp {
	if m != nil {
		return m.Const
	}
	return nil
}

func (m *TimestampRules) GetLt() *google_protobuf2.Timestamp {
	if m != nil {
		return m.Lt
	}
	return nil
}

func (m *TimestampRules) GetLte() *google_protobuf2.Timestamp {
	if m != nil {
		return m.Lte
	}
	return nil
}

func (m *TimestampRules) GetGt() *google_protobuf2.Timestamp {
	if m != nil {
		return m.Gt
	}
	return nil
}

func (m *TimestampRules) GetGte() *google_protobuf2.Timestamp {
	if m != nil {
		return m.Gte
	}
	return nil
}

func (m *TimestampRules) GetLtNow() bool {
	if m != nil && m.LtNow != nil {
		return *m.LtNow
	}
	return false
}

func (m *TimestampRules) GetGtNow() bool {
	if m != nil && m.GtNow != nil {
		return *m.GtNow
	}
	return false
}

func (m *TimestampRules) GetWithin() *google_protobuf1.Duration {
	if m != nil {
		return m.Within
	}
	return nil
}

var E_Disabled = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.MessageOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         919191,
	Name:          "validate.disabled",
	Tag:           "varint,919191,opt,name=disabled",
	Filename:      "validate/validate.proto",
}

var E_Required = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.OneofOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         919191,
	Name:          "validate.required",
	Tag:           "varint,919191,opt,name=required",
	Filename:      "validate/validate.proto",
}

var E_Rules = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.FieldOptions)(nil),
	ExtensionType: (*FieldRules)(nil),
	Field:         919191,
	Name:          "validate.rules",
	Tag:           "bytes,919191,opt,name=rules",
	Filename:      "validate/validate.proto",
}

func init() {
	proto.RegisterType((*FieldRules)(nil), "validate.FieldRules")
	proto.RegisterType((*FloatRules)(nil), "validate.FloatRules")
	proto.RegisterType((*DoubleRules)(nil), "validate.DoubleRules")
	proto.RegisterType((*Int32Rules)(nil), "validate.Int32Rules")
	proto.RegisterType((*Int64Rules)(nil), "validate.Int64Rules")
	proto.RegisterType((*UInt32Rules)(nil), "validate.UInt32Rules")
	proto.RegisterType((*UInt64Rules)(nil), "validate.UInt64Rules")
	proto.RegisterType((*SInt32Rules)(nil), "validate.SInt32Rules")
	proto.RegisterType((*SInt64Rules)(nil), "validate.SInt64Rules")
	proto.RegisterType((*Fixed32Rules)(nil), "validate.Fixed32Rules")
	proto.RegisterType((*Fixed64Rules)(nil), "validate.Fixed64Rules")
	proto.RegisterType((*SFixed32Rules)(nil), "validate.SFixed32Rules")
	proto.RegisterType((*SFixed64Rules)(nil), "validate.SFixed64Rules")
	proto.RegisterType((*BoolRules)(nil), "validate.BoolRules")
	proto.RegisterType((*StringRules)(nil), "validate.StringRules")
	proto.RegisterType((*BytesRules)(nil), "validate.BytesRules")
	proto.RegisterType((*EnumRules)(nil), "validate.EnumRules")
	proto.RegisterType((*MessageRules)(nil), "validate.MessageRules")
	proto.RegisterType((*RepeatedRules)(nil), "validate.RepeatedRules")
	proto.RegisterType((*MapRules)(nil), "validate.MapRules")
	proto.RegisterType((*AnyRules)(nil), "validate.AnyRules")
	proto.RegisterType((*DurationRules)(nil), "validate.DurationRules")
	proto.RegisterType((*TimestampRules)(nil), "validate.TimestampRules")
	proto.RegisterExtension(E_Disabled)
	proto.RegisterExtension(E_Required)
	proto.RegisterExtension(E_Rules)
}

func init() { proto.RegisterFile("validate/validate.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1555 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x98, 0x5b, 0x6e, 0xdb, 0x46,
	0x14, 0x86, 0xcb, 0xab, 0xa8, 0xb1, 0x14, 0x49, 0x13, 0xdb, 0x61, 0xdc, 0x4b, 0x1c, 0x3d, 0x14,
	0x4e, 0x1a, 0xd8, 0xa9, 0xe3, 0x0a, 0x41, 0x8a, 0x16, 0xa8, 0x91, 0x06, 0x0d, 0xda, 0x34, 0x05,
	0xdd, 0x3c, 0x1b, 0x74, 0x34, 0x52, 0x06, 0xa6, 0x86, 0x0c, 0x49, 0xc5, 0xd6, 0x22, 0xd2, 0xf6,
	0xad, 0xab, 0xe8, 0x02, 0xba, 0x85, 0x02, 0x5d, 0x48, 0x9f, 0xbb, 0x81, 0x62, 0x6e, 0xbc, 0x1c,
	0xd2, 0x32, 0xd0, 0x37, 0xcd, 0x39, 0xff, 0x99, 0xf9, 0xf0, 0x0f, 0x39, 0x73, 0x28, 0x74, 0xeb,
	0x5d, 0x18, 0xd1, 0x69, 0x98, 0x93, 0x03, 0xfd, 0x63, 0x3f, 0x49, 0xe3, 0x3c, 0xc6, 0x9e, 0x1e,
	0xef, 0xec, 0xce, 0xe3, 0x78, 0x1e, 0x91, 0x03, 0x11, 0x3f, 0x5b, 0xce, 0x0e, 0xa6, 0x24, 0x7b,
	0x9d, 0xd2, 0x24, 0x8f, 0x53, 0xa9, 0xdd, 0xf9, 0xa4, 0xa1, 0x58, 0xa6, 0x61, 0x4e, 0x63, 0xa6,
	0xf2, 0x77, 0x60, 0x3e, 0xa7, 0x0b, 0x92, 0xe5, 0xe1, 0x22, 0x91, 0x82, 0xf1, 0x5f, 0x1e, 0x42,
	0xcf, 0x28, 0x89, 0xa6, 0xc1, 0x32, 0x22, 0x19, 0x7e, 0x80, 0x9c, 0x59, 0x14, 0x87, 0xb9, 0x6f,
	0xec, 0x1a, 0x7b, 0x1b, 0x87, 0x9b, 0xfb, 0x05, 0xdb, 0x33, 0x1e, 0x16, 0xa2, 0xef, 0x3e, 0x08,
	0xa4, 0x08, 0x1f, 0x20, 0x77, 0x1a, 0x2f, 0xcf, 0x22, 0xe2, 0x9b, 0x42, 0xbe, 0x55, 0xca, 0x9f,
	0x8a, 0xb8, 0xd6, 0x2b, 0x19, 0x9f, 0x9e, 0xb2, 0xfc, 0xd1, 0xa1, 0x6f, 0xc1, 0xe9, 0x9f, 0xf3,
	0x70, 0x31, 0xbd, 0x10, 0x29, 0xf5, 0xe4, 0xc8, 0xb7, 0x5b, 0xd4, 0x93, 0xa3, 0xaa, 0x7a, 0x72,
	0xc4, 0x61, 0x96, 0x72, 0x72, 0x07, 0xc2, 0xbc, 0xaa, 0xcd, 0xae, 0x64, 0xba, 0x60, 0x72, 0xe4,
	0xbb, 0x6d, 0x05, 0xe5, 0x02, 0x4a, 0xc6, 0x0b, 0x32, 0xb9, 0x42, 0x07, 0x16, 0x9c, 0xd4, 0x57,
	0xc8, 0x8a, 0x15, 0x32, 0xb9, 0x82, 0xd7, 0x56, 0x50, 0x59, 0x41, 0xca, 0xf0, 0x21, 0xea, 0xcc,
	0xe8, 0x25, 0x99, 0x3e, 0x3a, 0xf4, 0xbb, 0xa2, 0x62, 0xbb, 0xb2, 0x01, 0x32, 0xa1, 0x4b, 0xb4,
	0xb0, 0xa8, 0x99, 0x1c, 0xf9, 0xa8, 0xb5, 0xa6, 0x5c, 0x46, 0x0b, 0xf1, 0x17, 0xc8, 0xcb, 0xf4,
	0x42, 0x1b, 0xa2, 0xe8, 0x56, 0x05, 0x0d, 0xac, 0x54, 0x48, 0xcb, 0xb2, 0xc9, 0x91, 0xdf, 0x6b,
	0x2f, 0x2b, 0x17, 0x2b, 0xa4, 0xf8, 0x1e, 0xb2, 0xcf, 0xe2, 0x38, 0xf2, 0xfb, 0xa2, 0xe4, 0x66,
	0x59, 0x72, 0x1c, 0xc7, 0x91, 0x96, 0x0b, 0x89, 0x70, 0x2c, 0x4f, 0x29, 0x9b, 0xfb, 0x37, 0x1a,
	0x8e, 0x89, 0x78, 0xe9, 0x98, 0x18, 0xf2, 0x67, 0xe4, 0x6c, 0x95, 0x93, 0xcc, 0x1f, 0xc0, 0x67,
	0xe4, 0x98, 0x87, 0x8b, 0x67, 0x44, 0x88, 0x38, 0x09, 0x61, 0xcb, 0x85, 0x3f, 0x84, 0x24, 0xdf,
	0xb2, 0xe5, 0xa2, 0x20, 0xe1, 0x12, 0x6e, 0xeb, 0x82, 0x64, 0x59, 0x38, 0x27, 0xfe, 0x08, 0xda,
	0xfa, 0x42, 0x26, 0x0a, 0x5b, 0x95, 0x90, 0xfb, 0x93, 0x92, 0x84, 0x84, 0x39, 0x99, 0xfa, 0x18,
	0xfa, 0x13, 0xa8, 0x4c, 0xe1, 0x8f, 0x96, 0xe2, 0x4f, 0x91, 0xb5, 0x08, 0x13, 0xff, 0xa6, 0xa8,
	0xc0, 0x95, 0x65, 0xc2, 0x44, 0x8b, 0xb9, 0x80, 0xeb, 0x42, 0xb6, 0xf2, 0x37, 0xa1, 0xee, 0x1b,
	0xb6, 0x2a, 0x74, 0x21, 0x5b, 0x71, 0x0c, 0x7d, 0x0c, 0xf8, 0x5b, 0x10, 0xe3, 0xa9, 0xca, 0x14,
	0x18, 0x5a, 0x8a, 0x1f, 0xa3, 0x6e, 0x71, 0x3a, 0xf8, 0xdb, 0xa2, 0xce, 0x2f, 0xeb, 0x7e, 0xd6,
	0x29, 0x5d, 0x58, 0x8a, 0x8f, 0x5d, 0x64, 0xe7, 0xab, 0x84, 0x8c, 0xdf, 0x1b, 0x08, 0x95, 0xe7,
	0x04, 0xde, 0x44, 0xce, 0xeb, 0x98, 0x65, 0xf2, 0x30, 0x31, 0x03, 0x39, 0xc0, 0x37, 0x90, 0x19,
	0xe5, 0xe2, 0xc0, 0x30, 0x03, 0x33, 0xca, 0xf1, 0x10, 0x59, 0x51, 0x4e, 0xc4, 0x89, 0x60, 0x06,
	0xfc, 0x27, 0x57, 0xcc, 0x73, 0xf1, 0xd2, 0x9b, 0x81, 0x39, 0x17, 0x8a, 0x79, 0x4e, 0xc4, 0x6b,
	0x6d, 0x06, 0xfc, 0x27, 0x57, 0x50, 0xe6, 0xbb, 0xbb, 0x16, 0x57, 0x50, 0x86, 0xb7, 0x90, 0xcb,
	0xe2, 0xfc, 0x94, 0x32, 0xbf, 0x23, 0x62, 0x0e, 0x8b, 0xf3, 0xe7, 0x6c, 0xfc, 0x8b, 0x81, 0x36,
	0x2a, 0x07, 0x51, 0x1d, 0xc8, 0x68, 0x02, 0x19, 0x10, 0xc8, 0x80, 0x40, 0x06, 0x04, 0x32, 0x20,
	0x90, 0xd1, 0x02, 0x64, 0x68, 0x20, 0x6e, 0x50, 0x79, 0x52, 0xd4, 0x79, 0x9c, 0x26, 0x8f, 0x03,
	0x79, 0x1c, 0xc8, 0xe3, 0x40, 0x1e, 0x07, 0xf2, 0x38, 0x2d, 0x3c, 0x0e, 0xe0, 0x51, 0x2f, 0x6d,
	0x9d, 0xc7, 0x6a, 0xf2, 0x58, 0x90, 0xc7, 0x82, 0x3c, 0x16, 0xe4, 0xb1, 0x20, 0x8f, 0xd5, 0xc2,
	0x63, 0x55, 0x37, 0xec, 0xd5, 0x55, 0x06, 0xf5, 0x9b, 0x40, 0x7d, 0x08, 0xd4, 0x87, 0x40, 0x7d,
	0x08, 0xd4, 0x87, 0x40, 0xfd, 0x16, 0xa0, 0x3e, 0x04, 0x6a, 0x75, 0xc8, 0x6e, 0x02, 0xd9, 0x10,
	0xc8, 0x86, 0x40, 0x36, 0x04, 0xb2, 0x21, 0x90, 0xdd, 0x02, 0x64, 0x57, 0x81, 0x4e, 0xae, 0x72,
	0x68, 0xd4, 0x04, 0x1a, 0x41, 0xa0, 0x11, 0x04, 0x1a, 0x41, 0xa0, 0x11, 0x04, 0x1a, 0xb5, 0x00,
	0x8d, 0x20, 0x50, 0xab, 0x43, 0xb8, 0x09, 0x84, 0x21, 0x10, 0x86, 0x40, 0x18, 0x02, 0x61, 0x08,
	0x84, 0x5b, 0x80, 0xb0, 0x06, 0xfa, 0xd5, 0x40, 0xbd, 0xea, 0x0d, 0x56, 0x27, 0xea, 0x34, 0x89,
	0x3a, 0x90, 0xa8, 0x03, 0x89, 0x3a, 0x90, 0xa8, 0x03, 0x89, 0x3a, 0x2d, 0x44, 0x9d, 0x06, 0x51,
	0xab, 0x47, 0x6e, 0x93, 0xc8, 0x85, 0x44, 0x2e, 0x24, 0x72, 0x21, 0x91, 0x0b, 0x89, 0xdc, 0x16,
	0x22, 0x57, 0x13, 0xfd, 0x66, 0xa0, 0xfe, 0xc9, 0xd5, 0x26, 0x0d, 0x9a, 0x48, 0x03, 0x88, 0x34,
	0x80, 0x48, 0x03, 0x88, 0x34, 0x80, 0x48, 0x83, 0x16, 0xa4, 0x41, 0x13, 0xa9, 0xd5, 0xa5, 0x61,
	0x13, 0x69, 0x08, 0x91, 0x86, 0x10, 0x69, 0x08, 0x91, 0x86, 0x10, 0x69, 0xd8, 0x82, 0x34, 0xd4,
	0x48, 0x77, 0x51, 0xb7, 0xe8, 0x50, 0xea, 0x34, 0x9e, 0xa2, 0x19, 0xff, 0x6d, 0xa1, 0x8d, 0x4a,
	0x63, 0x52, 0x57, 0x75, 0x35, 0xf3, 0x2d, 0xd4, 0x59, 0x50, 0x76, 0x1a, 0x11, 0xa6, 0x0e, 0x09,
	0x77, 0x41, 0xd9, 0x0f, 0x84, 0x89, 0x44, 0x78, 0x29, 0x12, 0x96, 0x4a, 0x84, 0x97, 0x3c, 0xf1,
	0x21, 0xea, 0xf2, 0x0a, 0xd9, 0xda, 0xc8, 0x63, 0xc3, 0x5b, 0x50, 0x26, 0x7a, 0x1a, 0x91, 0x0c,
	0x2f, 0x55, 0xd2, 0x51, 0xc9, 0xf0, 0x52, 0x26, 0x7d, 0xd4, 0x49, 0xc2, 0x3c, 0x27, 0x29, 0x13,
	0x6d, 0x6d, 0x37, 0xd0, 0x43, 0xbc, 0x8d, 0xdc, 0x24, 0x25, 0x33, 0x7a, 0x29, 0xda, 0xd7, 0x6e,
	0xa0, 0x46, 0x3c, 0x9e, 0x2d, 0x67, 0x3c, 0xee, 0xc9, 0xb8, 0x1c, 0xe1, 0x1d, 0xe4, 0xbd, 0x8e,
	0x59, 0x1e, 0x52, 0x96, 0x89, 0x6e, 0xb4, 0x1b, 0x14, 0x63, 0xe5, 0x20, 0xda, 0xb5, 0xf6, 0xba,
	0xc0, 0xc1, 0x0d, 0x11, 0x93, 0x0e, 0xe2, 0x6d, 0xe4, 0x90, 0x45, 0x48, 0x23, 0xd1, 0x2d, 0x7a,
	0xbc, 0x0f, 0x13, 0x43, 0xfc, 0x11, 0xf2, 0xde, 0xc4, 0x59, 0xce, 0xc2, 0x05, 0x11, 0x5d, 0x21,
	0x4f, 0x15, 0x11, 0x3c, 0x44, 0x26, 0x4d, 0x44, 0x03, 0xc8, 0xe3, 0x26, 0x4d, 0xf0, 0x26, 0xb2,
	0x69, 0xf2, 0xee, 0x48, 0x34, 0x79, 0x3c, 0x26, 0x46, 0x2a, 0x3a, 0x11, 0xdd, 0x9c, 0x8e, 0x4e,
	0x30, 0x46, 0xd6, 0x32, 0xa5, 0xa2, 0x69, 0xe3, 0x41, 0x3e, 0xc0, 0xb7, 0x51, 0x67, 0x99, 0xd2,
	0xd3, 0x94, 0xcc, 0x44, 0x5f, 0xe6, 0x89, 0xa6, 0x3e, 0xa5, 0x01, 0x99, 0x1d, 0xf7, 0x10, 0xba,
	0x20, 0x51, 0x74, 0x7a, 0xce, 0xe2, 0x0b, 0x36, 0xfe, 0xc3, 0x44, 0xa8, 0x6c, 0x1c, 0xeb, 0xdb,
	0xd9, 0xfb, 0xff, 0xdb, 0x59, 0xd9, 0x14, 0xfb, 0xaa, 0x4d, 0x71, 0xc4, 0x12, 0xcd, 0x4d, 0x71,
	0x65, 0xbc, 0x65, 0x53, 0x3a, 0x22, 0x03, 0x37, 0xc5, 0xdb, 0xb5, 0xf6, 0x7a, 0x60, 0x53, 0xba,
	0x22, 0xa6, 0x36, 0x45, 0xda, 0x8b, 0x5a, 0xec, 0xdd, 0x68, 0xb5, 0xb7, 0x57, 0xb5, 0x17, 0xf8,
	0x75, 0x8e, 0xba, 0x45, 0xeb, 0x7c, 0x45, 0x3b, 0x73, 0x17, 0xf5, 0xa6, 0x64, 0x46, 0x19, 0x99,
	0x9e, 0xc6, 0x2c, 0x5a, 0x09, 0xcb, 0xbc, 0x60, 0x43, 0xc5, 0x5e, 0xb2, 0x68, 0xa5, 0xc0, 0xad,
	0x96, 0x6e, 0xc5, 0xae, 0x76, 0x2b, 0x5f, 0xa3, 0x5e, 0xb5, 0xf3, 0xc6, 0x18, 0xd9, 0xd9, 0x39,
	0x4d, 0xd4, 0x1b, 0x29, 0x7e, 0x73, 0x7f, 0x52, 0xf2, 0x76, 0x49, 0x53, 0x32, 0x55, 0x2b, 0x15,
	0x63, 0xde, 0xed, 0xf4, 0x6b, 0x5d, 0xb8, 0x7e, 0xcd, 0x68, 0x4e, 0x16, 0x99, 0xba, 0xd2, 0xf9,
	0x6b, 0xf6, 0x9c, 0x8f, 0xf5, 0x6b, 0x26, 0x93, 0x66, 0xf1, 0x9a, 0xc9, 0xe4, 0x36, 0x72, 0x97,
	0x8c, 0xbe, 0x5d, 0xca, 0x93, 0xc7, 0x0b, 0xd4, 0x08, 0xdf, 0x47, 0x8e, 0x2c, 0x68, 0x7c, 0xb3,
	0x96, 0x5f, 0xd9, 0x81, 0x94, 0x8c, 0xff, 0x34, 0x90, 0xa7, 0x7b, 0x7c, 0x8d, 0x92, 0x84, 0x34,
	0xad, 0xa2, 0xfc, 0xc4, 0xc7, 0x1a, 0x45, 0x26, 0x4b, 0x94, 0x22, 0xc9, 0xe2, 0xd3, 0x2c, 0x09,
	0xd3, 0x4c, 0xd3, 0x78, 0x2c, 0x3e, 0x11, 0x63, 0xbc, 0x87, 0xec, 0x73, 0xb2, 0x5a, 0x8f, 0x23,
	0x14, 0xf8, 0x01, 0x72, 0xdf, 0x85, 0xd1, 0x52, 0x1d, 0x29, 0x57, 0x69, 0x95, 0x66, 0xfc, 0x02,
	0x79, 0xfa, 0xb3, 0xa3, 0xe6, 0xb9, 0x51, 0xf7, 0x5c, 0x6d, 0xad, 0xd9, 0x72, 0x50, 0x58, 0x95,
	0x83, 0x62, 0xfc, 0x8f, 0x89, 0xfa, 0xb5, 0x2f, 0x93, 0xb5, 0x93, 0x1e, 0xe8, 0x07, 0x4d, 0xfe,
	0xed, 0x70, 0x7b, 0x5f, 0xfe, 0xcb, 0xb1, 0xaf, 0xff, 0xe5, 0x28, 0x3f, 0x72, 0xd4, 0x33, 0x78,
	0x4f, 0x5c, 0x1a, 0xd6, 0x75, 0x6a, 0x7e, 0x9f, 0x7c, 0x26, 0xef, 0x13, 0xfb, 0x3a, 0xad, 0xb8,
	0x6a, 0xee, 0x89, 0xab, 0xc6, 0xb9, 0x76, 0xde, 0xb9, 0x98, 0x97, 0xdf, 0x42, 0xee, 0xb5, 0xf3,
	0xce, 0xe5, 0xbc, 0xea, 0x32, 0x5a, 0x3f, 0x2f, 0x65, 0xf8, 0x61, 0x61, 0xa8, 0x77, 0x9d, 0x5c,
	0x79, 0xfd, 0xaf, 0x89, 0x6e, 0xd4, 0xbf, 0xe6, 0xd6, 0x9a, 0xfd, 0xb0, 0x6e, 0xf6, 0x4e, 0x63,
	0xfe, 0x72, 0x2e, 0xe5, 0xf6, 0xfd, 0x8a, 0xdb, 0xeb, 0xe4, 0xdc, 0xee, 0x07, 0x55, 0xbb, 0xd7,
	0x89, 0x85, 0xdf, 0xf7, 0x2b, 0x7e, 0xaf, 0x9d, 0x79, 0x2e, 0x66, 0x2e, 0x0d, 0x5f, 0x3b, 0x33,
	0x77, 0x7c, 0x0b, 0xb9, 0x51, 0x7e, 0xca, 0xe2, 0x0b, 0x71, 0xaa, 0x7a, 0x81, 0x13, 0xe5, 0x3f,
	0xc6, 0x17, 0x3c, 0x3c, 0x97, 0x61, 0x4f, 0x86, 0xe7, 0x22, 0xfc, 0x39, 0x72, 0x2f, 0x68, 0xfe,
	0x46, 0x9c, 0xac, 0xd7, 0xec, 0xa7, 0x12, 0x3e, 0xf9, 0x0a, 0x79, 0x53, 0x9a, 0x85, 0x67, 0x11,
	0x99, 0xe2, 0x3b, 0x0d, 0xb9, 0x3a, 0xd7, 0x5e, 0x26, 0xbc, 0x26, 0xf3, 0x7f, 0x7f, 0xff, 0x58,
	0xee, 0x82, 0x2e, 0x79, 0xf2, 0x65, 0xb9, 0x43, 0xf8, 0xe3, 0x46, 0xf9, 0x4b, 0x46, 0xe2, 0x59,
	0xa3, 0x58, 0x17, 0x3c, 0xf9, 0x1e, 0x39, 0xa9, 0xd8, 0xe7, 0x66, 0xa5, 0x78, 0xb5, 0xeb, 0x95,
	0x57, 0x9e, 0x5a, 0x62, 0x8e, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0xc4, 0x1b, 0x73, 0x09, 0xb8,
	0x14, 0x00, 0x00,
}
