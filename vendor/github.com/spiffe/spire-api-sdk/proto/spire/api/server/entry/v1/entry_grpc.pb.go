// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.30.2
// source: spire/api/server/entry/v1/entry.proto

package entryv1

import (
	context "context"
	types "github.com/spiffe/spire-api-sdk/proto/spire/api/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Entry_CountEntries_FullMethodName          = "/spire.api.server.entry.v1.Entry/CountEntries"
	Entry_ListEntries_FullMethodName           = "/spire.api.server.entry.v1.Entry/ListEntries"
	Entry_GetEntry_FullMethodName              = "/spire.api.server.entry.v1.Entry/GetEntry"
	Entry_BatchCreateEntry_FullMethodName      = "/spire.api.server.entry.v1.Entry/BatchCreateEntry"
	Entry_BatchUpdateEntry_FullMethodName      = "/spire.api.server.entry.v1.Entry/BatchUpdateEntry"
	Entry_BatchDeleteEntry_FullMethodName      = "/spire.api.server.entry.v1.Entry/BatchDeleteEntry"
	Entry_GetAuthorizedEntries_FullMethodName  = "/spire.api.server.entry.v1.Entry/GetAuthorizedEntries"
	Entry_SyncAuthorizedEntries_FullMethodName = "/spire.api.server.entry.v1.Entry/SyncAuthorizedEntries"
)

// EntryClient is the client API for Entry service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Manages registration entries stored by the SPIRE Server.
type EntryClient interface {
	// Count entries.
	//
	// The caller must be local or present an admin X509-SVID.
	CountEntries(ctx context.Context, in *CountEntriesRequest, opts ...grpc.CallOption) (*CountEntriesResponse, error)
	// Lists entries.
	//
	// The caller must be local or present an admin X509-SVID.
	ListEntries(ctx context.Context, in *ListEntriesRequest, opts ...grpc.CallOption) (*ListEntriesResponse, error)
	// Gets an entry. If the entry does not exist, NOT_FOUND is returned.
	//
	// The caller must be local or present an admin X509-SVID.
	GetEntry(ctx context.Context, in *GetEntryRequest, opts ...grpc.CallOption) (*types.Entry, error)
	// Batch creates one or more entries.
	//
	// The caller must be local or present an admin X509-SVID.
	BatchCreateEntry(ctx context.Context, in *BatchCreateEntryRequest, opts ...grpc.CallOption) (*BatchCreateEntryResponse, error)
	// Batch updates one or more entries.
	//
	// The caller must be local or present an admin X509-SVID.
	BatchUpdateEntry(ctx context.Context, in *BatchUpdateEntryRequest, opts ...grpc.CallOption) (*BatchUpdateEntryResponse, error)
	// Batch deletes one or more entries.
	//
	// The caller must be local or present an admin X509-SVID.
	BatchDeleteEntry(ctx context.Context, in *BatchDeleteEntryRequest, opts ...grpc.CallOption) (*BatchDeleteEntryResponse, error)
	// Gets the entries the caller is authorized for.
	//
	// The caller must present an active agent X509-SVID. See the Agent
	// AttestAgent/RenewAgent RPCs.
	GetAuthorizedEntries(ctx context.Context, in *GetAuthorizedEntriesRequest, opts ...grpc.CallOption) (*GetAuthorizedEntriesResponse, error)
	// Syncs authorized entries down to the caller. The caller controls which
	// entries the server sends down full details for. The flow is as follows:
	// 1. Caller opens up sync stream
	// 2. Server determines authorized entries for caller:
	//   - If there are less entries than a server-determined page size, go to (5).
	//   - Otherwise, go to (3).
	//  3. Server pages entry revisions to the caller (contains the entry ID and
	//     revision number). The "more" flag set for all pages but the last so
	//     that the caller knows when the server is done.
	//  4. Client determines which entries are new or updated (based on revision
	//     number) and asks for them by sending a request with the IDs.
	//  5. Server pages down entries to the caller for each ID identified in (4)
	//     or every entry in (2) if the number of entries was less than the
	//     server-determined page size. The "more" flag set for all pages but
	//     the last so that the caller knows when the server is done.
	//  6. Steps (4) and (5) are repeated until the caller has synced down the
	//     details for all new/updated entries and closes the stream.
	SyncAuthorizedEntries(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SyncAuthorizedEntriesRequest, SyncAuthorizedEntriesResponse], error)
}

type entryClient struct {
	cc grpc.ClientConnInterface
}

func NewEntryClient(cc grpc.ClientConnInterface) EntryClient {
	return &entryClient{cc}
}

func (c *entryClient) CountEntries(ctx context.Context, in *CountEntriesRequest, opts ...grpc.CallOption) (*CountEntriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CountEntriesResponse)
	err := c.cc.Invoke(ctx, Entry_CountEntries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *entryClient) ListEntries(ctx context.Context, in *ListEntriesRequest, opts ...grpc.CallOption) (*ListEntriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListEntriesResponse)
	err := c.cc.Invoke(ctx, Entry_ListEntries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *entryClient) GetEntry(ctx context.Context, in *GetEntryRequest, opts ...grpc.CallOption) (*types.Entry, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(types.Entry)
	err := c.cc.Invoke(ctx, Entry_GetEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *entryClient) BatchCreateEntry(ctx context.Context, in *BatchCreateEntryRequest, opts ...grpc.CallOption) (*BatchCreateEntryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchCreateEntryResponse)
	err := c.cc.Invoke(ctx, Entry_BatchCreateEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *entryClient) BatchUpdateEntry(ctx context.Context, in *BatchUpdateEntryRequest, opts ...grpc.CallOption) (*BatchUpdateEntryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchUpdateEntryResponse)
	err := c.cc.Invoke(ctx, Entry_BatchUpdateEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *entryClient) BatchDeleteEntry(ctx context.Context, in *BatchDeleteEntryRequest, opts ...grpc.CallOption) (*BatchDeleteEntryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchDeleteEntryResponse)
	err := c.cc.Invoke(ctx, Entry_BatchDeleteEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *entryClient) GetAuthorizedEntries(ctx context.Context, in *GetAuthorizedEntriesRequest, opts ...grpc.CallOption) (*GetAuthorizedEntriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAuthorizedEntriesResponse)
	err := c.cc.Invoke(ctx, Entry_GetAuthorizedEntries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *entryClient) SyncAuthorizedEntries(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SyncAuthorizedEntriesRequest, SyncAuthorizedEntriesResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Entry_ServiceDesc.Streams[0], Entry_SyncAuthorizedEntries_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SyncAuthorizedEntriesRequest, SyncAuthorizedEntriesResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Entry_SyncAuthorizedEntriesClient = grpc.BidiStreamingClient[SyncAuthorizedEntriesRequest, SyncAuthorizedEntriesResponse]

// EntryServer is the server API for Entry service.
// All implementations must embed UnimplementedEntryServer
// for forward compatibility.
//
// Manages registration entries stored by the SPIRE Server.
type EntryServer interface {
	// Count entries.
	//
	// The caller must be local or present an admin X509-SVID.
	CountEntries(context.Context, *CountEntriesRequest) (*CountEntriesResponse, error)
	// Lists entries.
	//
	// The caller must be local or present an admin X509-SVID.
	ListEntries(context.Context, *ListEntriesRequest) (*ListEntriesResponse, error)
	// Gets an entry. If the entry does not exist, NOT_FOUND is returned.
	//
	// The caller must be local or present an admin X509-SVID.
	GetEntry(context.Context, *GetEntryRequest) (*types.Entry, error)
	// Batch creates one or more entries.
	//
	// The caller must be local or present an admin X509-SVID.
	BatchCreateEntry(context.Context, *BatchCreateEntryRequest) (*BatchCreateEntryResponse, error)
	// Batch updates one or more entries.
	//
	// The caller must be local or present an admin X509-SVID.
	BatchUpdateEntry(context.Context, *BatchUpdateEntryRequest) (*BatchUpdateEntryResponse, error)
	// Batch deletes one or more entries.
	//
	// The caller must be local or present an admin X509-SVID.
	BatchDeleteEntry(context.Context, *BatchDeleteEntryRequest) (*BatchDeleteEntryResponse, error)
	// Gets the entries the caller is authorized for.
	//
	// The caller must present an active agent X509-SVID. See the Agent
	// AttestAgent/RenewAgent RPCs.
	GetAuthorizedEntries(context.Context, *GetAuthorizedEntriesRequest) (*GetAuthorizedEntriesResponse, error)
	// Syncs authorized entries down to the caller. The caller controls which
	// entries the server sends down full details for. The flow is as follows:
	// 1. Caller opens up sync stream
	// 2. Server determines authorized entries for caller:
	//   - If there are less entries than a server-determined page size, go to (5).
	//   - Otherwise, go to (3).
	//  3. Server pages entry revisions to the caller (contains the entry ID and
	//     revision number). The "more" flag set for all pages but the last so
	//     that the caller knows when the server is done.
	//  4. Client determines which entries are new or updated (based on revision
	//     number) and asks for them by sending a request with the IDs.
	//  5. Server pages down entries to the caller for each ID identified in (4)
	//     or every entry in (2) if the number of entries was less than the
	//     server-determined page size. The "more" flag set for all pages but
	//     the last so that the caller knows when the server is done.
	//  6. Steps (4) and (5) are repeated until the caller has synced down the
	//     details for all new/updated entries and closes the stream.
	SyncAuthorizedEntries(grpc.BidiStreamingServer[SyncAuthorizedEntriesRequest, SyncAuthorizedEntriesResponse]) error
	mustEmbedUnimplementedEntryServer()
}

// UnimplementedEntryServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEntryServer struct{}

func (UnimplementedEntryServer) CountEntries(context.Context, *CountEntriesRequest) (*CountEntriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountEntries not implemented")
}
func (UnimplementedEntryServer) ListEntries(context.Context, *ListEntriesRequest) (*ListEntriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListEntries not implemented")
}
func (UnimplementedEntryServer) GetEntry(context.Context, *GetEntryRequest) (*types.Entry, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEntry not implemented")
}
func (UnimplementedEntryServer) BatchCreateEntry(context.Context, *BatchCreateEntryRequest) (*BatchCreateEntryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreateEntry not implemented")
}
func (UnimplementedEntryServer) BatchUpdateEntry(context.Context, *BatchUpdateEntryRequest) (*BatchUpdateEntryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchUpdateEntry not implemented")
}
func (UnimplementedEntryServer) BatchDeleteEntry(context.Context, *BatchDeleteEntryRequest) (*BatchDeleteEntryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchDeleteEntry not implemented")
}
func (UnimplementedEntryServer) GetAuthorizedEntries(context.Context, *GetAuthorizedEntriesRequest) (*GetAuthorizedEntriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAuthorizedEntries not implemented")
}
func (UnimplementedEntryServer) SyncAuthorizedEntries(grpc.BidiStreamingServer[SyncAuthorizedEntriesRequest, SyncAuthorizedEntriesResponse]) error {
	return status.Errorf(codes.Unimplemented, "method SyncAuthorizedEntries not implemented")
}
func (UnimplementedEntryServer) mustEmbedUnimplementedEntryServer() {}
func (UnimplementedEntryServer) testEmbeddedByValue()               {}

// UnsafeEntryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EntryServer will
// result in compilation errors.
type UnsafeEntryServer interface {
	mustEmbedUnimplementedEntryServer()
}

func RegisterEntryServer(s grpc.ServiceRegistrar, srv EntryServer) {
	// If the following call pancis, it indicates UnimplementedEntryServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Entry_ServiceDesc, srv)
}

func _Entry_CountEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountEntriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EntryServer).CountEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Entry_CountEntries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EntryServer).CountEntries(ctx, req.(*CountEntriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Entry_ListEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListEntriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EntryServer).ListEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Entry_ListEntries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EntryServer).ListEntries(ctx, req.(*ListEntriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Entry_GetEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EntryServer).GetEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Entry_GetEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EntryServer).GetEntry(ctx, req.(*GetEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Entry_BatchCreateEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EntryServer).BatchCreateEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Entry_BatchCreateEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EntryServer).BatchCreateEntry(ctx, req.(*BatchCreateEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Entry_BatchUpdateEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchUpdateEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EntryServer).BatchUpdateEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Entry_BatchUpdateEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EntryServer).BatchUpdateEntry(ctx, req.(*BatchUpdateEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Entry_BatchDeleteEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchDeleteEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EntryServer).BatchDeleteEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Entry_BatchDeleteEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EntryServer).BatchDeleteEntry(ctx, req.(*BatchDeleteEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Entry_GetAuthorizedEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAuthorizedEntriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EntryServer).GetAuthorizedEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Entry_GetAuthorizedEntries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EntryServer).GetAuthorizedEntries(ctx, req.(*GetAuthorizedEntriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Entry_SyncAuthorizedEntries_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EntryServer).SyncAuthorizedEntries(&grpc.GenericServerStream[SyncAuthorizedEntriesRequest, SyncAuthorizedEntriesResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Entry_SyncAuthorizedEntriesServer = grpc.BidiStreamingServer[SyncAuthorizedEntriesRequest, SyncAuthorizedEntriesResponse]

// Entry_ServiceDesc is the grpc.ServiceDesc for Entry service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Entry_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "spire.api.server.entry.v1.Entry",
	HandlerType: (*EntryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CountEntries",
			Handler:    _Entry_CountEntries_Handler,
		},
		{
			MethodName: "ListEntries",
			Handler:    _Entry_ListEntries_Handler,
		},
		{
			MethodName: "GetEntry",
			Handler:    _Entry_GetEntry_Handler,
		},
		{
			MethodName: "BatchCreateEntry",
			Handler:    _Entry_BatchCreateEntry_Handler,
		},
		{
			MethodName: "BatchUpdateEntry",
			Handler:    _Entry_BatchUpdateEntry_Handler,
		},
		{
			MethodName: "BatchDeleteEntry",
			Handler:    _Entry_BatchDeleteEntry_Handler,
		},
		{
			MethodName: "GetAuthorizedEntries",
			Handler:    _Entry_GetAuthorizedEntries_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SyncAuthorizedEntries",
			Handler:       _Entry_SyncAuthorizedEntries_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "spire/api/server/entry/v1/entry.proto",
}
