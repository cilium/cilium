// Code generated by protoc-gen-go. DO NOT EDIT.
// source: envoy/api/v2/auth/cert.proto

package auth

import (
	fmt "fmt"
	core "github.com/cilium/proxy/go/envoy/api/v2/core"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	wrappers "github.com/golang/protobuf/ptypes/wrappers"
	_ "github.com/lyft/protoc-gen-validate/validate"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type TlsParameters_TlsProtocol int32

const (
	// Envoy will choose the optimal TLS version.
	TlsParameters_TLS_AUTO TlsParameters_TlsProtocol = 0
	// TLS 1.0
	TlsParameters_TLSv1_0 TlsParameters_TlsProtocol = 1
	// TLS 1.1
	TlsParameters_TLSv1_1 TlsParameters_TlsProtocol = 2
	// TLS 1.2
	TlsParameters_TLSv1_2 TlsParameters_TlsProtocol = 3
	// TLS 1.3
	TlsParameters_TLSv1_3 TlsParameters_TlsProtocol = 4
)

var TlsParameters_TlsProtocol_name = map[int32]string{
	0: "TLS_AUTO",
	1: "TLSv1_0",
	2: "TLSv1_1",
	3: "TLSv1_2",
	4: "TLSv1_3",
}

var TlsParameters_TlsProtocol_value = map[string]int32{
	"TLS_AUTO": 0,
	"TLSv1_0":  1,
	"TLSv1_1":  2,
	"TLSv1_2":  3,
	"TLSv1_3":  4,
}

func (x TlsParameters_TlsProtocol) String() string {
	return proto.EnumName(TlsParameters_TlsProtocol_name, int32(x))
}

func (TlsParameters_TlsProtocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0c3851c0865b2745, []int{0, 0}
}

type TlsParameters struct {
	// Minimum TLS protocol version.
	TlsMinimumProtocolVersion TlsParameters_TlsProtocol `protobuf:"varint,1,opt,name=tls_minimum_protocol_version,json=tlsMinimumProtocolVersion,proto3,enum=envoy.api.v2.auth.TlsParameters_TlsProtocol" json:"tls_minimum_protocol_version,omitempty"`
	// Maximum TLS protocol version.
	TlsMaximumProtocolVersion TlsParameters_TlsProtocol `protobuf:"varint,2,opt,name=tls_maximum_protocol_version,json=tlsMaximumProtocolVersion,proto3,enum=envoy.api.v2.auth.TlsParameters_TlsProtocol" json:"tls_maximum_protocol_version,omitempty"`
	// If specified, the TLS listener will only support the specified `cipher list
	// <https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration>`_.
	// If not specified, the default list:
	//
	// .. code-block:: none
	//
	//   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
	//   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
	//   ECDHE-ECDSA-AES128-SHA
	//   ECDHE-RSA-AES128-SHA
	//   AES128-GCM-SHA256
	//   AES128-SHA
	//   ECDHE-ECDSA-AES256-GCM-SHA384
	//   ECDHE-RSA-AES256-GCM-SHA384
	//   ECDHE-ECDSA-AES256-SHA
	//   ECDHE-RSA-AES256-SHA
	//   AES256-GCM-SHA384
	//   AES256-SHA
	//
	// will be used.
	CipherSuites []string `protobuf:"bytes,3,rep,name=cipher_suites,json=cipherSuites,proto3" json:"cipher_suites,omitempty"`
	// If specified, the TLS connection will only support the specified ECDH
	// curves. If not specified, the default curves (X25519, P-256) will be used.
	EcdhCurves           []string `protobuf:"bytes,4,rep,name=ecdh_curves,json=ecdhCurves,proto3" json:"ecdh_curves,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TlsParameters) Reset()         { *m = TlsParameters{} }
func (m *TlsParameters) String() string { return proto.CompactTextString(m) }
func (*TlsParameters) ProtoMessage()    {}
func (*TlsParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c3851c0865b2745, []int{0}
}

func (m *TlsParameters) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TlsParameters.Unmarshal(m, b)
}
func (m *TlsParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TlsParameters.Marshal(b, m, deterministic)
}
func (m *TlsParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TlsParameters.Merge(m, src)
}
func (m *TlsParameters) XXX_Size() int {
	return xxx_messageInfo_TlsParameters.Size(m)
}
func (m *TlsParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_TlsParameters.DiscardUnknown(m)
}

var xxx_messageInfo_TlsParameters proto.InternalMessageInfo

func (m *TlsParameters) GetTlsMinimumProtocolVersion() TlsParameters_TlsProtocol {
	if m != nil {
		return m.TlsMinimumProtocolVersion
	}
	return TlsParameters_TLS_AUTO
}

func (m *TlsParameters) GetTlsMaximumProtocolVersion() TlsParameters_TlsProtocol {
	if m != nil {
		return m.TlsMaximumProtocolVersion
	}
	return TlsParameters_TLS_AUTO
}

func (m *TlsParameters) GetCipherSuites() []string {
	if m != nil {
		return m.CipherSuites
	}
	return nil
}

func (m *TlsParameters) GetEcdhCurves() []string {
	if m != nil {
		return m.EcdhCurves
	}
	return nil
}

type TlsCertificate struct {
	// The TLS certificate chain.
	CertificateChain *core.DataSource `protobuf:"bytes,1,opt,name=certificate_chain,json=certificateChain,proto3" json:"certificate_chain,omitempty"`
	// The TLS private key.
	PrivateKey *core.DataSource `protobuf:"bytes,2,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	// [#not-implemented-hide:]
	Password *core.DataSource `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	// [#not-implemented-hide:]
	OcspStaple *core.DataSource `protobuf:"bytes,4,opt,name=ocsp_staple,json=ocspStaple,proto3" json:"ocsp_staple,omitempty"`
	// [#not-implemented-hide:]
	SignedCertificateTimestamp []*core.DataSource `protobuf:"bytes,5,rep,name=signed_certificate_timestamp,json=signedCertificateTimestamp,proto3" json:"signed_certificate_timestamp,omitempty"`
	XXX_NoUnkeyedLiteral       struct{}           `json:"-"`
	XXX_unrecognized           []byte             `json:"-"`
	XXX_sizecache              int32              `json:"-"`
}

func (m *TlsCertificate) Reset()         { *m = TlsCertificate{} }
func (m *TlsCertificate) String() string { return proto.CompactTextString(m) }
func (*TlsCertificate) ProtoMessage()    {}
func (*TlsCertificate) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c3851c0865b2745, []int{1}
}

func (m *TlsCertificate) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TlsCertificate.Unmarshal(m, b)
}
func (m *TlsCertificate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TlsCertificate.Marshal(b, m, deterministic)
}
func (m *TlsCertificate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TlsCertificate.Merge(m, src)
}
func (m *TlsCertificate) XXX_Size() int {
	return xxx_messageInfo_TlsCertificate.Size(m)
}
func (m *TlsCertificate) XXX_DiscardUnknown() {
	xxx_messageInfo_TlsCertificate.DiscardUnknown(m)
}

var xxx_messageInfo_TlsCertificate proto.InternalMessageInfo

func (m *TlsCertificate) GetCertificateChain() *core.DataSource {
	if m != nil {
		return m.CertificateChain
	}
	return nil
}

func (m *TlsCertificate) GetPrivateKey() *core.DataSource {
	if m != nil {
		return m.PrivateKey
	}
	return nil
}

func (m *TlsCertificate) GetPassword() *core.DataSource {
	if m != nil {
		return m.Password
	}
	return nil
}

func (m *TlsCertificate) GetOcspStaple() *core.DataSource {
	if m != nil {
		return m.OcspStaple
	}
	return nil
}

func (m *TlsCertificate) GetSignedCertificateTimestamp() []*core.DataSource {
	if m != nil {
		return m.SignedCertificateTimestamp
	}
	return nil
}

type TlsSessionTicketKeys struct {
	// Keys for encrypting and decrypting TLS session tickets. The
	// first key in the array contains the key to encrypt all new sessions created by this context.
	// All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
	// by, for example, putting the new key first, and the previous key second.
	//
	// If :ref:`session_ticket_keys <envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys>`
	// is not specified, the TLS library will still support resuming sessions via tickets, but it will
	// use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
	// or on different hosts.
	//
	// Each key must contain exactly 80 bytes of cryptographically-secure random data. For
	// example, the output of ``openssl rand 80``.
	//
	// .. attention::
	//
	//   Using this feature has serious security considerations and risks. Improper handling of keys
	//   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
	//   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
	//   discussion. To minimize the risk, you must:
	//
	//   * Keep the session ticket keys at least as secure as your TLS certificate private keys
	//   * Rotate session ticket keys at least daily, and preferably hourly
	//   * Always generate keys using a cryptographically-secure random data source
	Keys                 []*core.DataSource `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TlsSessionTicketKeys) Reset()         { *m = TlsSessionTicketKeys{} }
func (m *TlsSessionTicketKeys) String() string { return proto.CompactTextString(m) }
func (*TlsSessionTicketKeys) ProtoMessage()    {}
func (*TlsSessionTicketKeys) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c3851c0865b2745, []int{2}
}

func (m *TlsSessionTicketKeys) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TlsSessionTicketKeys.Unmarshal(m, b)
}
func (m *TlsSessionTicketKeys) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TlsSessionTicketKeys.Marshal(b, m, deterministic)
}
func (m *TlsSessionTicketKeys) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TlsSessionTicketKeys.Merge(m, src)
}
func (m *TlsSessionTicketKeys) XXX_Size() int {
	return xxx_messageInfo_TlsSessionTicketKeys.Size(m)
}
func (m *TlsSessionTicketKeys) XXX_DiscardUnknown() {
	xxx_messageInfo_TlsSessionTicketKeys.DiscardUnknown(m)
}

var xxx_messageInfo_TlsSessionTicketKeys proto.InternalMessageInfo

func (m *TlsSessionTicketKeys) GetKeys() []*core.DataSource {
	if m != nil {
		return m.Keys
	}
	return nil
}

type CertificateValidationContext struct {
	// TLS certificate data containing certificate authority certificates to use in verifying
	// a presented peer certificate (e.g. server certificate for clusters or client certificate
	// for listeners). If not specified and a peer certificate is presented it will not be
	// verified. By default, a client certificate is optional, unless one of the additional
	// options (:ref:`require_client_certificate
	// <envoy_api_field_auth.DownstreamTlsContext.require_client_certificate>`,
	// :ref:`verify_certificate_spki
	// <envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki>`,
	// :ref:`verify_certificate_hash
	// <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>`, or
	// :ref:`verify_subject_alt_name
	// <envoy_api_field_auth.CertificateValidationContext.verify_subject_alt_name>`) is also
	// specified.
	//
	// It can optionally contain certificate revocation lists, in which case Envoy will verify
	// that the presented peer certificate has not been revoked by one of the included CRLs.
	//
	// See :ref:`the TLS overview <arch_overview_ssl_enabling_verification>` for a list of common
	// system CA locations.
	TrustedCa *core.DataSource `protobuf:"bytes,1,opt,name=trusted_ca,json=trustedCa,proto3" json:"trusted_ca,omitempty"`
	// An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
	// SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
	// matches one of the specified values.
	//
	// A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
	// can be generated with the following command:
	//
	// .. code-block:: bash
	//
	//   $ openssl x509 -in path/to/client.crt -noout -pubkey \
	//     | openssl pkey -pubin -outform DER \
	//     | openssl dgst -sha256 -binary \
	//     | openssl enc -base64
	//   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
	//
	// This is the format used in HTTP Public Key Pinning.
	//
	// When both:
	// :ref:`verify_certificate_hash
	// <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>` and
	// :ref:`verify_certificate_spki
	// <envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki>` are specified,
	// a hash matching value from either of the lists will result in the certificate being accepted.
	//
	// .. attention::
	//
	//   This option is preferred over :ref:`verify_certificate_hash
	//   <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>`,
	//   because SPKI is tied to a private key, so it doesn't change when the certificate
	//   is renewed using the same private key.
	VerifyCertificateSpki []string `protobuf:"bytes,3,rep,name=verify_certificate_spki,json=verifyCertificateSpki,proto3" json:"verify_certificate_spki,omitempty"`
	// An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
	// the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
	//
	// A hex-encoded SHA-256 of the certificate can be generated with the following command:
	//
	// .. code-block:: bash
	//
	//   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
	//   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
	//
	// A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
	// can be generated with the following command:
	//
	// .. code-block:: bash
	//
	//   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
	//   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
	//
	// Both of those formats are acceptable.
	//
	// When both:
	// :ref:`verify_certificate_hash
	// <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>` and
	// :ref:`verify_certificate_spki
	// <envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki>` are specified,
	// a hash matching value from either of the lists will result in the certificate being accepted.
	VerifyCertificateHash []string `protobuf:"bytes,2,rep,name=verify_certificate_hash,json=verifyCertificateHash,proto3" json:"verify_certificate_hash,omitempty"`
	// An optional list of Subject Alternative Names. If specified, Envoy will verify that the
	// Subject Alternative Name of the presented certificate matches one of the specified values.
	//
	// .. attention::
	//
	//   Subject Alternative Names are easily spoofable and verifying only them is insecure,
	//   therefore this option must be used together with :ref:`trusted_ca
	//   <envoy_api_field_auth.CertificateValidationContext.trusted_ca>`.
	VerifySubjectAltName []string `protobuf:"bytes,4,rep,name=verify_subject_alt_name,json=verifySubjectAltName,proto3" json:"verify_subject_alt_name,omitempty"`
	// [#not-implemented-hide:] Must present a signed time-stamped OCSP response.
	RequireOcspStaple *wrappers.BoolValue `protobuf:"bytes,5,opt,name=require_ocsp_staple,json=requireOcspStaple,proto3" json:"require_ocsp_staple,omitempty"`
	// [#not-implemented-hide:] Must present signed certificate time-stamp.
	RequireSignedCertificateTimestamp *wrappers.BoolValue `protobuf:"bytes,6,opt,name=require_signed_certificate_timestamp,json=requireSignedCertificateTimestamp,proto3" json:"require_signed_certificate_timestamp,omitempty"`
	// An optional `certificate revocation list
	// <http://https://en.wikipedia.org/wiki/Certificate_revocation_list>`_
	// (in PEM format). If specified, Envoy will verify that the presented peer
	// certificate has not been revoked by this CRL. If this DataSource contains
	// multiple CRLs, all of them will be used.
	Crl *core.DataSource `protobuf:"bytes,7,opt,name=crl,proto3" json:"crl,omitempty"`
	// If specified, Envoy will not reject expired certificates.
	AllowExpiredCertificate bool     `protobuf:"varint,8,opt,name=allow_expired_certificate,json=allowExpiredCertificate,proto3" json:"allow_expired_certificate,omitempty"`
	XXX_NoUnkeyedLiteral    struct{} `json:"-"`
	XXX_unrecognized        []byte   `json:"-"`
	XXX_sizecache           int32    `json:"-"`
}

func (m *CertificateValidationContext) Reset()         { *m = CertificateValidationContext{} }
func (m *CertificateValidationContext) String() string { return proto.CompactTextString(m) }
func (*CertificateValidationContext) ProtoMessage()    {}
func (*CertificateValidationContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c3851c0865b2745, []int{3}
}

func (m *CertificateValidationContext) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CertificateValidationContext.Unmarshal(m, b)
}
func (m *CertificateValidationContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CertificateValidationContext.Marshal(b, m, deterministic)
}
func (m *CertificateValidationContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateValidationContext.Merge(m, src)
}
func (m *CertificateValidationContext) XXX_Size() int {
	return xxx_messageInfo_CertificateValidationContext.Size(m)
}
func (m *CertificateValidationContext) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateValidationContext.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateValidationContext proto.InternalMessageInfo

func (m *CertificateValidationContext) GetTrustedCa() *core.DataSource {
	if m != nil {
		return m.TrustedCa
	}
	return nil
}

func (m *CertificateValidationContext) GetVerifyCertificateSpki() []string {
	if m != nil {
		return m.VerifyCertificateSpki
	}
	return nil
}

func (m *CertificateValidationContext) GetVerifyCertificateHash() []string {
	if m != nil {
		return m.VerifyCertificateHash
	}
	return nil
}

func (m *CertificateValidationContext) GetVerifySubjectAltName() []string {
	if m != nil {
		return m.VerifySubjectAltName
	}
	return nil
}

func (m *CertificateValidationContext) GetRequireOcspStaple() *wrappers.BoolValue {
	if m != nil {
		return m.RequireOcspStaple
	}
	return nil
}

func (m *CertificateValidationContext) GetRequireSignedCertificateTimestamp() *wrappers.BoolValue {
	if m != nil {
		return m.RequireSignedCertificateTimestamp
	}
	return nil
}

func (m *CertificateValidationContext) GetCrl() *core.DataSource {
	if m != nil {
		return m.Crl
	}
	return nil
}

func (m *CertificateValidationContext) GetAllowExpiredCertificate() bool {
	if m != nil {
		return m.AllowExpiredCertificate
	}
	return false
}

// TLS context shared by both client and server TLS contexts.
type CommonTlsContext struct {
	// TLS protocol versions, cipher suites etc.
	TlsParams *TlsParameters `protobuf:"bytes,1,opt,name=tls_params,json=tlsParams,proto3" json:"tls_params,omitempty"`
	// Multiple TLS certificates can be associated with the same context.
	// E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
	//
	// .. attention::
	//
	//   Although this is a list, currently only a single certificate is supported. This will be
	//   relaxed in the future.
	TlsCertificates []*TlsCertificate `protobuf:"bytes,2,rep,name=tls_certificates,json=tlsCertificates,proto3" json:"tls_certificates,omitempty"`
	// Configs for fetching TLS certificates via SDS API.
	TlsCertificateSdsSecretConfigs []*SdsSecretConfig `protobuf:"bytes,6,rep,name=tls_certificate_sds_secret_configs,json=tlsCertificateSdsSecretConfigs,proto3" json:"tls_certificate_sds_secret_configs,omitempty"`
	// Types that are valid to be assigned to ValidationContextType:
	//	*CommonTlsContext_ValidationContext
	//	*CommonTlsContext_ValidationContextSdsSecretConfig
	ValidationContextType isCommonTlsContext_ValidationContextType `protobuf_oneof:"validation_context_type"`
	// Supplies the list of ALPN protocols that the listener should expose. In
	// practice this is likely to be set to one of two values (see the
	// :ref:`codec_type
	// <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.codec_type>`
	// parameter in the HTTP connection manager for more information):
	//
	// * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
	// * "http/1.1" If the listener is only going to support HTTP/1.1.
	//
	// There is no default for this parameter. If empty, Envoy will not expose ALPN.
	AlpnProtocols        []string `protobuf:"bytes,4,rep,name=alpn_protocols,json=alpnProtocols,proto3" json:"alpn_protocols,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommonTlsContext) Reset()         { *m = CommonTlsContext{} }
func (m *CommonTlsContext) String() string { return proto.CompactTextString(m) }
func (*CommonTlsContext) ProtoMessage()    {}
func (*CommonTlsContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c3851c0865b2745, []int{4}
}

func (m *CommonTlsContext) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CommonTlsContext.Unmarshal(m, b)
}
func (m *CommonTlsContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CommonTlsContext.Marshal(b, m, deterministic)
}
func (m *CommonTlsContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonTlsContext.Merge(m, src)
}
func (m *CommonTlsContext) XXX_Size() int {
	return xxx_messageInfo_CommonTlsContext.Size(m)
}
func (m *CommonTlsContext) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonTlsContext.DiscardUnknown(m)
}

var xxx_messageInfo_CommonTlsContext proto.InternalMessageInfo

func (m *CommonTlsContext) GetTlsParams() *TlsParameters {
	if m != nil {
		return m.TlsParams
	}
	return nil
}

func (m *CommonTlsContext) GetTlsCertificates() []*TlsCertificate {
	if m != nil {
		return m.TlsCertificates
	}
	return nil
}

func (m *CommonTlsContext) GetTlsCertificateSdsSecretConfigs() []*SdsSecretConfig {
	if m != nil {
		return m.TlsCertificateSdsSecretConfigs
	}
	return nil
}

type isCommonTlsContext_ValidationContextType interface {
	isCommonTlsContext_ValidationContextType()
}

type CommonTlsContext_ValidationContext struct {
	ValidationContext *CertificateValidationContext `protobuf:"bytes,3,opt,name=validation_context,json=validationContext,proto3,oneof"`
}

type CommonTlsContext_ValidationContextSdsSecretConfig struct {
	ValidationContextSdsSecretConfig *SdsSecretConfig `protobuf:"bytes,7,opt,name=validation_context_sds_secret_config,json=validationContextSdsSecretConfig,proto3,oneof"`
}

func (*CommonTlsContext_ValidationContext) isCommonTlsContext_ValidationContextType() {}

func (*CommonTlsContext_ValidationContextSdsSecretConfig) isCommonTlsContext_ValidationContextType() {}

func (m *CommonTlsContext) GetValidationContextType() isCommonTlsContext_ValidationContextType {
	if m != nil {
		return m.ValidationContextType
	}
	return nil
}

func (m *CommonTlsContext) GetValidationContext() *CertificateValidationContext {
	if x, ok := m.GetValidationContextType().(*CommonTlsContext_ValidationContext); ok {
		return x.ValidationContext
	}
	return nil
}

func (m *CommonTlsContext) GetValidationContextSdsSecretConfig() *SdsSecretConfig {
	if x, ok := m.GetValidationContextType().(*CommonTlsContext_ValidationContextSdsSecretConfig); ok {
		return x.ValidationContextSdsSecretConfig
	}
	return nil
}

func (m *CommonTlsContext) GetAlpnProtocols() []string {
	if m != nil {
		return m.AlpnProtocols
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CommonTlsContext) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CommonTlsContext_OneofMarshaler, _CommonTlsContext_OneofUnmarshaler, _CommonTlsContext_OneofSizer, []interface{}{
		(*CommonTlsContext_ValidationContext)(nil),
		(*CommonTlsContext_ValidationContextSdsSecretConfig)(nil),
	}
}

func _CommonTlsContext_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CommonTlsContext)
	// validation_context_type
	switch x := m.ValidationContextType.(type) {
	case *CommonTlsContext_ValidationContext:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ValidationContext); err != nil {
			return err
		}
	case *CommonTlsContext_ValidationContextSdsSecretConfig:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ValidationContextSdsSecretConfig); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CommonTlsContext.ValidationContextType has unexpected type %T", x)
	}
	return nil
}

func _CommonTlsContext_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CommonTlsContext)
	switch tag {
	case 3: // validation_context_type.validation_context
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CertificateValidationContext)
		err := b.DecodeMessage(msg)
		m.ValidationContextType = &CommonTlsContext_ValidationContext{msg}
		return true, err
	case 7: // validation_context_type.validation_context_sds_secret_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SdsSecretConfig)
		err := b.DecodeMessage(msg)
		m.ValidationContextType = &CommonTlsContext_ValidationContextSdsSecretConfig{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CommonTlsContext_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CommonTlsContext)
	// validation_context_type
	switch x := m.ValidationContextType.(type) {
	case *CommonTlsContext_ValidationContext:
		s := proto.Size(x.ValidationContext)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CommonTlsContext_ValidationContextSdsSecretConfig:
		s := proto.Size(x.ValidationContextSdsSecretConfig)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type UpstreamTlsContext struct {
	// Common TLS context settings.
	CommonTlsContext *CommonTlsContext `protobuf:"bytes,1,opt,name=common_tls_context,json=commonTlsContext,proto3" json:"common_tls_context,omitempty"`
	// SNI string to use when creating TLS backend connections.
	Sni string `protobuf:"bytes,2,opt,name=sni,proto3" json:"sni,omitempty"`
	// If true, server-initiated TLS renegotiation will be allowed.
	//
	// .. attention::
	//
	//   TLS renegotiation is considered insecure and shouldn't be used unless absolutely necessary.
	AllowRenegotiation   bool     `protobuf:"varint,3,opt,name=allow_renegotiation,json=allowRenegotiation,proto3" json:"allow_renegotiation,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpstreamTlsContext) Reset()         { *m = UpstreamTlsContext{} }
func (m *UpstreamTlsContext) String() string { return proto.CompactTextString(m) }
func (*UpstreamTlsContext) ProtoMessage()    {}
func (*UpstreamTlsContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c3851c0865b2745, []int{5}
}

func (m *UpstreamTlsContext) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UpstreamTlsContext.Unmarshal(m, b)
}
func (m *UpstreamTlsContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UpstreamTlsContext.Marshal(b, m, deterministic)
}
func (m *UpstreamTlsContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpstreamTlsContext.Merge(m, src)
}
func (m *UpstreamTlsContext) XXX_Size() int {
	return xxx_messageInfo_UpstreamTlsContext.Size(m)
}
func (m *UpstreamTlsContext) XXX_DiscardUnknown() {
	xxx_messageInfo_UpstreamTlsContext.DiscardUnknown(m)
}

var xxx_messageInfo_UpstreamTlsContext proto.InternalMessageInfo

func (m *UpstreamTlsContext) GetCommonTlsContext() *CommonTlsContext {
	if m != nil {
		return m.CommonTlsContext
	}
	return nil
}

func (m *UpstreamTlsContext) GetSni() string {
	if m != nil {
		return m.Sni
	}
	return ""
}

func (m *UpstreamTlsContext) GetAllowRenegotiation() bool {
	if m != nil {
		return m.AllowRenegotiation
	}
	return false
}

type DownstreamTlsContext struct {
	// Common TLS context settings.
	CommonTlsContext *CommonTlsContext `protobuf:"bytes,1,opt,name=common_tls_context,json=commonTlsContext,proto3" json:"common_tls_context,omitempty"`
	// If specified, Envoy will reject connections without a valid client
	// certificate.
	RequireClientCertificate *wrappers.BoolValue `protobuf:"bytes,2,opt,name=require_client_certificate,json=requireClientCertificate,proto3" json:"require_client_certificate,omitempty"`
	// If specified, Envoy will reject connections without a valid and matching SNI.
	// [#not-implemented-hide:]
	RequireSni *wrappers.BoolValue `protobuf:"bytes,3,opt,name=require_sni,json=requireSni,proto3" json:"require_sni,omitempty"`
	// Types that are valid to be assigned to SessionTicketKeysType:
	//	*DownstreamTlsContext_SessionTicketKeys
	//	*DownstreamTlsContext_SessionTicketKeysSdsSecretConfig
	SessionTicketKeysType isDownstreamTlsContext_SessionTicketKeysType `protobuf_oneof:"session_ticket_keys_type"`
	XXX_NoUnkeyedLiteral  struct{}                                     `json:"-"`
	XXX_unrecognized      []byte                                       `json:"-"`
	XXX_sizecache         int32                                        `json:"-"`
}

func (m *DownstreamTlsContext) Reset()         { *m = DownstreamTlsContext{} }
func (m *DownstreamTlsContext) String() string { return proto.CompactTextString(m) }
func (*DownstreamTlsContext) ProtoMessage()    {}
func (*DownstreamTlsContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c3851c0865b2745, []int{6}
}

func (m *DownstreamTlsContext) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DownstreamTlsContext.Unmarshal(m, b)
}
func (m *DownstreamTlsContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DownstreamTlsContext.Marshal(b, m, deterministic)
}
func (m *DownstreamTlsContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownstreamTlsContext.Merge(m, src)
}
func (m *DownstreamTlsContext) XXX_Size() int {
	return xxx_messageInfo_DownstreamTlsContext.Size(m)
}
func (m *DownstreamTlsContext) XXX_DiscardUnknown() {
	xxx_messageInfo_DownstreamTlsContext.DiscardUnknown(m)
}

var xxx_messageInfo_DownstreamTlsContext proto.InternalMessageInfo

func (m *DownstreamTlsContext) GetCommonTlsContext() *CommonTlsContext {
	if m != nil {
		return m.CommonTlsContext
	}
	return nil
}

func (m *DownstreamTlsContext) GetRequireClientCertificate() *wrappers.BoolValue {
	if m != nil {
		return m.RequireClientCertificate
	}
	return nil
}

func (m *DownstreamTlsContext) GetRequireSni() *wrappers.BoolValue {
	if m != nil {
		return m.RequireSni
	}
	return nil
}

type isDownstreamTlsContext_SessionTicketKeysType interface {
	isDownstreamTlsContext_SessionTicketKeysType()
}

type DownstreamTlsContext_SessionTicketKeys struct {
	SessionTicketKeys *TlsSessionTicketKeys `protobuf:"bytes,4,opt,name=session_ticket_keys,json=sessionTicketKeys,proto3,oneof"`
}

type DownstreamTlsContext_SessionTicketKeysSdsSecretConfig struct {
	SessionTicketKeysSdsSecretConfig *SdsSecretConfig `protobuf:"bytes,5,opt,name=session_ticket_keys_sds_secret_config,json=sessionTicketKeysSdsSecretConfig,proto3,oneof"`
}

func (*DownstreamTlsContext_SessionTicketKeys) isDownstreamTlsContext_SessionTicketKeysType() {}

func (*DownstreamTlsContext_SessionTicketKeysSdsSecretConfig) isDownstreamTlsContext_SessionTicketKeysType() {
}

func (m *DownstreamTlsContext) GetSessionTicketKeysType() isDownstreamTlsContext_SessionTicketKeysType {
	if m != nil {
		return m.SessionTicketKeysType
	}
	return nil
}

func (m *DownstreamTlsContext) GetSessionTicketKeys() *TlsSessionTicketKeys {
	if x, ok := m.GetSessionTicketKeysType().(*DownstreamTlsContext_SessionTicketKeys); ok {
		return x.SessionTicketKeys
	}
	return nil
}

func (m *DownstreamTlsContext) GetSessionTicketKeysSdsSecretConfig() *SdsSecretConfig {
	if x, ok := m.GetSessionTicketKeysType().(*DownstreamTlsContext_SessionTicketKeysSdsSecretConfig); ok {
		return x.SessionTicketKeysSdsSecretConfig
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DownstreamTlsContext) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DownstreamTlsContext_OneofMarshaler, _DownstreamTlsContext_OneofUnmarshaler, _DownstreamTlsContext_OneofSizer, []interface{}{
		(*DownstreamTlsContext_SessionTicketKeys)(nil),
		(*DownstreamTlsContext_SessionTicketKeysSdsSecretConfig)(nil),
	}
}

func _DownstreamTlsContext_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DownstreamTlsContext)
	// session_ticket_keys_type
	switch x := m.SessionTicketKeysType.(type) {
	case *DownstreamTlsContext_SessionTicketKeys:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SessionTicketKeys); err != nil {
			return err
		}
	case *DownstreamTlsContext_SessionTicketKeysSdsSecretConfig:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SessionTicketKeysSdsSecretConfig); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DownstreamTlsContext.SessionTicketKeysType has unexpected type %T", x)
	}
	return nil
}

func _DownstreamTlsContext_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DownstreamTlsContext)
	switch tag {
	case 4: // session_ticket_keys_type.session_ticket_keys
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TlsSessionTicketKeys)
		err := b.DecodeMessage(msg)
		m.SessionTicketKeysType = &DownstreamTlsContext_SessionTicketKeys{msg}
		return true, err
	case 5: // session_ticket_keys_type.session_ticket_keys_sds_secret_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SdsSecretConfig)
		err := b.DecodeMessage(msg)
		m.SessionTicketKeysType = &DownstreamTlsContext_SessionTicketKeysSdsSecretConfig{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DownstreamTlsContext_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DownstreamTlsContext)
	// session_ticket_keys_type
	switch x := m.SessionTicketKeysType.(type) {
	case *DownstreamTlsContext_SessionTicketKeys:
		s := proto.Size(x.SessionTicketKeys)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DownstreamTlsContext_SessionTicketKeysSdsSecretConfig:
		s := proto.Size(x.SessionTicketKeysSdsSecretConfig)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// [#proto-status: experimental]
type SdsSecretConfig struct {
	// Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
	// When both name and config are specified, then secret can be fetched and/or reloaded via SDS.
	// When only name is specified, then secret will be loaded from static resources [V2-API-DIFF].
	Name                 string             `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	SdsConfig            *core.ConfigSource `protobuf:"bytes,2,opt,name=sds_config,json=sdsConfig,proto3" json:"sds_config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *SdsSecretConfig) Reset()         { *m = SdsSecretConfig{} }
func (m *SdsSecretConfig) String() string { return proto.CompactTextString(m) }
func (*SdsSecretConfig) ProtoMessage()    {}
func (*SdsSecretConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c3851c0865b2745, []int{7}
}

func (m *SdsSecretConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SdsSecretConfig.Unmarshal(m, b)
}
func (m *SdsSecretConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SdsSecretConfig.Marshal(b, m, deterministic)
}
func (m *SdsSecretConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SdsSecretConfig.Merge(m, src)
}
func (m *SdsSecretConfig) XXX_Size() int {
	return xxx_messageInfo_SdsSecretConfig.Size(m)
}
func (m *SdsSecretConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SdsSecretConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SdsSecretConfig proto.InternalMessageInfo

func (m *SdsSecretConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SdsSecretConfig) GetSdsConfig() *core.ConfigSource {
	if m != nil {
		return m.SdsConfig
	}
	return nil
}

// [#proto-status: experimental]
type Secret struct {
	// Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*Secret_TlsCertificate
	//	*Secret_SessionTicketKeys
	//	*Secret_ValidationContext
	Type                 isSecret_Type `protobuf_oneof:"type"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Secret) Reset()         { *m = Secret{} }
func (m *Secret) String() string { return proto.CompactTextString(m) }
func (*Secret) ProtoMessage()    {}
func (*Secret) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c3851c0865b2745, []int{8}
}

func (m *Secret) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Secret.Unmarshal(m, b)
}
func (m *Secret) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Secret.Marshal(b, m, deterministic)
}
func (m *Secret) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Secret.Merge(m, src)
}
func (m *Secret) XXX_Size() int {
	return xxx_messageInfo_Secret.Size(m)
}
func (m *Secret) XXX_DiscardUnknown() {
	xxx_messageInfo_Secret.DiscardUnknown(m)
}

var xxx_messageInfo_Secret proto.InternalMessageInfo

func (m *Secret) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type isSecret_Type interface {
	isSecret_Type()
}

type Secret_TlsCertificate struct {
	TlsCertificate *TlsCertificate `protobuf:"bytes,2,opt,name=tls_certificate,json=tlsCertificate,proto3,oneof"`
}

type Secret_SessionTicketKeys struct {
	SessionTicketKeys *TlsSessionTicketKeys `protobuf:"bytes,3,opt,name=session_ticket_keys,json=sessionTicketKeys,proto3,oneof"`
}

type Secret_ValidationContext struct {
	ValidationContext *CertificateValidationContext `protobuf:"bytes,4,opt,name=validation_context,json=validationContext,proto3,oneof"`
}

func (*Secret_TlsCertificate) isSecret_Type() {}

func (*Secret_SessionTicketKeys) isSecret_Type() {}

func (*Secret_ValidationContext) isSecret_Type() {}

func (m *Secret) GetType() isSecret_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Secret) GetTlsCertificate() *TlsCertificate {
	if x, ok := m.GetType().(*Secret_TlsCertificate); ok {
		return x.TlsCertificate
	}
	return nil
}

func (m *Secret) GetSessionTicketKeys() *TlsSessionTicketKeys {
	if x, ok := m.GetType().(*Secret_SessionTicketKeys); ok {
		return x.SessionTicketKeys
	}
	return nil
}

func (m *Secret) GetValidationContext() *CertificateValidationContext {
	if x, ok := m.GetType().(*Secret_ValidationContext); ok {
		return x.ValidationContext
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Secret) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Secret_OneofMarshaler, _Secret_OneofUnmarshaler, _Secret_OneofSizer, []interface{}{
		(*Secret_TlsCertificate)(nil),
		(*Secret_SessionTicketKeys)(nil),
		(*Secret_ValidationContext)(nil),
	}
}

func _Secret_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Secret)
	// type
	switch x := m.Type.(type) {
	case *Secret_TlsCertificate:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TlsCertificate); err != nil {
			return err
		}
	case *Secret_SessionTicketKeys:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SessionTicketKeys); err != nil {
			return err
		}
	case *Secret_ValidationContext:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ValidationContext); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Secret.Type has unexpected type %T", x)
	}
	return nil
}

func _Secret_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Secret)
	switch tag {
	case 2: // type.tls_certificate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TlsCertificate)
		err := b.DecodeMessage(msg)
		m.Type = &Secret_TlsCertificate{msg}
		return true, err
	case 3: // type.session_ticket_keys
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TlsSessionTicketKeys)
		err := b.DecodeMessage(msg)
		m.Type = &Secret_SessionTicketKeys{msg}
		return true, err
	case 4: // type.validation_context
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CertificateValidationContext)
		err := b.DecodeMessage(msg)
		m.Type = &Secret_ValidationContext{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Secret_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Secret)
	// type
	switch x := m.Type.(type) {
	case *Secret_TlsCertificate:
		s := proto.Size(x.TlsCertificate)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Secret_SessionTicketKeys:
		s := proto.Size(x.SessionTicketKeys)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Secret_ValidationContext:
		s := proto.Size(x.ValidationContext)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterEnum("envoy.api.v2.auth.TlsParameters_TlsProtocol", TlsParameters_TlsProtocol_name, TlsParameters_TlsProtocol_value)
	proto.RegisterType((*TlsParameters)(nil), "envoy.api.v2.auth.TlsParameters")
	proto.RegisterType((*TlsCertificate)(nil), "envoy.api.v2.auth.TlsCertificate")
	proto.RegisterType((*TlsSessionTicketKeys)(nil), "envoy.api.v2.auth.TlsSessionTicketKeys")
	proto.RegisterType((*CertificateValidationContext)(nil), "envoy.api.v2.auth.CertificateValidationContext")
	proto.RegisterType((*CommonTlsContext)(nil), "envoy.api.v2.auth.CommonTlsContext")
	proto.RegisterType((*UpstreamTlsContext)(nil), "envoy.api.v2.auth.UpstreamTlsContext")
	proto.RegisterType((*DownstreamTlsContext)(nil), "envoy.api.v2.auth.DownstreamTlsContext")
	proto.RegisterType((*SdsSecretConfig)(nil), "envoy.api.v2.auth.SdsSecretConfig")
	proto.RegisterType((*Secret)(nil), "envoy.api.v2.auth.Secret")
}

func init() { proto.RegisterFile("envoy/api/v2/auth/cert.proto", fileDescriptor_0c3851c0865b2745) }

var fileDescriptor_0c3851c0865b2745 = []byte{
	// 1189 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x55, 0xcf, 0x92, 0xdb, 0xc4,
	0x13, 0x5e, 0x59, 0x5a, 0xc7, 0xdb, 0x4e, 0x36, 0xda, 0xc9, 0xfe, 0x6a, 0x95, 0xad, 0xfd, 0x25,
	0x8e, 0x92, 0x14, 0x7b, 0x48, 0x59, 0x64, 0x53, 0x1c, 0xf8, 0x17, 0x88, 0x1d, 0xaa, 0xb6, 0x92,
	0x40, 0x40, 0x76, 0x52, 0x81, 0x8b, 0x98, 0x95, 0x67, 0xed, 0xc1, 0xb2, 0x24, 0x66, 0xc6, 0xde,
	0xf8, 0xca, 0x23, 0xe4, 0xcc, 0x03, 0x70, 0xe3, 0xc6, 0x81, 0x2a, 0xaa, 0x78, 0x01, 0x5e, 0x82,
	0x1b, 0x17, 0xce, 0xdc, 0xa0, 0x66, 0x46, 0xb6, 0x65, 0x5b, 0x89, 0x4d, 0xd5, 0x16, 0x37, 0xcd,
	0x74, 0xf7, 0xf7, 0xb5, 0xa6, 0xbf, 0xee, 0x86, 0x03, 0x12, 0x8f, 0x92, 0xb1, 0x87, 0x53, 0xea,
	0x8d, 0x8e, 0x3c, 0x3c, 0x14, 0x3d, 0x2f, 0x24, 0x4c, 0xd4, 0x53, 0x96, 0x88, 0x04, 0xed, 0x28,
	0x6b, 0x1d, 0xa7, 0xb4, 0x3e, 0x3a, 0xaa, 0x4b, 0xeb, 0xfe, 0x7c, 0x40, 0x98, 0x30, 0xe2, 0x9d,
	0x60, 0x4e, 0x74, 0xc0, 0xfe, 0xed, 0x65, 0x6b, 0x98, 0xc4, 0xa7, 0xb4, 0x1b, 0xf0, 0x64, 0xc8,
	0xc2, 0x89, 0xdb, 0xb5, 0x6e, 0x92, 0x74, 0x23, 0xe2, 0xa9, 0xd3, 0xc9, 0xf0, 0xd4, 0x3b, 0x63,
	0x38, 0x4d, 0x09, 0xe3, 0x99, 0x7d, 0x6f, 0x84, 0x23, 0xda, 0xc1, 0x82, 0x78, 0x93, 0x8f, 0xcc,
	0xb0, 0xdb, 0x4d, 0xba, 0x89, 0xfa, 0xf4, 0xe4, 0x97, 0xbe, 0x75, 0xbf, 0x37, 0xe1, 0x52, 0x3b,
	0xe2, 0x9f, 0x63, 0x86, 0x07, 0x44, 0x10, 0xc6, 0xd1, 0x18, 0x0e, 0x44, 0xc4, 0x83, 0x01, 0x8d,
	0xe9, 0x60, 0x38, 0x08, 0x94, 0x5b, 0x98, 0x44, 0xc1, 0x88, 0x30, 0x4e, 0x93, 0xd8, 0x31, 0x6a,
	0xc6, 0xe1, 0xf6, 0xd1, 0x9d, 0xfa, 0xd2, 0xff, 0xd5, 0xe7, 0x70, 0xd4, 0x29, 0x8b, 0x6d, 0xc0,
	0xcf, 0x7f, 0xfc, 0x6a, 0x6e, 0x7e, 0x67, 0x94, 0x6c, 0xc3, 0xbf, 0x2a, 0x22, 0xfe, 0xa9, 0x06,
	0x9f, 0xd8, 0x9f, 0x6b, 0xe8, 0x29, 0x35, 0x7e, 0x59, 0x4c, 0x5d, 0x3a, 0x0f, 0x6a, 0x0d, 0xbe,
	0x48, 0x7d, 0x13, 0x2e, 0x85, 0x34, 0xed, 0x11, 0x16, 0xf0, 0x21, 0x15, 0x84, 0x3b, 0x66, 0xcd,
	0x3c, 0xdc, 0xf2, 0x2f, 0xea, 0xcb, 0x96, 0xba, 0x43, 0xd7, 0xa1, 0x4a, 0xc2, 0x4e, 0x2f, 0x08,
	0x87, 0x6c, 0x44, 0xb8, 0x63, 0x29, 0x17, 0x90, 0x57, 0x4d, 0x75, 0xe3, 0x3e, 0x85, 0x6a, 0x8e,
	0x1b, 0x5d, 0x84, 0x4a, 0xfb, 0x49, 0x2b, 0x78, 0xf0, 0xac, 0xfd, 0xd4, 0xde, 0x40, 0x55, 0xb8,
	0xd0, 0x7e, 0xd2, 0x1a, 0xdd, 0x0d, 0xde, 0xb6, 0x8d, 0xd9, 0xe1, 0xae, 0x5d, 0x9a, 0x1d, 0x8e,
	0x6c, 0x73, 0x76, 0xb8, 0x67, 0x5b, 0xee, 0x5f, 0x25, 0xd8, 0x6e, 0x47, 0xbc, 0x49, 0x98, 0xa0,
	0xa7, 0x34, 0xc4, 0x82, 0xa0, 0x47, 0xb0, 0x13, 0xce, 0x8e, 0x41, 0xd8, 0xc3, 0x54, 0x17, 0xa5,
	0x7a, 0xf4, 0xff, 0xf9, 0x97, 0x91, 0x1a, 0xaa, 0x3f, 0xc4, 0x02, 0xb7, 0x94, 0x80, 0x7c, 0x3b,
	0x17, 0xd7, 0x94, 0x61, 0xe8, 0x3e, 0x54, 0x53, 0x46, 0x47, 0x12, 0xa7, 0x4f, 0xc6, 0xea, 0x7d,
	0x57, 0xa2, 0x40, 0x16, 0xf1, 0x98, 0x8c, 0xd1, 0xbb, 0x50, 0x49, 0x31, 0xe7, 0x67, 0x09, 0xeb,
	0x38, 0xe6, 0x3a, 0xc1, 0x53, 0x77, 0x49, 0x9d, 0x84, 0x3c, 0x0d, 0xb8, 0xc0, 0x69, 0x44, 0x1c,
	0x6b, 0x2d, 0x6a, 0x19, 0xd1, 0x52, 0x01, 0x28, 0x80, 0x03, 0x4e, 0xbb, 0x31, 0xe9, 0x04, 0xf9,
	0xd7, 0x10, 0x74, 0x40, 0xb8, 0xc0, 0x83, 0xd4, 0xd9, 0xac, 0x99, 0xab, 0x01, 0xf7, 0x35, 0x44,
	0xee, 0x79, 0xdb, 0x13, 0x00, 0xf7, 0x19, 0xec, 0xb6, 0x23, 0xde, 0x22, 0x5c, 0xea, 0xa3, 0x4d,
	0xc3, 0x3e, 0x11, 0x8f, 0xc9, 0x98, 0xa3, 0x0f, 0xc1, 0xea, 0x93, 0x31, 0x77, 0x8c, 0x35, 0x08,
	0x32, 0xf5, 0xbd, 0x32, 0x4a, 0x15, 0xc3, 0x57, 0x61, 0xee, 0x6f, 0x16, 0x1c, 0xe4, 0xf8, 0x9e,
	0xeb, 0x26, 0xa5, 0x49, 0xdc, 0x4c, 0x62, 0x41, 0x5e, 0x0a, 0xf4, 0x01, 0x80, 0x60, 0x43, 0x2e,
	0xe4, 0x9f, 0xe1, 0xf5, 0x0a, 0xbb, 0x95, 0x05, 0x34, 0x31, 0x3a, 0x86, 0xbd, 0x11, 0x61, 0xf4,
	0x74, 0x3c, 0xf7, 0x2c, 0x3c, 0xed, 0x53, 0xad, 0xe8, 0x86, 0x2d, 0x33, 0xaa, 0xbe, 0x32, 0x2a,
	0x6e, 0x99, 0x59, 0xb5, 0x3b, 0x87, 0x77, 0xfc, 0xff, 0xe9, 0x80, 0x5c, 0x52, 0xad, 0xb4, 0x4f,
	0x5f, 0x83, 0xd4, 0xc3, 0xbc, 0xe7, 0x94, 0x0a, 0x90, 0x3e, 0x3e, 0x0c, 0x0a, 0x90, 0x8e, 0x31,
	0xef, 0xa1, 0x77, 0xa6, 0x48, 0x7c, 0x78, 0xf2, 0x0d, 0x09, 0x45, 0x80, 0x23, 0x11, 0xc4, 0x78,
	0x40, 0xb2, 0x16, 0xda, 0xd5, 0xe6, 0x96, 0xb6, 0x3e, 0x88, 0xc4, 0x67, 0x78, 0x20, 0x85, 0x7e,
	0x85, 0x91, 0x6f, 0x87, 0x94, 0x91, 0x20, 0xaf, 0x94, 0x4d, 0xf5, 0x22, 0xfb, 0x75, 0x3d, 0x07,
	0xeb, 0x93, 0x39, 0x58, 0x6f, 0x24, 0x49, 0xf4, 0x1c, 0x47, 0x43, 0xe2, 0xef, 0x64, 0x61, 0x4f,
	0x67, 0x6a, 0xe9, 0xc3, 0xad, 0x09, 0xd6, 0x1b, 0x55, 0x53, 0x5e, 0x09, 0x7e, 0x23, 0xc3, 0x69,
	0xbd, 0x56, 0x39, 0xc8, 0x03, 0x33, 0x64, 0x91, 0x73, 0x61, 0x9d, 0xd2, 0x49, 0x4f, 0xf4, 0x1e,
	0x5c, 0xc5, 0x51, 0x94, 0x9c, 0x05, 0xe4, 0x65, 0x4a, 0xd9, 0x7c, 0x72, 0x4e, 0xa5, 0x66, 0x1c,
	0x56, 0xfc, 0x3d, 0xe5, 0xf0, 0x89, 0xb6, 0xe7, 0x58, 0xdd, 0x5f, 0x2c, 0xb0, 0x9b, 0xc9, 0x60,
	0x90, 0xc4, 0x72, 0x4e, 0x64, 0x1a, 0xfa, 0x08, 0x40, 0x0e, 0xd2, 0x54, 0x8e, 0x44, 0x9e, 0x69,
	0xa8, 0xb6, 0x6a, 0x6c, 0xfa, 0x5b, 0x22, 0x3b, 0x72, 0xf4, 0x02, 0x6c, 0x09, 0x90, 0xcb, 0x83,
	0xab, 0xaa, 0x57, 0x8f, 0x6e, 0x14, 0xc3, 0xe4, 0x52, 0x9a, 0x89, 0xde, 0x36, 0xfc, 0xcb, 0x62,
	0xce, 0xc6, 0x51, 0x0c, 0xee, 0x02, 0x72, 0xc0, 0x3b, 0x3c, 0xe0, 0x24, 0x64, 0x44, 0x04, 0x7a,
	0xe3, 0x71, 0xa7, 0xac, 0xb8, 0xdc, 0x02, 0xae, 0x56, 0x87, 0xb7, 0x94, 0x6f, 0x53, 0xb9, 0xfa,
	0xd7, 0xe6, 0x09, 0x16, 0xcc, 0x1c, 0x7d, 0x0d, 0x68, 0x34, 0xed, 0x31, 0x89, 0x2f, 0x1f, 0x28,
	0x1b, 0x56, 0x5e, 0x01, 0xfe, 0x9b, 0x7a, 0xf3, 0x78, 0xc3, 0xdf, 0x19, 0x2d, 0x35, 0xac, 0x80,
	0x5b, 0xcb, 0x0c, 0xcb, 0x3f, 0x95, 0xe9, 0x61, 0x8d, 0x7f, 0x3a, 0xde, 0xf0, 0x6b, 0x4b, 0x34,
	0x0b, 0x3e, 0xe8, 0x36, 0x6c, 0xe3, 0x28, 0x8d, 0xa7, 0x4b, 0x72, 0xb2, 0x8e, 0x2e, 0xc9, 0xdb,
	0xc9, 0x06, 0xe2, 0x8d, 0xab, 0xb0, 0x57, 0x90, 0x9c, 0x18, 0xa7, 0xe4, 0x91, 0x55, 0xd9, 0xb4,
	0xcb, 0xee, 0x4f, 0x06, 0xa0, 0x67, 0x29, 0x17, 0x8c, 0xe0, 0x41, 0x4e, 0x41, 0x5f, 0x00, 0x0a,
	0x95, 0xaa, 0x02, 0x55, 0xad, 0xec, 0xd9, 0xb4, 0x92, 0x6e, 0x16, 0x3d, 0xdb, 0x82, 0x04, 0x7d,
	0x3b, 0x5c, 0x14, 0xe5, 0x01, 0x98, 0x3c, 0xa6, 0x6a, 0xc9, 0x6c, 0x65, 0x1a, 0x61, 0xe6, 0xe1,
	0xdf, 0x86, 0x2f, 0xaf, 0x91, 0x07, 0x57, 0x74, 0x0f, 0x30, 0x12, 0x93, 0x6e, 0x22, 0xa8, 0xca,
	0x58, 0x15, 0xaa, 0xe2, 0x23, 0x65, 0xf2, 0xf3, 0x16, 0xf7, 0x4f, 0x13, 0x76, 0x1f, 0x26, 0x67,
	0xf1, 0x7f, 0x91, 0xfa, 0x0b, 0xd8, 0x9f, 0x8c, 0x8f, 0x30, 0xa2, 0x24, 0x16, 0x73, 0x1d, 0x5a,
	0x5a, 0x39, 0x34, 0x9c, 0x2c, 0xba, 0xa9, 0x82, 0xf3, 0xdb, 0xfc, 0x7d, 0xa8, 0x4e, 0x07, 0x53,
	0x4c, 0x33, 0x5d, 0xbe, 0x09, 0x0a, 0x26, 0xf3, 0x27, 0xa6, 0xe8, 0x4b, 0xb8, 0xc2, 0xf5, 0x7e,
	0x0a, 0x84, 0x5a, 0x50, 0x81, 0xda, 0x4c, 0x7a, 0x97, 0xbe, 0x55, 0xdc, 0xa8, 0x4b, 0x0b, 0x4d,
	0x8a, 0x9a, 0x2f, 0x6d, 0xb9, 0x21, 0xdc, 0x2e, 0x80, 0x2e, 0x50, 0xf5, 0xe6, 0xbf, 0x51, 0xf5,
	0x12, 0xcf, 0x82, 0x4f, 0x63, 0x1f, 0x9c, 0x22, 0x5a, 0xa9, 0x57, 0x97, 0xc0, 0xe5, 0xc5, 0x26,
	0x40, 0x60, 0xa9, 0x35, 0x22, 0x8b, 0xbb, 0xe5, 0xab, 0x6f, 0x74, 0x1f, 0x40, 0x66, 0x99, 0xa5,
	0xa7, 0x6b, 0x73, 0xbd, 0x60, 0x08, 0x6b, 0x88, 0xc9, 0x06, 0xe5, 0x1d, 0xae, 0x2f, 0xdc, 0x1f,
	0x4b, 0x50, 0xd6, 0x24, 0x85, 0xf0, 0x4f, 0xe0, 0xf2, 0xc2, 0xfc, 0xca, 0x38, 0x56, 0x0f, 0xc6,
	0xe3, 0x0d, 0x7f, 0x7b, 0x7e, 0x5a, 0xbd, 0xae, 0x82, 0xe6, 0x39, 0x54, 0xb0, 0x78, 0xf0, 0x59,
	0xe7, 0x37, 0xf8, 0x1a, 0x65, 0xb0, 0x64, 0x61, 0x1a, 0xf0, 0xc3, 0xef, 0xd7, 0x8c, 0xaf, 0x2c,
	0x89, 0x72, 0x52, 0x56, 0x92, 0xbd, 0xf7, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x9e, 0x8b, 0x0f,
	0x22, 0x1d, 0x0d, 0x00, 0x00,
}
