// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: flow/flow.proto

package flow

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"strings"
	"time"
	"unicode/utf8"

	"github.com/golang/protobuf/ptypes"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = ptypes.DynamicAny{}
)

// define the regex for a UUID once up-front
var _flow_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on Flow with the rules defined in the proto
// definition for this message. If any rules are violated, an error is returned.
func (m *Flow) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlowValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Verdict

	// no validation rules for DropReason

	if v, ok := interface{}(m.GetEthernet()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlowValidationError{
				field:  "Ethernet",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetIP()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlowValidationError{
				field:  "IP",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetL4()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlowValidationError{
				field:  "L4",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlowValidationError{
				field:  "Source",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetDestination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlowValidationError{
				field:  "Destination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Type

	// no validation rules for NodeName

	if v, ok := interface{}(m.GetL7()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlowValidationError{
				field:  "L7",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Reply

	if v, ok := interface{}(m.GetEventType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlowValidationError{
				field:  "EventType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetSourceService()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlowValidationError{
				field:  "SourceService",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetDestinationService()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlowValidationError{
				field:  "DestinationService",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Summary

	return nil
}

// FlowValidationError is the validation error returned by Flow.Validate if the
// designated constraints aren't met.
type FlowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlowValidationError) ErrorName() string { return "FlowValidationError" }

// Error satisfies the builtin error interface
func (e FlowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlow.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlowValidationError{}

// Validate checks the field values on Layer4 with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Layer4) Validate() error {
	if m == nil {
		return nil
	}

	switch m.Protocol.(type) {

	case *Layer4_TCP:

		if v, ok := interface{}(m.GetTCP()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Layer4ValidationError{
					field:  "TCP",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Layer4_UDP:

		if v, ok := interface{}(m.GetUDP()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Layer4ValidationError{
					field:  "UDP",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Layer4_ICMPv4:

		if v, ok := interface{}(m.GetICMPv4()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Layer4ValidationError{
					field:  "ICMPv4",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Layer4_ICMPv6:

		if v, ok := interface{}(m.GetICMPv6()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Layer4ValidationError{
					field:  "ICMPv6",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// Layer4ValidationError is the validation error returned by Layer4.Validate if
// the designated constraints aren't met.
type Layer4ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Layer4ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Layer4ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Layer4ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Layer4ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Layer4ValidationError) ErrorName() string { return "Layer4ValidationError" }

// Error satisfies the builtin error interface
func (e Layer4ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLayer4.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Layer4ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Layer4ValidationError{}

// Validate checks the field values on Layer7 with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Layer7) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Type

	// no validation rules for LatencyNs

	switch m.Record.(type) {

	case *Layer7_Dns:

		if v, ok := interface{}(m.GetDns()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Layer7ValidationError{
					field:  "Dns",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Layer7_Http:

		if v, ok := interface{}(m.GetHttp()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Layer7ValidationError{
					field:  "Http",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Layer7_Kafka:

		if v, ok := interface{}(m.GetKafka()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Layer7ValidationError{
					field:  "Kafka",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// Layer7ValidationError is the validation error returned by Layer7.Validate if
// the designated constraints aren't met.
type Layer7ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Layer7ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Layer7ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Layer7ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Layer7ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Layer7ValidationError) ErrorName() string { return "Layer7ValidationError" }

// Error satisfies the builtin error interface
func (e Layer7ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLayer7.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Layer7ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Layer7ValidationError{}

// Validate checks the field values on Endpoint with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Endpoint) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for ID

	// no validation rules for Identity

	// no validation rules for Namespace

	// no validation rules for PodName

	return nil
}

// EndpointValidationError is the validation error returned by
// Endpoint.Validate if the designated constraints aren't met.
type EndpointValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EndpointValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EndpointValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EndpointValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EndpointValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EndpointValidationError) ErrorName() string { return "EndpointValidationError" }

// Error satisfies the builtin error interface
func (e EndpointValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEndpoint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EndpointValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EndpointValidationError{}

// Validate checks the field values on TCP with the rules defined in the proto
// definition for this message. If any rules are violated, an error is returned.
func (m *TCP) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for SourcePort

	// no validation rules for DestinationPort

	if v, ok := interface{}(m.GetFlags()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TCPValidationError{
				field:  "Flags",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// TCPValidationError is the validation error returned by TCP.Validate if the
// designated constraints aren't met.
type TCPValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TCPValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TCPValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TCPValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TCPValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TCPValidationError) ErrorName() string { return "TCPValidationError" }

// Error satisfies the builtin error interface
func (e TCPValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTCP.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TCPValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TCPValidationError{}

// Validate checks the field values on IP with the rules defined in the proto
// definition for this message. If any rules are violated, an error is returned.
func (m *IP) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Source

	// no validation rules for Destination

	// no validation rules for IpVersion

	// no validation rules for Encrypted

	return nil
}

// IPValidationError is the validation error returned by IP.Validate if the
// designated constraints aren't met.
type IPValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IPValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IPValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IPValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IPValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IPValidationError) ErrorName() string { return "IPValidationError" }

// Error satisfies the builtin error interface
func (e IPValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIP.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IPValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IPValidationError{}

// Validate checks the field values on Ethernet with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Ethernet) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Source

	// no validation rules for Destination

	return nil
}

// EthernetValidationError is the validation error returned by
// Ethernet.Validate if the designated constraints aren't met.
type EthernetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EthernetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EthernetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EthernetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EthernetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EthernetValidationError) ErrorName() string { return "EthernetValidationError" }

// Error satisfies the builtin error interface
func (e EthernetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEthernet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EthernetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EthernetValidationError{}

// Validate checks the field values on TCPFlags with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *TCPFlags) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for FIN

	// no validation rules for SYN

	// no validation rules for RST

	// no validation rules for PSH

	// no validation rules for ACK

	// no validation rules for URG

	// no validation rules for ECE

	// no validation rules for CWR

	// no validation rules for NS

	return nil
}

// TCPFlagsValidationError is the validation error returned by
// TCPFlags.Validate if the designated constraints aren't met.
type TCPFlagsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TCPFlagsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TCPFlagsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TCPFlagsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TCPFlagsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TCPFlagsValidationError) ErrorName() string { return "TCPFlagsValidationError" }

// Error satisfies the builtin error interface
func (e TCPFlagsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTCPFlags.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TCPFlagsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TCPFlagsValidationError{}

// Validate checks the field values on UDP with the rules defined in the proto
// definition for this message. If any rules are violated, an error is returned.
func (m *UDP) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for SourcePort

	// no validation rules for DestinationPort

	return nil
}

// UDPValidationError is the validation error returned by UDP.Validate if the
// designated constraints aren't met.
type UDPValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UDPValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UDPValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UDPValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UDPValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UDPValidationError) ErrorName() string { return "UDPValidationError" }

// Error satisfies the builtin error interface
func (e UDPValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUDP.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UDPValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UDPValidationError{}

// Validate checks the field values on ICMPv4 with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *ICMPv4) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Type

	// no validation rules for Code

	return nil
}

// ICMPv4ValidationError is the validation error returned by ICMPv4.Validate if
// the designated constraints aren't met.
type ICMPv4ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ICMPv4ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ICMPv4ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ICMPv4ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ICMPv4ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ICMPv4ValidationError) ErrorName() string { return "ICMPv4ValidationError" }

// Error satisfies the builtin error interface
func (e ICMPv4ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sICMPv4.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ICMPv4ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ICMPv4ValidationError{}

// Validate checks the field values on ICMPv6 with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *ICMPv6) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Type

	// no validation rules for Code

	return nil
}

// ICMPv6ValidationError is the validation error returned by ICMPv6.Validate if
// the designated constraints aren't met.
type ICMPv6ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ICMPv6ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ICMPv6ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ICMPv6ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ICMPv6ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ICMPv6ValidationError) ErrorName() string { return "ICMPv6ValidationError" }

// Error satisfies the builtin error interface
func (e ICMPv6ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sICMPv6.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ICMPv6ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ICMPv6ValidationError{}

// Validate checks the field values on EventTypeFilter with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *EventTypeFilter) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Type

	// no validation rules for MatchSubType

	// no validation rules for SubType

	return nil
}

// EventTypeFilterValidationError is the validation error returned by
// EventTypeFilter.Validate if the designated constraints aren't met.
type EventTypeFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventTypeFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventTypeFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventTypeFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventTypeFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventTypeFilterValidationError) ErrorName() string { return "EventTypeFilterValidationError" }

// Error satisfies the builtin error interface
func (e EventTypeFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventTypeFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventTypeFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventTypeFilterValidationError{}

// Validate checks the field values on CiliumEventType with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *CiliumEventType) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Type

	// no validation rules for SubType

	return nil
}

// CiliumEventTypeValidationError is the validation error returned by
// CiliumEventType.Validate if the designated constraints aren't met.
type CiliumEventTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CiliumEventTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CiliumEventTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CiliumEventTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CiliumEventTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CiliumEventTypeValidationError) ErrorName() string { return "CiliumEventTypeValidationError" }

// Error satisfies the builtin error interface
func (e CiliumEventTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCiliumEventType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CiliumEventTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CiliumEventTypeValidationError{}

// Validate checks the field values on FlowFilter with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *FlowFilter) Validate() error {
	if m == nil {
		return nil
	}

	for idx, item := range m.GetEventType() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FlowFilterValidationError{
					field:  fmt.Sprintf("EventType[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// FlowFilterValidationError is the validation error returned by
// FlowFilter.Validate if the designated constraints aren't met.
type FlowFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlowFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlowFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlowFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlowFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlowFilterValidationError) ErrorName() string { return "FlowFilterValidationError" }

// Error satisfies the builtin error interface
func (e FlowFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlowFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlowFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlowFilterValidationError{}

// Validate checks the field values on Payload with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Payload) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Type

	// no validation rules for CPU

	// no validation rules for Lost

	// no validation rules for Data

	if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PayloadValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for HostName

	return nil
}

// PayloadValidationError is the validation error returned by Payload.Validate
// if the designated constraints aren't met.
type PayloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PayloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PayloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PayloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PayloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PayloadValidationError) ErrorName() string { return "PayloadValidationError" }

// Error satisfies the builtin error interface
func (e PayloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPayload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PayloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PayloadValidationError{}

// Validate checks the field values on DNS with the rules defined in the proto
// definition for this message. If any rules are violated, an error is returned.
func (m *DNS) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Query

	// no validation rules for Ttl

	// no validation rules for ObservationSource

	// no validation rules for Rcode

	return nil
}

// DNSValidationError is the validation error returned by DNS.Validate if the
// designated constraints aren't met.
type DNSValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DNSValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DNSValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DNSValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DNSValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DNSValidationError) ErrorName() string { return "DNSValidationError" }

// Error satisfies the builtin error interface
func (e DNSValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDNS.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DNSValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DNSValidationError{}

// Validate checks the field values on HTTPHeader with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *HTTPHeader) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Key

	// no validation rules for Value

	return nil
}

// HTTPHeaderValidationError is the validation error returned by
// HTTPHeader.Validate if the designated constraints aren't met.
type HTTPHeaderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HTTPHeaderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HTTPHeaderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HTTPHeaderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HTTPHeaderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HTTPHeaderValidationError) ErrorName() string { return "HTTPHeaderValidationError" }

// Error satisfies the builtin error interface
func (e HTTPHeaderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHTTPHeader.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HTTPHeaderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HTTPHeaderValidationError{}

// Validate checks the field values on HTTP with the rules defined in the proto
// definition for this message. If any rules are violated, an error is returned.
func (m *HTTP) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Code

	// no validation rules for Method

	// no validation rules for Url

	// no validation rules for Protocol

	for idx, item := range m.GetHeaders() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HTTPValidationError{
					field:  fmt.Sprintf("Headers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// HTTPValidationError is the validation error returned by HTTP.Validate if the
// designated constraints aren't met.
type HTTPValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HTTPValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HTTPValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HTTPValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HTTPValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HTTPValidationError) ErrorName() string { return "HTTPValidationError" }

// Error satisfies the builtin error interface
func (e HTTPValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHTTP.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HTTPValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HTTPValidationError{}

// Validate checks the field values on Kafka with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Kafka) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for ErrorCode

	// no validation rules for ApiVersion

	// no validation rules for ApiKey

	// no validation rules for CorrelationId

	// no validation rules for Topic

	return nil
}

// KafkaValidationError is the validation error returned by Kafka.Validate if
// the designated constraints aren't met.
type KafkaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KafkaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KafkaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KafkaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KafkaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KafkaValidationError) ErrorName() string { return "KafkaValidationError" }

// Error satisfies the builtin error interface
func (e KafkaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKafka.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KafkaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KafkaValidationError{}

// Validate checks the field values on Service with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Service) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Name

	// no validation rules for Namespace

	return nil
}

// ServiceValidationError is the validation error returned by Service.Validate
// if the designated constraints aren't met.
type ServiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceValidationError) ErrorName() string { return "ServiceValidationError" }

// Error satisfies the builtin error interface
func (e ServiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sService.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceValidationError{}
