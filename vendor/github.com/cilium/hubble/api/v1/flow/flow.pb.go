// Code generated by protoc-gen-go. DO NOT EDIT.
// source: flow/flow.proto

package flow

import (
	fmt "fmt"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type FlowType int32

const (
	FlowType_UNKNOWN_TYPE FlowType = 0
	FlowType_L3_L4        FlowType = 1
	FlowType_L7           FlowType = 2
)

var FlowType_name = map[int32]string{
	0: "UNKNOWN_TYPE",
	1: "L3_L4",
	2: "L7",
}

var FlowType_value = map[string]int32{
	"UNKNOWN_TYPE": 0,
	"L3_L4":        1,
	"L7":           2,
}

func (x FlowType) String() string {
	return proto.EnumName(FlowType_name, int32(x))
}

func (FlowType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{0}
}

// This enum corresponds to Cilium's L7 accesslog FlowType:
//   https://github.com/cilium/cilium/blob/728c79e427438ab6f8d9375b62fccd6fed4ace3a/pkg/proxy/accesslog/record.go#L26
type L7FlowType int32

const (
	L7FlowType_UNKNOWN_L7_TYPE L7FlowType = 0
	L7FlowType_REQUEST         L7FlowType = 1
	L7FlowType_RESPONSE        L7FlowType = 2
	L7FlowType_SAMPLE          L7FlowType = 3
)

var L7FlowType_name = map[int32]string{
	0: "UNKNOWN_L7_TYPE",
	1: "REQUEST",
	2: "RESPONSE",
	3: "SAMPLE",
}

var L7FlowType_value = map[string]int32{
	"UNKNOWN_L7_TYPE": 0,
	"REQUEST":         1,
	"RESPONSE":        2,
	"SAMPLE":          3,
}

func (x L7FlowType) String() string {
	return proto.EnumName(L7FlowType_name, int32(x))
}

func (L7FlowType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{1}
}

type IPVersion int32

const (
	IPVersion_IP_NOT_USED IPVersion = 0
	IPVersion_IPv4        IPVersion = 1
	IPVersion_IPv6        IPVersion = 2
)

var IPVersion_name = map[int32]string{
	0: "IP_NOT_USED",
	1: "IPv4",
	2: "IPv6",
}

var IPVersion_value = map[string]int32{
	"IP_NOT_USED": 0,
	"IPv4":        1,
	"IPv6":        2,
}

func (x IPVersion) String() string {
	return proto.EnumName(IPVersion_name, int32(x))
}

func (IPVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{2}
}

type Verdict int32

const (
	Verdict_VERDICT_UNKNOWN Verdict = 0
	Verdict_FORWARDED       Verdict = 1
	Verdict_DROPPED         Verdict = 2
)

var Verdict_name = map[int32]string{
	0: "VERDICT_UNKNOWN",
	1: "FORWARDED",
	2: "DROPPED",
}

var Verdict_value = map[string]int32{
	"VERDICT_UNKNOWN": 0,
	"FORWARDED":       1,
	"DROPPED":         2,
}

func (x Verdict) String() string {
	return proto.EnumName(Verdict_name, int32(x))
}

func (Verdict) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{3}
}

// EventType are constants are based on the ones from <linux/perf_event.h>.
type EventType int32

const (
	EventType_UNKNOWN EventType = 0
	// EventSample is equivalent to PERF_RECORD_SAMPLE.
	EventType_EventSample EventType = 9
	// RecordLost is equivalent to PERF_RECORD_LOST.
	EventType_RecordLost EventType = 2
)

var EventType_name = map[int32]string{
	0: "UNKNOWN",
	9: "EventSample",
	2: "RecordLost",
}

var EventType_value = map[string]int32{
	"UNKNOWN":     0,
	"EventSample": 9,
	"RecordLost":  2,
}

func (x EventType) String() string {
	return proto.EnumName(EventType_name, int32(x))
}

func (EventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{4}
}

type Flow struct {
	Time    *types.Timestamp `protobuf:"bytes,1,opt,name=time,proto3" json:"time,omitempty"`
	Verdict Verdict          `protobuf:"varint,2,opt,name=verdict,proto3,enum=flow.Verdict" json:"verdict,omitempty"`
	// only applicable to Verdict = DROPPED.
	DropReason uint32 `protobuf:"varint,3,opt,name=drop_reason,json=dropReason,proto3" json:"drop_reason,omitempty"`
	// l2
	Ethernet *Ethernet `protobuf:"bytes,4,opt,name=ethernet,proto3" json:"ethernet,omitempty"`
	// l3
	IP *IP `protobuf:"bytes,5,opt,name=IP,proto3" json:"IP,omitempty"`
	// l4
	L4          *Layer4   `protobuf:"bytes,6,opt,name=l4,proto3" json:"l4,omitempty"`
	Source      *Endpoint `protobuf:"bytes,8,opt,name=source,proto3" json:"source,omitempty"`
	Destination *Endpoint `protobuf:"bytes,9,opt,name=destination,proto3" json:"destination,omitempty"`
	Type        FlowType  `protobuf:"varint,10,opt,name=Type,proto3,enum=flow.FlowType" json:"Type,omitempty"`
	// NodeName is the name of the node from which this Flow was captured.
	NodeName string `protobuf:"bytes,11,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
	// all names the source IP can have.
	SourceNames []string `protobuf:"bytes,13,rep,name=source_names,json=sourceNames,proto3" json:"source_names,omitempty"`
	// all names the destination IP can have.
	DestinationNames []string `protobuf:"bytes,14,rep,name=destination_names,json=destinationNames,proto3" json:"destination_names,omitempty"`
	// L7 information. This field is set if and only if FlowType is L7.
	L7    *Layer7 `protobuf:"bytes,15,opt,name=l7,proto3" json:"l7,omitempty"`
	Reply bool    `protobuf:"varint,16,opt,name=reply,proto3" json:"reply,omitempty"`
	// EventType of the originating Cilium event
	EventType *CiliumEventType `protobuf:"bytes,19,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	// source_service contains the service name of the source
	SourceService *Service `protobuf:"bytes,20,opt,name=source_service,json=sourceService,proto3" json:"source_service,omitempty"`
	// destination_service contains the service name of the destination
	DestinationService *Service `protobuf:"bytes,21,opt,name=destination_service,json=destinationService,proto3" json:"destination_service,omitempty"`
	// This is a temporary workaround to support summary field for pb.Flow without
	// duplicating logic from the old parser. This field will be removed once we
	// fully migrate to the new parser.
	Summary              string   `protobuf:"bytes,100000,opt,name=Summary,proto3" json:"Summary,omitempty"` // Deprecated: Do not use.
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Flow) Reset()         { *m = Flow{} }
func (m *Flow) String() string { return proto.CompactTextString(m) }
func (*Flow) ProtoMessage()    {}
func (*Flow) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{0}
}

func (m *Flow) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Flow.Unmarshal(m, b)
}
func (m *Flow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Flow.Marshal(b, m, deterministic)
}
func (m *Flow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Flow.Merge(m, src)
}
func (m *Flow) XXX_Size() int {
	return xxx_messageInfo_Flow.Size(m)
}
func (m *Flow) XXX_DiscardUnknown() {
	xxx_messageInfo_Flow.DiscardUnknown(m)
}

var xxx_messageInfo_Flow proto.InternalMessageInfo

func (m *Flow) GetTime() *types.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *Flow) GetVerdict() Verdict {
	if m != nil {
		return m.Verdict
	}
	return Verdict_VERDICT_UNKNOWN
}

func (m *Flow) GetDropReason() uint32 {
	if m != nil {
		return m.DropReason
	}
	return 0
}

func (m *Flow) GetEthernet() *Ethernet {
	if m != nil {
		return m.Ethernet
	}
	return nil
}

func (m *Flow) GetIP() *IP {
	if m != nil {
		return m.IP
	}
	return nil
}

func (m *Flow) GetL4() *Layer4 {
	if m != nil {
		return m.L4
	}
	return nil
}

func (m *Flow) GetSource() *Endpoint {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Flow) GetDestination() *Endpoint {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *Flow) GetType() FlowType {
	if m != nil {
		return m.Type
	}
	return FlowType_UNKNOWN_TYPE
}

func (m *Flow) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *Flow) GetSourceNames() []string {
	if m != nil {
		return m.SourceNames
	}
	return nil
}

func (m *Flow) GetDestinationNames() []string {
	if m != nil {
		return m.DestinationNames
	}
	return nil
}

func (m *Flow) GetL7() *Layer7 {
	if m != nil {
		return m.L7
	}
	return nil
}

func (m *Flow) GetReply() bool {
	if m != nil {
		return m.Reply
	}
	return false
}

func (m *Flow) GetEventType() *CiliumEventType {
	if m != nil {
		return m.EventType
	}
	return nil
}

func (m *Flow) GetSourceService() *Service {
	if m != nil {
		return m.SourceService
	}
	return nil
}

func (m *Flow) GetDestinationService() *Service {
	if m != nil {
		return m.DestinationService
	}
	return nil
}

// Deprecated: Do not use.
func (m *Flow) GetSummary() string {
	if m != nil {
		return m.Summary
	}
	return ""
}

type Layer4 struct {
	// Types that are valid to be assigned to Protocol:
	//	*Layer4_TCP
	//	*Layer4_UDP
	//	*Layer4_ICMPv4
	//	*Layer4_ICMPv6
	Protocol             isLayer4_Protocol `protobuf_oneof:"protocol"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Layer4) Reset()         { *m = Layer4{} }
func (m *Layer4) String() string { return proto.CompactTextString(m) }
func (*Layer4) ProtoMessage()    {}
func (*Layer4) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{1}
}

func (m *Layer4) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Layer4.Unmarshal(m, b)
}
func (m *Layer4) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Layer4.Marshal(b, m, deterministic)
}
func (m *Layer4) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Layer4.Merge(m, src)
}
func (m *Layer4) XXX_Size() int {
	return xxx_messageInfo_Layer4.Size(m)
}
func (m *Layer4) XXX_DiscardUnknown() {
	xxx_messageInfo_Layer4.DiscardUnknown(m)
}

var xxx_messageInfo_Layer4 proto.InternalMessageInfo

type isLayer4_Protocol interface {
	isLayer4_Protocol()
}

type Layer4_TCP struct {
	TCP *TCP `protobuf:"bytes,1,opt,name=TCP,proto3,oneof"`
}

type Layer4_UDP struct {
	UDP *UDP `protobuf:"bytes,2,opt,name=UDP,proto3,oneof"`
}

type Layer4_ICMPv4 struct {
	ICMPv4 *ICMPv4 `protobuf:"bytes,3,opt,name=ICMPv4,proto3,oneof"`
}

type Layer4_ICMPv6 struct {
	ICMPv6 *ICMPv6 `protobuf:"bytes,4,opt,name=ICMPv6,proto3,oneof"`
}

func (*Layer4_TCP) isLayer4_Protocol() {}

func (*Layer4_UDP) isLayer4_Protocol() {}

func (*Layer4_ICMPv4) isLayer4_Protocol() {}

func (*Layer4_ICMPv6) isLayer4_Protocol() {}

func (m *Layer4) GetProtocol() isLayer4_Protocol {
	if m != nil {
		return m.Protocol
	}
	return nil
}

func (m *Layer4) GetTCP() *TCP {
	if x, ok := m.GetProtocol().(*Layer4_TCP); ok {
		return x.TCP
	}
	return nil
}

func (m *Layer4) GetUDP() *UDP {
	if x, ok := m.GetProtocol().(*Layer4_UDP); ok {
		return x.UDP
	}
	return nil
}

func (m *Layer4) GetICMPv4() *ICMPv4 {
	if x, ok := m.GetProtocol().(*Layer4_ICMPv4); ok {
		return x.ICMPv4
	}
	return nil
}

func (m *Layer4) GetICMPv6() *ICMPv6 {
	if x, ok := m.GetProtocol().(*Layer4_ICMPv6); ok {
		return x.ICMPv6
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Layer4) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Layer4_TCP)(nil),
		(*Layer4_UDP)(nil),
		(*Layer4_ICMPv4)(nil),
		(*Layer4_ICMPv6)(nil),
	}
}

// Message for L7 flow, which roughly corresponds to Cilium's accesslog LogRecord:
//   https://github.com/cilium/cilium/blob/728c79e427438ab6f8d9375b62fccd6fed4ace3a/pkg/proxy/accesslog/record.go#L141
type Layer7 struct {
	Type L7FlowType `protobuf:"varint,1,opt,name=type,proto3,enum=flow.L7FlowType" json:"type,omitempty"`
	// Latency of the response
	LatencyNs uint64 `protobuf:"varint,2,opt,name=latency_ns,json=latencyNs,proto3" json:"latency_ns,omitempty"`
	// L7 field. This field is set if and only if FlowType is L7.
	//
	// Types that are valid to be assigned to Record:
	//	*Layer7_Dns
	//	*Layer7_Http
	//	*Layer7_Kafka
	Record               isLayer7_Record `protobuf_oneof:"record"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Layer7) Reset()         { *m = Layer7{} }
func (m *Layer7) String() string { return proto.CompactTextString(m) }
func (*Layer7) ProtoMessage()    {}
func (*Layer7) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{2}
}

func (m *Layer7) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Layer7.Unmarshal(m, b)
}
func (m *Layer7) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Layer7.Marshal(b, m, deterministic)
}
func (m *Layer7) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Layer7.Merge(m, src)
}
func (m *Layer7) XXX_Size() int {
	return xxx_messageInfo_Layer7.Size(m)
}
func (m *Layer7) XXX_DiscardUnknown() {
	xxx_messageInfo_Layer7.DiscardUnknown(m)
}

var xxx_messageInfo_Layer7 proto.InternalMessageInfo

func (m *Layer7) GetType() L7FlowType {
	if m != nil {
		return m.Type
	}
	return L7FlowType_UNKNOWN_L7_TYPE
}

func (m *Layer7) GetLatencyNs() uint64 {
	if m != nil {
		return m.LatencyNs
	}
	return 0
}

type isLayer7_Record interface {
	isLayer7_Record()
}

type Layer7_Dns struct {
	Dns *DNS `protobuf:"bytes,100,opt,name=dns,proto3,oneof"`
}

type Layer7_Http struct {
	Http *HTTP `protobuf:"bytes,101,opt,name=http,proto3,oneof"`
}

type Layer7_Kafka struct {
	Kafka *Kafka `protobuf:"bytes,102,opt,name=kafka,proto3,oneof"`
}

func (*Layer7_Dns) isLayer7_Record() {}

func (*Layer7_Http) isLayer7_Record() {}

func (*Layer7_Kafka) isLayer7_Record() {}

func (m *Layer7) GetRecord() isLayer7_Record {
	if m != nil {
		return m.Record
	}
	return nil
}

func (m *Layer7) GetDns() *DNS {
	if x, ok := m.GetRecord().(*Layer7_Dns); ok {
		return x.Dns
	}
	return nil
}

func (m *Layer7) GetHttp() *HTTP {
	if x, ok := m.GetRecord().(*Layer7_Http); ok {
		return x.Http
	}
	return nil
}

func (m *Layer7) GetKafka() *Kafka {
	if x, ok := m.GetRecord().(*Layer7_Kafka); ok {
		return x.Kafka
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Layer7) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Layer7_Dns)(nil),
		(*Layer7_Http)(nil),
		(*Layer7_Kafka)(nil),
	}
}

type Endpoint struct {
	ID        uint64 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Identity  uint64 `protobuf:"varint,2,opt,name=identity,proto3" json:"identity,omitempty"`
	Namespace string `protobuf:"bytes,3,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// labels in `foo=bar` format.
	Labels               []string `protobuf:"bytes,4,rep,name=labels,proto3" json:"labels,omitempty"`
	PodName              string   `protobuf:"bytes,5,opt,name=pod_name,json=podName,proto3" json:"pod_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Endpoint) Reset()         { *m = Endpoint{} }
func (m *Endpoint) String() string { return proto.CompactTextString(m) }
func (*Endpoint) ProtoMessage()    {}
func (*Endpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{3}
}

func (m *Endpoint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Endpoint.Unmarshal(m, b)
}
func (m *Endpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Endpoint.Marshal(b, m, deterministic)
}
func (m *Endpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Endpoint.Merge(m, src)
}
func (m *Endpoint) XXX_Size() int {
	return xxx_messageInfo_Endpoint.Size(m)
}
func (m *Endpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_Endpoint.DiscardUnknown(m)
}

var xxx_messageInfo_Endpoint proto.InternalMessageInfo

func (m *Endpoint) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Endpoint) GetIdentity() uint64 {
	if m != nil {
		return m.Identity
	}
	return 0
}

func (m *Endpoint) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Endpoint) GetLabels() []string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Endpoint) GetPodName() string {
	if m != nil {
		return m.PodName
	}
	return ""
}

type TCP struct {
	SourcePort           uint32    `protobuf:"varint,1,opt,name=source_port,json=sourcePort,proto3" json:"source_port,omitempty"`
	DestinationPort      uint32    `protobuf:"varint,2,opt,name=destination_port,json=destinationPort,proto3" json:"destination_port,omitempty"`
	Flags                *TCPFlags `protobuf:"bytes,3,opt,name=flags,proto3" json:"flags,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *TCP) Reset()         { *m = TCP{} }
func (m *TCP) String() string { return proto.CompactTextString(m) }
func (*TCP) ProtoMessage()    {}
func (*TCP) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{4}
}

func (m *TCP) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TCP.Unmarshal(m, b)
}
func (m *TCP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TCP.Marshal(b, m, deterministic)
}
func (m *TCP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TCP.Merge(m, src)
}
func (m *TCP) XXX_Size() int {
	return xxx_messageInfo_TCP.Size(m)
}
func (m *TCP) XXX_DiscardUnknown() {
	xxx_messageInfo_TCP.DiscardUnknown(m)
}

var xxx_messageInfo_TCP proto.InternalMessageInfo

func (m *TCP) GetSourcePort() uint32 {
	if m != nil {
		return m.SourcePort
	}
	return 0
}

func (m *TCP) GetDestinationPort() uint32 {
	if m != nil {
		return m.DestinationPort
	}
	return 0
}

func (m *TCP) GetFlags() *TCPFlags {
	if m != nil {
		return m.Flags
	}
	return nil
}

type IP struct {
	Source      string    `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Destination string    `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
	IpVersion   IPVersion `protobuf:"varint,3,opt,name=ipVersion,proto3,enum=flow.IPVersion" json:"ipVersion,omitempty"`
	// This field indicates whether the TraceReasonEncryptMask is set or not.
	// https://github.com/cilium/cilium/blob/ba0ed147bd5bb342f67b1794c2ad13c6e99d5236/pkg/monitor/datapath_trace.go#L27
	Encrypted            bool     `protobuf:"varint,4,opt,name=encrypted,proto3" json:"encrypted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IP) Reset()         { *m = IP{} }
func (m *IP) String() string { return proto.CompactTextString(m) }
func (*IP) ProtoMessage()    {}
func (*IP) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{5}
}

func (m *IP) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IP.Unmarshal(m, b)
}
func (m *IP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IP.Marshal(b, m, deterministic)
}
func (m *IP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IP.Merge(m, src)
}
func (m *IP) XXX_Size() int {
	return xxx_messageInfo_IP.Size(m)
}
func (m *IP) XXX_DiscardUnknown() {
	xxx_messageInfo_IP.DiscardUnknown(m)
}

var xxx_messageInfo_IP proto.InternalMessageInfo

func (m *IP) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *IP) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *IP) GetIpVersion() IPVersion {
	if m != nil {
		return m.IpVersion
	}
	return IPVersion_IP_NOT_USED
}

func (m *IP) GetEncrypted() bool {
	if m != nil {
		return m.Encrypted
	}
	return false
}

type Ethernet struct {
	Source               string   `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Destination          string   `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Ethernet) Reset()         { *m = Ethernet{} }
func (m *Ethernet) String() string { return proto.CompactTextString(m) }
func (*Ethernet) ProtoMessage()    {}
func (*Ethernet) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{6}
}

func (m *Ethernet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Ethernet.Unmarshal(m, b)
}
func (m *Ethernet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Ethernet.Marshal(b, m, deterministic)
}
func (m *Ethernet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ethernet.Merge(m, src)
}
func (m *Ethernet) XXX_Size() int {
	return xxx_messageInfo_Ethernet.Size(m)
}
func (m *Ethernet) XXX_DiscardUnknown() {
	xxx_messageInfo_Ethernet.DiscardUnknown(m)
}

var xxx_messageInfo_Ethernet proto.InternalMessageInfo

func (m *Ethernet) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *Ethernet) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

type TCPFlags struct {
	FIN                  bool     `protobuf:"varint,1,opt,name=FIN,proto3" json:"FIN,omitempty"`
	SYN                  bool     `protobuf:"varint,2,opt,name=SYN,proto3" json:"SYN,omitempty"`
	RST                  bool     `protobuf:"varint,3,opt,name=RST,proto3" json:"RST,omitempty"`
	PSH                  bool     `protobuf:"varint,4,opt,name=PSH,proto3" json:"PSH,omitempty"`
	ACK                  bool     `protobuf:"varint,5,opt,name=ACK,proto3" json:"ACK,omitempty"`
	URG                  bool     `protobuf:"varint,6,opt,name=URG,proto3" json:"URG,omitempty"`
	ECE                  bool     `protobuf:"varint,7,opt,name=ECE,proto3" json:"ECE,omitempty"`
	CWR                  bool     `protobuf:"varint,8,opt,name=CWR,proto3" json:"CWR,omitempty"`
	NS                   bool     `protobuf:"varint,9,opt,name=NS,proto3" json:"NS,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TCPFlags) Reset()         { *m = TCPFlags{} }
func (m *TCPFlags) String() string { return proto.CompactTextString(m) }
func (*TCPFlags) ProtoMessage()    {}
func (*TCPFlags) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{7}
}

func (m *TCPFlags) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TCPFlags.Unmarshal(m, b)
}
func (m *TCPFlags) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TCPFlags.Marshal(b, m, deterministic)
}
func (m *TCPFlags) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TCPFlags.Merge(m, src)
}
func (m *TCPFlags) XXX_Size() int {
	return xxx_messageInfo_TCPFlags.Size(m)
}
func (m *TCPFlags) XXX_DiscardUnknown() {
	xxx_messageInfo_TCPFlags.DiscardUnknown(m)
}

var xxx_messageInfo_TCPFlags proto.InternalMessageInfo

func (m *TCPFlags) GetFIN() bool {
	if m != nil {
		return m.FIN
	}
	return false
}

func (m *TCPFlags) GetSYN() bool {
	if m != nil {
		return m.SYN
	}
	return false
}

func (m *TCPFlags) GetRST() bool {
	if m != nil {
		return m.RST
	}
	return false
}

func (m *TCPFlags) GetPSH() bool {
	if m != nil {
		return m.PSH
	}
	return false
}

func (m *TCPFlags) GetACK() bool {
	if m != nil {
		return m.ACK
	}
	return false
}

func (m *TCPFlags) GetURG() bool {
	if m != nil {
		return m.URG
	}
	return false
}

func (m *TCPFlags) GetECE() bool {
	if m != nil {
		return m.ECE
	}
	return false
}

func (m *TCPFlags) GetCWR() bool {
	if m != nil {
		return m.CWR
	}
	return false
}

func (m *TCPFlags) GetNS() bool {
	if m != nil {
		return m.NS
	}
	return false
}

type UDP struct {
	SourcePort           uint32   `protobuf:"varint,1,opt,name=source_port,json=sourcePort,proto3" json:"source_port,omitempty"`
	DestinationPort      uint32   `protobuf:"varint,2,opt,name=destination_port,json=destinationPort,proto3" json:"destination_port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UDP) Reset()         { *m = UDP{} }
func (m *UDP) String() string { return proto.CompactTextString(m) }
func (*UDP) ProtoMessage()    {}
func (*UDP) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{8}
}

func (m *UDP) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UDP.Unmarshal(m, b)
}
func (m *UDP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UDP.Marshal(b, m, deterministic)
}
func (m *UDP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UDP.Merge(m, src)
}
func (m *UDP) XXX_Size() int {
	return xxx_messageInfo_UDP.Size(m)
}
func (m *UDP) XXX_DiscardUnknown() {
	xxx_messageInfo_UDP.DiscardUnknown(m)
}

var xxx_messageInfo_UDP proto.InternalMessageInfo

func (m *UDP) GetSourcePort() uint32 {
	if m != nil {
		return m.SourcePort
	}
	return 0
}

func (m *UDP) GetDestinationPort() uint32 {
	if m != nil {
		return m.DestinationPort
	}
	return 0
}

type ICMPv4 struct {
	Type                 uint32   `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Code                 uint32   `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ICMPv4) Reset()         { *m = ICMPv4{} }
func (m *ICMPv4) String() string { return proto.CompactTextString(m) }
func (*ICMPv4) ProtoMessage()    {}
func (*ICMPv4) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{9}
}

func (m *ICMPv4) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ICMPv4.Unmarshal(m, b)
}
func (m *ICMPv4) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ICMPv4.Marshal(b, m, deterministic)
}
func (m *ICMPv4) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPv4.Merge(m, src)
}
func (m *ICMPv4) XXX_Size() int {
	return xxx_messageInfo_ICMPv4.Size(m)
}
func (m *ICMPv4) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPv4.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPv4 proto.InternalMessageInfo

func (m *ICMPv4) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ICMPv4) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

type ICMPv6 struct {
	Type                 uint32   `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Code                 uint32   `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ICMPv6) Reset()         { *m = ICMPv6{} }
func (m *ICMPv6) String() string { return proto.CompactTextString(m) }
func (*ICMPv6) ProtoMessage()    {}
func (*ICMPv6) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{10}
}

func (m *ICMPv6) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ICMPv6.Unmarshal(m, b)
}
func (m *ICMPv6) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ICMPv6.Marshal(b, m, deterministic)
}
func (m *ICMPv6) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ICMPv6.Merge(m, src)
}
func (m *ICMPv6) XXX_Size() int {
	return xxx_messageInfo_ICMPv6.Size(m)
}
func (m *ICMPv6) XXX_DiscardUnknown() {
	xxx_messageInfo_ICMPv6.DiscardUnknown(m)
}

var xxx_messageInfo_ICMPv6 proto.InternalMessageInfo

func (m *ICMPv6) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ICMPv6) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

// EventTypeFilter is a filter describing a particular event type
type EventTypeFilter struct {
	// type is the primary flow type as defined by:
	// github.com/cilium/cilium/pkg/monitor/api.MessageType*
	Type int32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	// match_sub_type is set to true when matching on the sub_type should
	// be done. This flag is required as 0 is a valid sub_type.
	MatchSubType bool `protobuf:"varint,2,opt,name=match_sub_type,json=matchSubType,proto3" json:"match_sub_type,omitempty"`
	// sub_type is the secondary type, e.g.
	// - github.com/cilium/cilium/pkg/monitor/api.Trace*
	SubType              int32    `protobuf:"varint,3,opt,name=sub_type,json=subType,proto3" json:"sub_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EventTypeFilter) Reset()         { *m = EventTypeFilter{} }
func (m *EventTypeFilter) String() string { return proto.CompactTextString(m) }
func (*EventTypeFilter) ProtoMessage()    {}
func (*EventTypeFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{11}
}

func (m *EventTypeFilter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EventTypeFilter.Unmarshal(m, b)
}
func (m *EventTypeFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EventTypeFilter.Marshal(b, m, deterministic)
}
func (m *EventTypeFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTypeFilter.Merge(m, src)
}
func (m *EventTypeFilter) XXX_Size() int {
	return xxx_messageInfo_EventTypeFilter.Size(m)
}
func (m *EventTypeFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTypeFilter.DiscardUnknown(m)
}

var xxx_messageInfo_EventTypeFilter proto.InternalMessageInfo

func (m *EventTypeFilter) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *EventTypeFilter) GetMatchSubType() bool {
	if m != nil {
		return m.MatchSubType
	}
	return false
}

func (m *EventTypeFilter) GetSubType() int32 {
	if m != nil {
		return m.SubType
	}
	return 0
}

// CiliumEventType from which the flow originated
type CiliumEventType struct {
	// type of event the flow originated from, i.e.
	// github.com/cilium/cilium/pkg/monitor/api.MessageType*
	Type int32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	// sub_type may indicate more details depending on type, e.g.
	// - github.com/cilium/cilium/pkg/monitor/api.Trace*
	// - github.com/cilium/cilium/pkg/monitor/api.Drop*
	SubType              int32    `protobuf:"varint,2,opt,name=sub_type,json=subType,proto3" json:"sub_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CiliumEventType) Reset()         { *m = CiliumEventType{} }
func (m *CiliumEventType) String() string { return proto.CompactTextString(m) }
func (*CiliumEventType) ProtoMessage()    {}
func (*CiliumEventType) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{12}
}

func (m *CiliumEventType) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CiliumEventType.Unmarshal(m, b)
}
func (m *CiliumEventType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CiliumEventType.Marshal(b, m, deterministic)
}
func (m *CiliumEventType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CiliumEventType.Merge(m, src)
}
func (m *CiliumEventType) XXX_Size() int {
	return xxx_messageInfo_CiliumEventType.Size(m)
}
func (m *CiliumEventType) XXX_DiscardUnknown() {
	xxx_messageInfo_CiliumEventType.DiscardUnknown(m)
}

var xxx_messageInfo_CiliumEventType proto.InternalMessageInfo

func (m *CiliumEventType) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *CiliumEventType) GetSubType() int32 {
	if m != nil {
		return m.SubType
	}
	return 0
}

// FlowFilter represent an individual flow filter. All fields are optional. If
// multiple fields are set, then all fields must match for the filter to match.
type FlowFilter struct {
	// source_ip filters by a list of source ips
	SourceIp []string `protobuf:"bytes,1,rep,name=source_ip,json=sourceIp,proto3" json:"source_ip,omitempty"`
	// source_pod filters by a list of source pod name prefixes, optionally
	// within a given namespace (e.g. "xwing", "kube-system/coredns-").
	// The pod name can be emitted to only filter by namespace
	// (e.g. "kube-system/")
	SourcePod []string `protobuf:"bytes,2,rep,name=source_pod,json=sourcePod,proto3" json:"source_pod,omitempty"`
	// source_fqdn filters by a list of source fully qualified domain names
	SourceFqdn []string `protobuf:"bytes,7,rep,name=source_fqdn,json=sourceFqdn,proto3" json:"source_fqdn,omitempty"`
	// source_labels filters on a list of source label selectors. Selectors
	// support the full Kubernetes label selector syntax.
	SourceLabel []string `protobuf:"bytes,10,rep,name=source_label,json=sourceLabel,proto3" json:"source_label,omitempty"`
	// source_service filters on a list of source service names. This field
	// supports the same syntax as the source_pod field.
	SourceService []string `protobuf:"bytes,16,rep,name=source_service,json=sourceService,proto3" json:"source_service,omitempty"`
	// destination_ip filters by a list of destination ips
	DestinationIp []string `protobuf:"bytes,3,rep,name=destination_ip,json=destinationIp,proto3" json:"destination_ip,omitempty"`
	// destination_pod filters by a list of destination pod names
	DestinationPod []string `protobuf:"bytes,4,rep,name=destination_pod,json=destinationPod,proto3" json:"destination_pod,omitempty"`
	// destination_fqdn filters by a list of destination fully qualified domain names
	DestinationFqdn []string `protobuf:"bytes,8,rep,name=destination_fqdn,json=destinationFqdn,proto3" json:"destination_fqdn,omitempty"`
	// destination_label filters on a list of destination label selectors
	DestinationLabel []string `protobuf:"bytes,11,rep,name=destination_label,json=destinationLabel,proto3" json:"destination_label,omitempty"`
	// destination_service filters on a list of destination service names
	DestinationService []string `protobuf:"bytes,17,rep,name=destination_service,json=destinationService,proto3" json:"destination_service,omitempty"`
	// only return Flows that were classified with a particular verdict.
	Verdict []Verdict `protobuf:"varint,5,rep,packed,name=verdict,proto3,enum=flow.Verdict" json:"verdict,omitempty"`
	// event_type is the list of event types to filter on
	EventType []*EventTypeFilter `protobuf:"bytes,6,rep,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	// http_status_code is a list of string prefixes (e.g. "4+", "404", "5+")
	// to filter on the HTTP status code
	HttpStatusCode []string `protobuf:"bytes,9,rep,name=http_status_code,json=httpStatusCode,proto3" json:"http_status_code,omitempty"`
	// protocol filters flows by L4 or L7 protocol, e.g. (e.g. "tcp", "http")
	Protocol []string `protobuf:"bytes,12,rep,name=protocol,proto3" json:"protocol,omitempty"`
	// source_port filters flows by L4 source port
	SourcePort []string `protobuf:"bytes,13,rep,name=source_port,json=sourcePort,proto3" json:"source_port,omitempty"`
	// destination_port filters flows by L4 destination port
	DestinationPort []string `protobuf:"bytes,14,rep,name=destination_port,json=destinationPort,proto3" json:"destination_port,omitempty"`
	// reply filters flows based on the direction of the flow.
	Reply []bool `protobuf:"varint,15,rep,packed,name=reply,proto3" json:"reply,omitempty"`
	// dns_query filters L7 DNS flows by query patterns (RE2 regex), e.g. 'kube.*local'.
	DnsQuery             []string `protobuf:"bytes,18,rep,name=dns_query,json=dnsQuery,proto3" json:"dns_query,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FlowFilter) Reset()         { *m = FlowFilter{} }
func (m *FlowFilter) String() string { return proto.CompactTextString(m) }
func (*FlowFilter) ProtoMessage()    {}
func (*FlowFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{13}
}

func (m *FlowFilter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FlowFilter.Unmarshal(m, b)
}
func (m *FlowFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FlowFilter.Marshal(b, m, deterministic)
}
func (m *FlowFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowFilter.Merge(m, src)
}
func (m *FlowFilter) XXX_Size() int {
	return xxx_messageInfo_FlowFilter.Size(m)
}
func (m *FlowFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowFilter.DiscardUnknown(m)
}

var xxx_messageInfo_FlowFilter proto.InternalMessageInfo

func (m *FlowFilter) GetSourceIp() []string {
	if m != nil {
		return m.SourceIp
	}
	return nil
}

func (m *FlowFilter) GetSourcePod() []string {
	if m != nil {
		return m.SourcePod
	}
	return nil
}

func (m *FlowFilter) GetSourceFqdn() []string {
	if m != nil {
		return m.SourceFqdn
	}
	return nil
}

func (m *FlowFilter) GetSourceLabel() []string {
	if m != nil {
		return m.SourceLabel
	}
	return nil
}

func (m *FlowFilter) GetSourceService() []string {
	if m != nil {
		return m.SourceService
	}
	return nil
}

func (m *FlowFilter) GetDestinationIp() []string {
	if m != nil {
		return m.DestinationIp
	}
	return nil
}

func (m *FlowFilter) GetDestinationPod() []string {
	if m != nil {
		return m.DestinationPod
	}
	return nil
}

func (m *FlowFilter) GetDestinationFqdn() []string {
	if m != nil {
		return m.DestinationFqdn
	}
	return nil
}

func (m *FlowFilter) GetDestinationLabel() []string {
	if m != nil {
		return m.DestinationLabel
	}
	return nil
}

func (m *FlowFilter) GetDestinationService() []string {
	if m != nil {
		return m.DestinationService
	}
	return nil
}

func (m *FlowFilter) GetVerdict() []Verdict {
	if m != nil {
		return m.Verdict
	}
	return nil
}

func (m *FlowFilter) GetEventType() []*EventTypeFilter {
	if m != nil {
		return m.EventType
	}
	return nil
}

func (m *FlowFilter) GetHttpStatusCode() []string {
	if m != nil {
		return m.HttpStatusCode
	}
	return nil
}

func (m *FlowFilter) GetProtocol() []string {
	if m != nil {
		return m.Protocol
	}
	return nil
}

func (m *FlowFilter) GetSourcePort() []string {
	if m != nil {
		return m.SourcePort
	}
	return nil
}

func (m *FlowFilter) GetDestinationPort() []string {
	if m != nil {
		return m.DestinationPort
	}
	return nil
}

func (m *FlowFilter) GetReply() []bool {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *FlowFilter) GetDnsQuery() []string {
	if m != nil {
		return m.DnsQuery
	}
	return nil
}

// Payload is the payload, i.e. the data the monitor returns.
type Payload struct {
	// type is the event type perf returns.
	Type EventType `protobuf:"varint,1,opt,name=type,proto3,enum=flow.EventType" json:"type,omitempty"`
	// CPU is the CPU id for this event.
	CPU int32 `protobuf:"varint,2,opt,name=CPU,proto3" json:"CPU,omitempty"`
	// lost is the number of events lost for a given CPU.
	Lost uint64 `protobuf:"varint,3,opt,name=lost,proto3" json:"lost,omitempty"`
	// data is the sample data returned by perf.
	Data []byte `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	// time when the event was observed
	Time *types.Timestamp `protobuf:"bytes,5,opt,name=time,proto3" json:"time,omitempty"`
	// the host name from which the payload was captured.
	HostName             string   `protobuf:"bytes,6,opt,name=host_name,json=hostName,proto3" json:"host_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Payload) Reset()         { *m = Payload{} }
func (m *Payload) String() string { return proto.CompactTextString(m) }
func (*Payload) ProtoMessage()    {}
func (*Payload) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{14}
}

func (m *Payload) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Payload.Unmarshal(m, b)
}
func (m *Payload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Payload.Marshal(b, m, deterministic)
}
func (m *Payload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Payload.Merge(m, src)
}
func (m *Payload) XXX_Size() int {
	return xxx_messageInfo_Payload.Size(m)
}
func (m *Payload) XXX_DiscardUnknown() {
	xxx_messageInfo_Payload.DiscardUnknown(m)
}

var xxx_messageInfo_Payload proto.InternalMessageInfo

func (m *Payload) GetType() EventType {
	if m != nil {
		return m.Type
	}
	return EventType_UNKNOWN
}

func (m *Payload) GetCPU() int32 {
	if m != nil {
		return m.CPU
	}
	return 0
}

func (m *Payload) GetLost() uint64 {
	if m != nil {
		return m.Lost
	}
	return 0
}

func (m *Payload) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Payload) GetTime() *types.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *Payload) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

// DNS flow. This is basically directly mapped from Cilium's LogRecordDNS:
//     https://github.com/cilium/cilium/blob/04f3889d627774f79e56d14ddbc165b3169e2d01/pkg/proxy/accesslog/record.go#L264
type DNS struct {
	// DNS name that's being looked up: e.g. "isovalent.com."
	Query string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	// List of IP addresses in the DNS response.
	Ips []string `protobuf:"bytes,2,rep,name=ips,proto3" json:"ips,omitempty"`
	// TTL in the DNS response.
	Ttl uint32 `protobuf:"varint,3,opt,name=ttl,proto3" json:"ttl,omitempty"`
	// List of CNames in the DNS response.
	Cnames []string `protobuf:"bytes,4,rep,name=cnames,proto3" json:"cnames,omitempty"`
	// Corresponds to DNSDataSource defined in:
	//   https://github.com/cilium/cilium/blob/04f3889d627774f79e56d14ddbc165b3169e2d01/pkg/proxy/accesslog/record.go#L253
	ObservationSource string `protobuf:"bytes,5,opt,name=observation_source,json=observationSource,proto3" json:"observation_source,omitempty"`
	// Return code of the DNS request defined in:
	//   https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-6
	Rcode uint32 `protobuf:"varint,6,opt,name=rcode,proto3" json:"rcode,omitempty"`
	// String representation of qtypes defined in:
	//   https://tools.ietf.org/html/rfc1035#section-3.2.3
	Qtypes []string `protobuf:"bytes,7,rep,name=qtypes,proto3" json:"qtypes,omitempty"`
	// String representation of rrtypes defined in:
	// https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4
	Rrtypes              []string `protobuf:"bytes,8,rep,name=rrtypes,proto3" json:"rrtypes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DNS) Reset()         { *m = DNS{} }
func (m *DNS) String() string { return proto.CompactTextString(m) }
func (*DNS) ProtoMessage()    {}
func (*DNS) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{15}
}

func (m *DNS) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DNS.Unmarshal(m, b)
}
func (m *DNS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DNS.Marshal(b, m, deterministic)
}
func (m *DNS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNS.Merge(m, src)
}
func (m *DNS) XXX_Size() int {
	return xxx_messageInfo_DNS.Size(m)
}
func (m *DNS) XXX_DiscardUnknown() {
	xxx_messageInfo_DNS.DiscardUnknown(m)
}

var xxx_messageInfo_DNS proto.InternalMessageInfo

func (m *DNS) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *DNS) GetIps() []string {
	if m != nil {
		return m.Ips
	}
	return nil
}

func (m *DNS) GetTtl() uint32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *DNS) GetCnames() []string {
	if m != nil {
		return m.Cnames
	}
	return nil
}

func (m *DNS) GetObservationSource() string {
	if m != nil {
		return m.ObservationSource
	}
	return ""
}

func (m *DNS) GetRcode() uint32 {
	if m != nil {
		return m.Rcode
	}
	return 0
}

func (m *DNS) GetQtypes() []string {
	if m != nil {
		return m.Qtypes
	}
	return nil
}

func (m *DNS) GetRrtypes() []string {
	if m != nil {
		return m.Rrtypes
	}
	return nil
}

type HTTPHeader struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HTTPHeader) Reset()         { *m = HTTPHeader{} }
func (m *HTTPHeader) String() string { return proto.CompactTextString(m) }
func (*HTTPHeader) ProtoMessage()    {}
func (*HTTPHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{16}
}

func (m *HTTPHeader) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HTTPHeader.Unmarshal(m, b)
}
func (m *HTTPHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HTTPHeader.Marshal(b, m, deterministic)
}
func (m *HTTPHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTPHeader.Merge(m, src)
}
func (m *HTTPHeader) XXX_Size() int {
	return xxx_messageInfo_HTTPHeader.Size(m)
}
func (m *HTTPHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTPHeader.DiscardUnknown(m)
}

var xxx_messageInfo_HTTPHeader proto.InternalMessageInfo

func (m *HTTPHeader) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *HTTPHeader) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// L7 information for HTTP flows. It corresponds to Cilium's accesslog.LogRecordHTTP type.
//   https://github.com/cilium/cilium/blob/728c79e427438ab6f8d9375b62fccd6fed4ace3a/pkg/proxy/accesslog/record.go#L206
type HTTP struct {
	Code                 uint32        `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Method               string        `protobuf:"bytes,2,opt,name=method,proto3" json:"method,omitempty"`
	Url                  string        `protobuf:"bytes,3,opt,name=url,proto3" json:"url,omitempty"`
	Protocol             string        `protobuf:"bytes,4,opt,name=protocol,proto3" json:"protocol,omitempty"`
	Headers              []*HTTPHeader `protobuf:"bytes,5,rep,name=headers,proto3" json:"headers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *HTTP) Reset()         { *m = HTTP{} }
func (m *HTTP) String() string { return proto.CompactTextString(m) }
func (*HTTP) ProtoMessage()    {}
func (*HTTP) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{17}
}

func (m *HTTP) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HTTP.Unmarshal(m, b)
}
func (m *HTTP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HTTP.Marshal(b, m, deterministic)
}
func (m *HTTP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTP.Merge(m, src)
}
func (m *HTTP) XXX_Size() int {
	return xxx_messageInfo_HTTP.Size(m)
}
func (m *HTTP) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTP.DiscardUnknown(m)
}

var xxx_messageInfo_HTTP proto.InternalMessageInfo

func (m *HTTP) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *HTTP) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *HTTP) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *HTTP) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *HTTP) GetHeaders() []*HTTPHeader {
	if m != nil {
		return m.Headers
	}
	return nil
}

// L7 information for Kafka flows. It corresponds to Cilium's accesslog.LogRecordKafka type.
//   https://github.com/cilium/cilium/blob/728c79e427438ab6f8d9375b62fccd6fed4ace3a/pkg/proxy/accesslog/record.go#L229
type Kafka struct {
	ErrorCode            int32    `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	ApiVersion           int32    `protobuf:"varint,2,opt,name=api_version,json=apiVersion,proto3" json:"api_version,omitempty"`
	ApiKey               string   `protobuf:"bytes,3,opt,name=api_key,json=apiKey,proto3" json:"api_key,omitempty"`
	CorrelationId        int32    `protobuf:"varint,4,opt,name=correlation_id,json=correlationId,proto3" json:"correlation_id,omitempty"`
	Topic                string   `protobuf:"bytes,5,opt,name=topic,proto3" json:"topic,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Kafka) Reset()         { *m = Kafka{} }
func (m *Kafka) String() string { return proto.CompactTextString(m) }
func (*Kafka) ProtoMessage()    {}
func (*Kafka) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{18}
}

func (m *Kafka) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Kafka.Unmarshal(m, b)
}
func (m *Kafka) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Kafka.Marshal(b, m, deterministic)
}
func (m *Kafka) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Kafka.Merge(m, src)
}
func (m *Kafka) XXX_Size() int {
	return xxx_messageInfo_Kafka.Size(m)
}
func (m *Kafka) XXX_DiscardUnknown() {
	xxx_messageInfo_Kafka.DiscardUnknown(m)
}

var xxx_messageInfo_Kafka proto.InternalMessageInfo

func (m *Kafka) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *Kafka) GetApiVersion() int32 {
	if m != nil {
		return m.ApiVersion
	}
	return 0
}

func (m *Kafka) GetApiKey() string {
	if m != nil {
		return m.ApiKey
	}
	return ""
}

func (m *Kafka) GetCorrelationId() int32 {
	if m != nil {
		return m.CorrelationId
	}
	return 0
}

func (m *Kafka) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

type Service struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Namespace            string   `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Service) Reset()         { *m = Service{} }
func (m *Service) String() string { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()    {}
func (*Service) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c1fa740027c1208, []int{19}
}

func (m *Service) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Service.Unmarshal(m, b)
}
func (m *Service) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Service.Marshal(b, m, deterministic)
}
func (m *Service) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Service.Merge(m, src)
}
func (m *Service) XXX_Size() int {
	return xxx_messageInfo_Service.Size(m)
}
func (m *Service) XXX_DiscardUnknown() {
	xxx_messageInfo_Service.DiscardUnknown(m)
}

var xxx_messageInfo_Service proto.InternalMessageInfo

func (m *Service) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Service) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func init() {
	proto.RegisterEnum("flow.FlowType", FlowType_name, FlowType_value)
	proto.RegisterEnum("flow.L7FlowType", L7FlowType_name, L7FlowType_value)
	proto.RegisterEnum("flow.IPVersion", IPVersion_name, IPVersion_value)
	proto.RegisterEnum("flow.Verdict", Verdict_name, Verdict_value)
	proto.RegisterEnum("flow.EventType", EventType_name, EventType_value)
	proto.RegisterType((*Flow)(nil), "flow.Flow")
	proto.RegisterType((*Layer4)(nil), "flow.Layer4")
	proto.RegisterType((*Layer7)(nil), "flow.Layer7")
	proto.RegisterType((*Endpoint)(nil), "flow.Endpoint")
	proto.RegisterType((*TCP)(nil), "flow.TCP")
	proto.RegisterType((*IP)(nil), "flow.IP")
	proto.RegisterType((*Ethernet)(nil), "flow.Ethernet")
	proto.RegisterType((*TCPFlags)(nil), "flow.TCPFlags")
	proto.RegisterType((*UDP)(nil), "flow.UDP")
	proto.RegisterType((*ICMPv4)(nil), "flow.ICMPv4")
	proto.RegisterType((*ICMPv6)(nil), "flow.ICMPv6")
	proto.RegisterType((*EventTypeFilter)(nil), "flow.EventTypeFilter")
	proto.RegisterType((*CiliumEventType)(nil), "flow.CiliumEventType")
	proto.RegisterType((*FlowFilter)(nil), "flow.FlowFilter")
	proto.RegisterType((*Payload)(nil), "flow.Payload")
	proto.RegisterType((*DNS)(nil), "flow.DNS")
	proto.RegisterType((*HTTPHeader)(nil), "flow.HTTPHeader")
	proto.RegisterType((*HTTP)(nil), "flow.HTTP")
	proto.RegisterType((*Kafka)(nil), "flow.Kafka")
	proto.RegisterType((*Service)(nil), "flow.Service")
}

func init() { proto.RegisterFile("flow/flow.proto", fileDescriptor_3c1fa740027c1208) }

var fileDescriptor_3c1fa740027c1208 = []byte{
	// 1749 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x5f, 0x6f, 0xdb, 0xc8,
	0x11, 0x37, 0xa9, 0x7f, 0xe4, 0xc8, 0x96, 0x98, 0xcd, 0x5d, 0xcb, 0x4b, 0xee, 0x1a, 0x55, 0x97,
	0xeb, 0xb9, 0x2e, 0xce, 0x0e, 0x72, 0x86, 0x8d, 0xb6, 0x40, 0xd1, 0x44, 0x92, 0x6b, 0x21, 0x3e,
	0x99, 0x59, 0xca, 0x09, 0xee, 0x49, 0xa0, 0xc5, 0x75, 0x4c, 0x84, 0x22, 0x19, 0x92, 0x72, 0xa0,
	0x4f, 0xd0, 0x87, 0xb6, 0x1f, 0xa1, 0x40, 0xd1, 0xc7, 0x3e, 0xf5, 0xa5, 0x8f, 0xfd, 0x0a, 0xed,
	0x57, 0x2a, 0x66, 0x76, 0x49, 0x51, 0x8e, 0x5b, 0x04, 0xc5, 0xbd, 0x10, 0xb3, 0xbf, 0x99, 0xe1,
	0xce, 0xce, 0x7f, 0xe8, 0x5e, 0x85, 0xf1, 0xfb, 0x03, 0xfc, 0xec, 0x27, 0x69, 0x9c, 0xc7, 0xac,
	0x8e, 0xf4, 0x83, 0x47, 0x6f, 0xe2, 0xf8, 0x4d, 0x28, 0x0e, 0x08, 0xbb, 0x5c, 0x5e, 0x1d, 0xe4,
	0xc1, 0x42, 0x64, 0xb9, 0xb7, 0x48, 0xa4, 0x58, 0xff, 0xdf, 0x0d, 0xa8, 0x9f, 0x84, 0xf1, 0x7b,
	0xb6, 0x0f, 0x75, 0xe4, 0xd9, 0x5a, 0x4f, 0xdb, 0x6d, 0x3f, 0x7d, 0xb0, 0x2f, 0x15, 0xf7, 0x0b,
	0xc5, 0xfd, 0x69, 0xa1, 0xc8, 0x49, 0x8e, 0x7d, 0x0d, 0xad, 0x1b, 0x91, 0xfa, 0xc1, 0x3c, 0xb7,
	0xf5, 0x9e, 0xb6, 0xdb, 0x79, 0xba, 0xb3, 0x4f, 0xb7, 0xbf, 0x92, 0x20, 0x2f, 0xb8, 0xec, 0x11,
	0xb4, 0xfd, 0x34, 0x4e, 0x66, 0xa9, 0xf0, 0xb2, 0x38, 0xb2, 0x6b, 0x3d, 0x6d, 0x77, 0x87, 0x03,
	0x42, 0x9c, 0x10, 0xb6, 0x07, 0x86, 0xc8, 0xaf, 0x45, 0x1a, 0x89, 0xdc, 0xae, 0xd3, 0xed, 0x1d,
	0xf9, 0xab, 0x91, 0x42, 0x79, 0xc9, 0x67, 0x36, 0xe8, 0x63, 0xc7, 0x6e, 0x90, 0x94, 0x21, 0xa5,
	0xc6, 0x0e, 0xd7, 0xc7, 0x0e, 0xfb, 0x1c, 0xf4, 0xf0, 0xd0, 0x6e, 0x12, 0x67, 0x5b, 0x72, 0xce,
	0xbc, 0x95, 0x48, 0x0f, 0xb9, 0x1e, 0x1e, 0xb2, 0x9f, 0x41, 0x33, 0x8b, 0x97, 0xe9, 0x5c, 0xd8,
	0xc6, 0xc6, 0x0d, 0x91, 0x9f, 0xc4, 0x41, 0x94, 0x73, 0xc5, 0x65, 0x4f, 0xa0, 0xed, 0x8b, 0x2c,
	0x0f, 0x22, 0x2f, 0x0f, 0xe2, 0xc8, 0x36, 0xef, 0x14, 0xae, 0x8a, 0xb0, 0x3e, 0xd4, 0xa7, 0xab,
	0x44, 0xd8, 0x40, 0x4e, 0x50, 0xa2, 0xe8, 0x51, 0x44, 0x39, 0xf1, 0xd8, 0x43, 0x30, 0xa3, 0xd8,
	0x17, 0xb3, 0xc8, 0x5b, 0x08, 0xbb, 0xdd, 0xd3, 0x76, 0x4d, 0x6e, 0x20, 0x30, 0xf1, 0x16, 0x82,
	0xfd, 0x14, 0xb6, 0xe5, 0xe5, 0xc4, 0xce, 0xec, 0x9d, 0x5e, 0x6d, 0xd7, 0xe4, 0x6d, 0x89, 0xa1,
	0x44, 0xc6, 0x7e, 0x01, 0xf7, 0x2a, 0x57, 0x2a, 0xb9, 0x0e, 0xc9, 0x59, 0x15, 0x86, 0x14, 0x46,
	0x47, 0x1c, 0xdb, 0xdd, 0x0f, 0x1c, 0x71, 0xcc, 0xf5, 0xf0, 0x98, 0x7d, 0x02, 0x8d, 0x54, 0x24,
	0xe1, 0xca, 0xb6, 0x7a, 0xda, 0xae, 0xc1, 0xe5, 0x81, 0x1d, 0x02, 0x88, 0x1b, 0x11, 0xe5, 0xb3,
	0x1c, 0x9f, 0x72, 0x9f, 0x74, 0x3f, 0x95, 0xba, 0x83, 0x20, 0x0c, 0x96, 0x8b, 0x11, 0x72, 0xe9,
	0x45, 0xa6, 0x28, 0x48, 0x76, 0x08, 0x1d, 0x65, 0x79, 0x26, 0xd2, 0x9b, 0x60, 0x2e, 0xec, 0x4f,
	0x48, 0x53, 0x65, 0x82, 0x2b, 0x41, 0xbe, 0x23, 0x85, 0xd4, 0x91, 0xfd, 0x06, 0xee, 0x57, 0x1f,
	0x53, 0xa8, 0x7e, 0x7a, 0x97, 0x2a, 0xab, 0x48, 0x16, 0xfa, 0x3f, 0x81, 0x96, 0xbb, 0x5c, 0x2c,
	0xbc, 0x74, 0x65, 0xff, 0xe5, 0x4f, 0x18, 0x6f, 0xf3, 0xb9, 0x6e, 0x6b, 0xbc, 0x00, 0xfb, 0x7f,
	0xd5, 0xa0, 0x29, 0x23, 0xcf, 0xbe, 0x80, 0xda, 0x74, 0xe0, 0xa8, 0x94, 0x36, 0xe5, 0xaf, 0xa7,
	0x03, 0xe7, 0x74, 0x8b, 0x23, 0x8e, 0xec, 0x8b, 0xa1, 0x43, 0xe9, 0x5b, 0xb2, 0x2f, 0x86, 0xc4,
	0xbe, 0x18, 0x3a, 0x98, 0x33, 0xe3, 0xc1, 0x77, 0xce, 0xcd, 0x21, 0xe5, 0x6c, 0xe9, 0x4c, 0x89,
	0x9d, 0x6e, 0x71, 0xc5, 0x2d, 0xe5, 0x8e, 0x54, 0xf6, 0x56, 0xe5, 0x8e, 0x4a, 0xb9, 0xa3, 0xe7,
	0x00, 0x06, 0x55, 0xd3, 0x3c, 0x0e, 0xfb, 0xff, 0x2c, 0x8c, 0x3c, 0x66, 0x8f, 0xa1, 0x4e, 0x5e,
	0xd7, 0x28, 0x81, 0x2c, 0x15, 0xb1, 0xe3, 0x75, 0x0a, 0x21, 0x97, 0x7d, 0x01, 0x10, 0x7a, 0xb9,
	0x88, 0xe6, 0xab, 0x59, 0x94, 0x91, 0xc9, 0x75, 0x6e, 0x2a, 0x64, 0x92, 0xe1, 0x53, 0xfc, 0x28,
	0xb3, 0xfd, 0xea, 0x53, 0x86, 0x13, 0x17, 0x9f, 0xe2, 0x47, 0x19, 0xeb, 0x41, 0xfd, 0x3a, 0xcf,
	0x13, 0x5b, 0x10, 0x1f, 0x24, 0xff, 0x74, 0x3a, 0xc5, 0xb7, 0x12, 0x87, 0x7d, 0x09, 0x8d, 0xb7,
	0xde, 0xd5, 0x5b, 0xcf, 0xbe, 0x22, 0x91, 0xb6, 0x14, 0x79, 0x81, 0xd0, 0xe9, 0x16, 0x97, 0xbc,
	0xe7, 0x06, 0x34, 0x53, 0x31, 0x8f, 0x53, 0xbf, 0xff, 0x7b, 0x0d, 0x8c, 0xa2, 0x1e, 0x58, 0x07,
	0xf4, 0xf1, 0x90, 0xec, 0xaf, 0x73, 0x7d, 0x3c, 0x64, 0x0f, 0xc0, 0x08, 0x7c, 0x11, 0xe5, 0x41,
	0xbe, 0x52, 0x96, 0x96, 0x67, 0xf6, 0x39, 0x98, 0x94, 0xbe, 0x89, 0x37, 0x17, 0xe4, 0x57, 0x93,
	0xaf, 0x01, 0xf6, 0x23, 0x68, 0x86, 0xde, 0xa5, 0x08, 0x33, 0xbb, 0x4e, 0xd9, 0xad, 0x4e, 0xec,
	0x33, 0x30, 0x92, 0xd8, 0x97, 0xf5, 0xd3, 0x20, 0xa5, 0x56, 0x12, 0xfb, 0x98, 0xef, 0xfd, 0xf7,
	0x14, 0x63, 0xec, 0x32, 0x2a, 0x17, 0x93, 0x38, 0xcd, 0xc9, 0x98, 0x1d, 0x0e, 0x12, 0x72, 0xe2,
	0x34, 0x67, 0x3f, 0x87, 0x6a, 0xa9, 0x48, 0x29, 0x9d, 0xa4, 0xba, 0x15, 0x9c, 0x44, 0x1f, 0x43,
	0xe3, 0x2a, 0xf4, 0xde, 0x64, 0x2a, 0xee, 0x9d, 0x32, 0x71, 0x4e, 0x10, 0xe5, 0x92, 0xd9, 0xff,
	0x83, 0x86, 0xbd, 0x08, 0x4d, 0x56, 0x9d, 0x45, 0x23, 0xc3, 0x8a, 0x4e, 0xd2, 0xdb, 0xec, 0x24,
	0x3a, 0x31, 0x37, 0x3a, 0xc7, 0x37, 0x60, 0x06, 0xc9, 0x2b, 0x91, 0x66, 0x81, 0x6a, 0x8b, 0x9d,
	0xa7, 0xdd, 0xa2, 0xa5, 0x29, 0x98, 0xaf, 0x25, 0xd0, 0x73, 0x22, 0x9a, 0xa7, 0xab, 0x24, 0x17,
	0x3e, 0x65, 0x9a, 0xc1, 0xd7, 0x40, 0x7f, 0x08, 0x46, 0xd1, 0x2e, 0xff, 0x7f, 0x93, 0xfa, 0x7f,
	0xd3, 0xc0, 0x28, 0xde, 0xc9, 0x2c, 0xa8, 0x9d, 0x8c, 0x27, 0xf4, 0x0f, 0x83, 0x23, 0x89, 0x88,
	0xfb, 0xfd, 0x84, 0x14, 0x0d, 0x8e, 0x24, 0x22, 0xdc, 0x9d, 0x92, 0xf5, 0x06, 0x47, 0x12, 0x11,
	0xc7, 0x3d, 0x55, 0x06, 0x22, 0x89, 0xc8, 0xb3, 0xc1, 0x0b, 0x8a, 0x9b, 0xc1, 0x91, 0x44, 0xe4,
	0x82, 0xff, 0x8e, 0x9a, 0xb5, 0xc1, 0x91, 0x44, 0x64, 0x34, 0x18, 0xd9, 0x2d, 0x89, 0x8c, 0x06,
	0x23, 0x44, 0x06, 0xaf, 0x39, 0xb5, 0x6b, 0x83, 0x23, 0x89, 0x69, 0x36, 0x71, 0xa9, 0x25, 0x1b,
	0x5c, 0x9f, 0xb8, 0xfd, 0x97, 0x54, 0xbe, 0x3f, 0x64, 0xe4, 0xfb, 0x4f, 0x8a, 0x92, 0x67, 0xac,
	0x52, 0x95, 0x3b, 0xaa, 0x06, 0x19, 0xd4, 0xe7, 0xb1, 0x2f, 0x94, 0x32, 0xd1, 0xa5, 0xc6, 0xd1,
	0x47, 0x6b, 0x5c, 0x41, 0xb7, 0xec, 0xa6, 0x27, 0x41, 0x98, 0x8b, 0x74, 0x43, 0xb5, 0xa1, 0x54,
	0x1f, 0x43, 0x67, 0xe1, 0xe5, 0xf3, 0xeb, 0x59, 0xb6, 0xbc, 0x94, 0x6d, 0x59, 0xba, 0x7d, 0x9b,
	0x50, 0x77, 0x79, 0x49, 0x2d, 0xf8, 0x33, 0x30, 0x4a, 0x7e, 0x8d, 0xb4, 0x5b, 0x99, 0x64, 0xf5,
	0x7f, 0x0b, 0xdd, 0x5b, 0xbd, 0xfb, 0xce, 0x7b, 0xaa, 0x7f, 0xd0, 0x37, 0xff, 0xf0, 0xf7, 0x06,
	0x00, 0xb6, 0x21, 0x65, 0xe5, 0x43, 0x30, 0x95, 0xa3, 0x83, 0xc4, 0xd6, 0xa8, 0x3e, 0x0d, 0x09,
	0x8c, 0x13, 0xec, 0x4f, 0x65, 0x14, 0x7c, 0x5b, 0x27, 0xae, 0x59, 0x04, 0xc1, 0xaf, 0x04, 0xe9,
	0xea, 0x9d, 0x1f, 0xd9, 0x2d, 0xe2, 0x2b, 0x8d, 0x93, 0x77, 0x7e, 0x54, 0x99, 0x82, 0x54, 0xf2,
	0x36, 0x54, 0xa7, 0xe0, 0x19, 0x42, 0xec, 0xab, 0x0f, 0xc6, 0x8d, 0x45, 0x42, 0xb7, 0xe6, 0xcb,
	0x57, 0xd0, 0xa9, 0x86, 0x3b, 0x48, 0xec, 0x9a, 0x14, 0xab, 0xa0, 0xe3, 0x84, 0x7d, 0x0d, 0xdd,
	0xcd, 0xac, 0xf0, 0x55, 0xcf, 0xe9, 0x6c, 0x24, 0x85, 0x7f, 0x3b, 0x7d, 0xc8, 0x7e, 0x83, 0x24,
	0xab, 0x3f, 0xa0, 0x47, 0xdc, 0x9a, 0xd3, 0xf2, 0x25, 0xed, 0x0f, 0xe6, 0xb4, 0x7c, 0xce, 0xc1,
	0xdd, 0x73, 0xf0, 0x1e, 0x89, 0xdf, 0x35, 0xf8, 0x2a, 0x1b, 0x57, 0xa3, 0x57, 0xfb, 0x1f, 0x1b,
	0xd7, 0xe6, 0x34, 0x6f, 0xf6, 0x6a, 0xeb, 0x69, 0x7e, 0x2b, 0xf3, 0xaa, 0xd3, 0x7c, 0x17, 0x2c,
	0x9c, 0x04, 0xb3, 0x2c, 0xf7, 0xf2, 0x65, 0x36, 0xa3, 0xbc, 0x35, 0xa5, 0x47, 0x10, 0x77, 0x09,
	0x1e, 0xc4, 0xbe, 0xc0, 0xfe, 0x5e, 0x0c, 0x32, 0x7b, 0x5b, 0xe6, 0x41, 0x71, 0xbe, 0x5d, 0x8d,
	0x3b, 0xd5, 0x40, 0xff, 0xd7, 0x6a, 0xec, 0x7c, 0xe0, 0x4e, 0x12, 0x2d, 0x77, 0x95, 0x6e, 0xaf,
	0xb6, 0xde, 0x55, 0x1e, 0x82, 0xe9, 0x47, 0xd9, 0xec, 0xdd, 0x52, 0xa4, 0x2b, 0x9b, 0xc9, 0xeb,
	0xfd, 0x28, 0x7b, 0x89, 0xe7, 0xfe, 0x3f, 0x34, 0x68, 0x39, 0xde, 0x2a, 0x8c, 0x3d, 0x9f, 0x7d,
	0xb9, 0x31, 0x58, 0xbb, 0xb7, 0x1c, 0xa0, 0xd2, 0x1f, 0xdb, 0x8c, 0x73, 0xa1, 0x32, 0x1f, 0x49,
	0x2c, 0x92, 0x30, 0xce, 0x72, 0x2a, 0xa7, 0x3a, 0x27, 0x1a, 0x31, 0xdf, 0xcb, 0x3d, 0xea, 0x6a,
	0xdb, 0x9c, 0xe8, 0x72, 0x61, 0x6e, 0x7c, 0xe4, 0xc2, 0xfc, 0x10, 0xcc, 0xeb, 0x38, 0xcb, 0xe5,
	0x10, 0x6b, 0xca, 0x25, 0x10, 0x01, 0x9a, 0x62, 0xff, 0xd2, 0xa0, 0x36, 0x9c, 0xb8, 0xf8, 0x64,
	0xf9, 0x30, 0xd9, 0xb9, 0xe5, 0x01, 0x8d, 0x0c, 0x92, 0x4c, 0x55, 0x15, 0x92, 0x88, 0xe4, 0x79,
	0xa8, 0x96, 0x69, 0x24, 0xb1, 0xe9, 0xcf, 0xe5, 0x62, 0xa8, 0x46, 0xa7, 0x3c, 0xb1, 0x6f, 0x80,
	0xc5, 0x97, 0x98, 0x5c, 0x2a, 0xcd, 0xe4, 0x60, 0x90, 0x43, 0xf4, 0x5e, 0x85, 0xe3, 0xca, 0x19,
	0x81, 0x3e, 0xa7, 0xd0, 0x37, 0xe9, 0xd7, 0xf2, 0x80, 0x3f, 0x7f, 0x87, 0xee, 0xca, 0x54, 0xe5,
	0xaa, 0x13, 0xb3, 0xa1, 0x95, 0xa6, 0x92, 0x21, 0x4b, 0xa2, 0x38, 0xf6, 0x0f, 0x01, 0x68, 0xbf,
	0x10, 0x9e, 0x2f, 0x52, 0x34, 0xf7, 0xad, 0x28, 0x1e, 0x85, 0x24, 0xde, 0x73, 0xe3, 0x85, 0x4b,
	0xa1, 0xa6, 0x90, 0x3c, 0xf4, 0xff, 0xa8, 0x41, 0x1d, 0xd5, 0xca, 0xc6, 0xa9, 0xad, 0x1b, 0x27,
	0x1a, 0xb1, 0x10, 0xf9, 0x35, 0xb5, 0x17, 0x1a, 0x6b, 0xf2, 0x84, 0x3f, 0x5f, 0xa6, 0xa1, 0x5a,
	0x26, 0x90, 0xdc, 0x48, 0xd0, 0xba, 0xf4, 0x74, 0x99, 0xa0, 0x7b, 0xd0, 0xba, 0x26, 0xa3, 0x32,
	0xaa, 0xa2, 0x76, 0xb1, 0x71, 0xad, 0xad, 0xe5, 0x85, 0x40, 0xff, 0xcf, 0x1a, 0x34, 0x68, 0x05,
	0xc2, 0xf6, 0x26, 0xd2, 0x34, 0x4e, 0x67, 0xa5, 0x55, 0x0d, 0x6e, 0x12, 0x42, 0x15, 0xf1, 0x08,
	0xda, 0x5e, 0x12, 0xcc, 0x6e, 0xd4, 0x30, 0x97, 0xd9, 0x04, 0x5e, 0x12, 0x14, 0xc3, 0xfb, 0xc7,
	0xd0, 0x42, 0x01, 0x74, 0x82, 0xb4, 0xb3, 0xe9, 0x25, 0xc1, 0x0b, 0xb1, 0xc2, 0x6e, 0x35, 0x8f,
	0xd3, 0x54, 0x84, 0xaa, 0x5b, 0xc9, 0xd1, 0xde, 0xe0, 0x3b, 0x15, 0x74, 0xec, 0xa3, 0xbb, 0xf2,
	0x38, 0x09, 0xe6, 0x2a, 0x70, 0xf2, 0xd0, 0xff, 0x35, 0xb4, 0x8a, 0xe6, 0xc0, 0xa0, 0x4e, 0x89,
	0x25, 0x5d, 0x4c, 0xf4, 0xe6, 0xae, 0xa5, 0xdf, 0xda, 0xb5, 0xf6, 0x0e, 0xc0, 0x28, 0x76, 0x4c,
	0x66, 0xc1, 0xf6, 0xc5, 0xe4, 0xc5, 0xe4, 0xfc, 0xf5, 0x64, 0x36, 0xfd, 0xde, 0x19, 0x59, 0x5b,
	0xcc, 0x84, 0xc6, 0xd9, 0xb7, 0xb3, 0xb3, 0x43, 0x4b, 0x63, 0x4d, 0xd0, 0xcf, 0x8e, 0x2d, 0x7d,
	0xef, 0x14, 0x60, 0xbd, 0x96, 0xb2, 0xfb, 0xd0, 0x2d, 0x54, 0xce, 0x8e, 0x0b, 0xad, 0x36, 0xb4,
	0xf8, 0xe8, 0xe5, 0xc5, 0xc8, 0x9d, 0x5a, 0x1a, 0xdb, 0x06, 0x83, 0x8f, 0x5c, 0xe7, 0x7c, 0xe2,
	0x8e, 0x2c, 0x9d, 0x01, 0x34, 0xdd, 0x67, 0xdf, 0x39, 0x67, 0x23, 0xab, 0xb6, 0xf7, 0x04, 0xcc,
	0x72, 0xc5, 0x61, 0x5d, 0x68, 0x8f, 0x9d, 0xd9, 0xe4, 0x7c, 0x3a, 0xbb, 0x70, 0x47, 0x43, 0x6b,
	0x8b, 0x19, 0x50, 0x1f, 0x3b, 0x37, 0x78, 0xb3, 0xa4, 0x8e, 0x2c, 0x7d, 0xef, 0x57, 0xd0, 0x52,
	0x6d, 0x0e, 0x2f, 0x7e, 0x35, 0xe2, 0xc3, 0xf1, 0x60, 0x3a, 0x53, 0x06, 0x58, 0x5b, 0x6c, 0x07,
	0xcc, 0x93, 0x73, 0xfe, 0xfa, 0x19, 0x1f, 0x8e, 0x86, 0x96, 0x86, 0x76, 0x0c, 0xf9, 0xb9, 0xe3,
	0x8c, 0x86, 0x96, 0xbe, 0xf7, 0x4b, 0x30, 0xd7, 0x23, 0xb0, 0x0d, 0xad, 0xb5, 0x56, 0x17, 0xda,
	0xc4, 0x71, 0xbd, 0x45, 0x12, 0x0a, 0xcb, 0x64, 0x1d, 0x00, 0x4e, 0x0b, 0xee, 0x59, 0x9c, 0xe5,
	0x96, 0x7e, 0xd9, 0xa4, 0xb4, 0xf9, 0xf6, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x2f, 0xeb, 0x61,
	0x4a, 0x5e, 0x0f, 0x00, 0x00,
}
