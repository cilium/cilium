// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v6.33.2
// source: envoy/admin/v3/clusters.proto

package adminv3

import (
	_ "github.com/cncf/xds/go/udpa/annotations"
	v31 "github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3"
	v32 "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
	v3 "github.com/envoyproxy/go-control-plane/envoy/type/v3"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Admin endpoint uses this wrapper for “/clusters“ to display cluster status information.
// See :ref:`/clusters <operations_admin_interface_clusters>` for more information.
type Clusters struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Mapping from cluster name to each cluster's status.
	ClusterStatuses []*ClusterStatus `protobuf:"bytes,1,rep,name=cluster_statuses,json=clusterStatuses,proto3" json:"cluster_statuses,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *Clusters) Reset() {
	*x = Clusters{}
	mi := &file_envoy_admin_v3_clusters_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Clusters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Clusters) ProtoMessage() {}

func (x *Clusters) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_admin_v3_clusters_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Clusters.ProtoReflect.Descriptor instead.
func (*Clusters) Descriptor() ([]byte, []int) {
	return file_envoy_admin_v3_clusters_proto_rawDescGZIP(), []int{0}
}

func (x *Clusters) GetClusterStatuses() []*ClusterStatus {
	if x != nil {
		return x.ClusterStatuses
	}
	return nil
}

// Details an individual cluster's current status.
// [#next-free-field: 9]
type ClusterStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the cluster.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Denotes whether this cluster was added via API or configured statically.
	AddedViaApi bool `protobuf:"varint,2,opt,name=added_via_api,json=addedViaApi,proto3" json:"added_via_api,omitempty"`
	// The success rate threshold used in the last interval.
	//
	//   - If :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
	//     is “false“, all errors: externally and locally generated were used to calculate the threshold.
	//   - If :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
	//     is “true“, only externally generated errors were used to calculate the threshold.
	//
	// The threshold is used to eject hosts based on their success rate. For more information, see the
	// :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation.
	//
	// .. note::
	//
	//	This field may be omitted in any of the three following cases:
	//
	//	1. There were not enough hosts with enough request volume to proceed with success rate based outlier ejection.
	//	2. The threshold is computed to be < 0 because a negative value implies that there was no threshold for that
	//	   interval.
	//	3. Outlier detection is not enabled for this cluster.
	SuccessRateEjectionThreshold *v3.Percent `protobuf:"bytes,3,opt,name=success_rate_ejection_threshold,json=successRateEjectionThreshold,proto3" json:"success_rate_ejection_threshold,omitempty"`
	// Mapping from host address to the host's current status.
	HostStatuses []*HostStatus `protobuf:"bytes,4,rep,name=host_statuses,json=hostStatuses,proto3" json:"host_statuses,omitempty"`
	// The success rate threshold used in the last interval when only locally originated failures were
	// taken into account and externally originated errors were treated as success.
	// This field should be interpreted only when
	// :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
	// is “true“. The threshold is used to eject hosts based on their success rate.
	//
	// For more information, see the :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation.
	//
	// .. note::
	//
	//	This field may be omitted in any of the three following cases:
	//
	//	1. There were not enough hosts with enough request volume to proceed with success rate based outlier ejection.
	//	2. The threshold is computed to be < 0 because a negative value implies that there was no threshold for that
	//	   interval.
	//	3. Outlier detection is not enabled for this cluster.
	LocalOriginSuccessRateEjectionThreshold *v3.Percent `protobuf:"bytes,5,opt,name=local_origin_success_rate_ejection_threshold,json=localOriginSuccessRateEjectionThreshold,proto3" json:"local_origin_success_rate_ejection_threshold,omitempty"`
	// :ref:`Circuit breaking <arch_overview_circuit_break>` settings of the cluster.
	CircuitBreakers *v31.CircuitBreakers `protobuf:"bytes,6,opt,name=circuit_breakers,json=circuitBreakers,proto3" json:"circuit_breakers,omitempty"`
	// Observability name of the cluster.
	ObservabilityName string `protobuf:"bytes,7,opt,name=observability_name,json=observabilityName,proto3" json:"observability_name,omitempty"`
	// The :ref:`EDS service name <envoy_v3_api_field_config.cluster.v3.Cluster.EdsClusterConfig.service_name>` if the cluster is an EDS cluster.
	EdsServiceName string `protobuf:"bytes,8,opt,name=eds_service_name,json=edsServiceName,proto3" json:"eds_service_name,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ClusterStatus) Reset() {
	*x = ClusterStatus{}
	mi := &file_envoy_admin_v3_clusters_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClusterStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClusterStatus) ProtoMessage() {}

func (x *ClusterStatus) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_admin_v3_clusters_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClusterStatus.ProtoReflect.Descriptor instead.
func (*ClusterStatus) Descriptor() ([]byte, []int) {
	return file_envoy_admin_v3_clusters_proto_rawDescGZIP(), []int{1}
}

func (x *ClusterStatus) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ClusterStatus) GetAddedViaApi() bool {
	if x != nil {
		return x.AddedViaApi
	}
	return false
}

func (x *ClusterStatus) GetSuccessRateEjectionThreshold() *v3.Percent {
	if x != nil {
		return x.SuccessRateEjectionThreshold
	}
	return nil
}

func (x *ClusterStatus) GetHostStatuses() []*HostStatus {
	if x != nil {
		return x.HostStatuses
	}
	return nil
}

func (x *ClusterStatus) GetLocalOriginSuccessRateEjectionThreshold() *v3.Percent {
	if x != nil {
		return x.LocalOriginSuccessRateEjectionThreshold
	}
	return nil
}

func (x *ClusterStatus) GetCircuitBreakers() *v31.CircuitBreakers {
	if x != nil {
		return x.CircuitBreakers
	}
	return nil
}

func (x *ClusterStatus) GetObservabilityName() string {
	if x != nil {
		return x.ObservabilityName
	}
	return ""
}

func (x *ClusterStatus) GetEdsServiceName() string {
	if x != nil {
		return x.EdsServiceName
	}
	return ""
}

// Current state of a particular host.
// [#next-free-field: 10]
type HostStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Address of this host.
	Address *v32.Address `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// List of stats specific to this host.
	Stats []*SimpleMetric `protobuf:"bytes,2,rep,name=stats,proto3" json:"stats,omitempty"`
	// The host's current health status.
	HealthStatus *HostHealthStatus `protobuf:"bytes,3,opt,name=health_status,json=healthStatus,proto3" json:"health_status,omitempty"`
	// The success rate for this host during the last measurement interval.
	//
	//   - If :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
	//     is “false“, all errors: externally and locally generated were used in success rate calculation.
	//   - If :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
	//     is “true“, only externally generated errors were used in success rate calculation.
	//
	// For more information, see the :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation.
	//
	// .. note::
	//
	//	The message will be missing if the host didn't receive enough traffic to calculate a reliable success rate, or
	//	if the cluster had too few hosts to apply outlier ejection based on success rate.
	SuccessRate *v3.Percent `protobuf:"bytes,4,opt,name=success_rate,json=successRate,proto3" json:"success_rate,omitempty"`
	// The host's weight. If not configured, the value defaults to 1.
	Weight uint32 `protobuf:"varint,5,opt,name=weight,proto3" json:"weight,omitempty"`
	// The hostname of the host, if applicable.
	Hostname string `protobuf:"bytes,6,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// The host's priority. If not configured, the value defaults to 0 (highest priority).
	Priority uint32 `protobuf:"varint,7,opt,name=priority,proto3" json:"priority,omitempty"`
	// The success rate for this host during the last interval, considering only locally generated errors. Externally
	// generated errors are treated as successes.
	//
	// This field is only relevant when
	// :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
	// is set to “true“.
	//
	// For more information, see the :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation.
	//
	// .. note::
	//
	//	The message will be missing if the host didn't receive enough traffic to compute a success rate, or if the
	//	cluster didn't have enough hosts to perform outlier ejection based on success rate.
	LocalOriginSuccessRate *v3.Percent `protobuf:"bytes,8,opt,name=local_origin_success_rate,json=localOriginSuccessRate,proto3" json:"local_origin_success_rate,omitempty"`
	// locality of the host.
	Locality      *v32.Locality `protobuf:"bytes,9,opt,name=locality,proto3" json:"locality,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HostStatus) Reset() {
	*x = HostStatus{}
	mi := &file_envoy_admin_v3_clusters_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HostStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HostStatus) ProtoMessage() {}

func (x *HostStatus) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_admin_v3_clusters_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HostStatus.ProtoReflect.Descriptor instead.
func (*HostStatus) Descriptor() ([]byte, []int) {
	return file_envoy_admin_v3_clusters_proto_rawDescGZIP(), []int{2}
}

func (x *HostStatus) GetAddress() *v32.Address {
	if x != nil {
		return x.Address
	}
	return nil
}

func (x *HostStatus) GetStats() []*SimpleMetric {
	if x != nil {
		return x.Stats
	}
	return nil
}

func (x *HostStatus) GetHealthStatus() *HostHealthStatus {
	if x != nil {
		return x.HealthStatus
	}
	return nil
}

func (x *HostStatus) GetSuccessRate() *v3.Percent {
	if x != nil {
		return x.SuccessRate
	}
	return nil
}

func (x *HostStatus) GetWeight() uint32 {
	if x != nil {
		return x.Weight
	}
	return 0
}

func (x *HostStatus) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *HostStatus) GetPriority() uint32 {
	if x != nil {
		return x.Priority
	}
	return 0
}

func (x *HostStatus) GetLocalOriginSuccessRate() *v3.Percent {
	if x != nil {
		return x.LocalOriginSuccessRate
	}
	return nil
}

func (x *HostStatus) GetLocality() *v32.Locality {
	if x != nil {
		return x.Locality
	}
	return nil
}

// Health status for a host.
// [#next-free-field: 9]
type HostHealthStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The host is currently failing active health checks.
	FailedActiveHealthCheck bool `protobuf:"varint,1,opt,name=failed_active_health_check,json=failedActiveHealthCheck,proto3" json:"failed_active_health_check,omitempty"`
	// The host is currently considered an outlier and has been ejected.
	FailedOutlierCheck bool `protobuf:"varint,2,opt,name=failed_outlier_check,json=failedOutlierCheck,proto3" json:"failed_outlier_check,omitempty"`
	// The host is currently being marked as degraded through active health checking.
	FailedActiveDegradedCheck bool `protobuf:"varint,4,opt,name=failed_active_degraded_check,json=failedActiveDegradedCheck,proto3" json:"failed_active_degraded_check,omitempty"`
	// The host has been removed from service discovery, but is being stabilized due to active
	// health checking.
	PendingDynamicRemoval bool `protobuf:"varint,5,opt,name=pending_dynamic_removal,json=pendingDynamicRemoval,proto3" json:"pending_dynamic_removal,omitempty"`
	// The host is awaiting first health check.
	PendingActiveHc bool `protobuf:"varint,6,opt,name=pending_active_hc,json=pendingActiveHc,proto3" json:"pending_active_hc,omitempty"`
	// The host should be excluded from panic, spillover, etc. calculations because it was explicitly
	// taken out of rotation via protocol signal and is not meant to be routed to.
	ExcludedViaImmediateHcFail bool `protobuf:"varint,7,opt,name=excluded_via_immediate_hc_fail,json=excludedViaImmediateHcFail,proto3" json:"excluded_via_immediate_hc_fail,omitempty"`
	// The host failed active health check due to timeout.
	ActiveHcTimeout bool `protobuf:"varint,8,opt,name=active_hc_timeout,json=activeHcTimeout,proto3" json:"active_hc_timeout,omitempty"`
	// Health status as reported by EDS.
	//
	// .. note::
	//
	//	Currently, only ``HEALTHY`` and ``UNHEALTHY`` are supported.
	//
	// [#comment:TODO(mrice32): pipe through remaining EDS health status possibilities.]
	EdsHealthStatus v32.HealthStatus `protobuf:"varint,3,opt,name=eds_health_status,json=edsHealthStatus,proto3,enum=envoy.config.core.v3.HealthStatus" json:"eds_health_status,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *HostHealthStatus) Reset() {
	*x = HostHealthStatus{}
	mi := &file_envoy_admin_v3_clusters_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HostHealthStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HostHealthStatus) ProtoMessage() {}

func (x *HostHealthStatus) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_admin_v3_clusters_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HostHealthStatus.ProtoReflect.Descriptor instead.
func (*HostHealthStatus) Descriptor() ([]byte, []int) {
	return file_envoy_admin_v3_clusters_proto_rawDescGZIP(), []int{3}
}

func (x *HostHealthStatus) GetFailedActiveHealthCheck() bool {
	if x != nil {
		return x.FailedActiveHealthCheck
	}
	return false
}

func (x *HostHealthStatus) GetFailedOutlierCheck() bool {
	if x != nil {
		return x.FailedOutlierCheck
	}
	return false
}

func (x *HostHealthStatus) GetFailedActiveDegradedCheck() bool {
	if x != nil {
		return x.FailedActiveDegradedCheck
	}
	return false
}

func (x *HostHealthStatus) GetPendingDynamicRemoval() bool {
	if x != nil {
		return x.PendingDynamicRemoval
	}
	return false
}

func (x *HostHealthStatus) GetPendingActiveHc() bool {
	if x != nil {
		return x.PendingActiveHc
	}
	return false
}

func (x *HostHealthStatus) GetExcludedViaImmediateHcFail() bool {
	if x != nil {
		return x.ExcludedViaImmediateHcFail
	}
	return false
}

func (x *HostHealthStatus) GetActiveHcTimeout() bool {
	if x != nil {
		return x.ActiveHcTimeout
	}
	return false
}

func (x *HostHealthStatus) GetEdsHealthStatus() v32.HealthStatus {
	if x != nil {
		return x.EdsHealthStatus
	}
	return v32.HealthStatus(0)
}

var File_envoy_admin_v3_clusters_proto protoreflect.FileDescriptor

const file_envoy_admin_v3_clusters_proto_rawDesc = "" +
	"\n" +
	"\x1denvoy/admin/v3/clusters.proto\x12\x0eenvoy.admin.v3\x1a\x1cenvoy/admin/v3/metrics.proto\x1a-envoy/config/cluster/v3/circuit_breaker.proto\x1a\"envoy/config/core/v3/address.proto\x1a\x1fenvoy/config/core/v3/base.proto\x1a'envoy/config/core/v3/health_check.proto\x1a\x1benvoy/type/v3/percent.proto\x1a\x1dudpa/annotations/status.proto\x1a!udpa/annotations/versioning.proto\"y\n" +
	"\bClusters\x12H\n" +
	"\x10cluster_statuses\x18\x01 \x03(\v2\x1d.envoy.admin.v3.ClusterStatusR\x0fclusterStatuses:#\x9aň\x1e\x1e\n" +
	"\x1cenvoy.admin.v2alpha.Clusters\"\xb6\x04\n" +
	"\rClusterStatus\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\"\n" +
	"\radded_via_api\x18\x02 \x01(\bR\vaddedViaApi\x12]\n" +
	"\x1fsuccess_rate_ejection_threshold\x18\x03 \x01(\v2\x16.envoy.type.v3.PercentR\x1csuccessRateEjectionThreshold\x12?\n" +
	"\rhost_statuses\x18\x04 \x03(\v2\x1a.envoy.admin.v3.HostStatusR\fhostStatuses\x12u\n" +
	",local_origin_success_rate_ejection_threshold\x18\x05 \x01(\v2\x16.envoy.type.v3.PercentR'localOriginSuccessRateEjectionThreshold\x12S\n" +
	"\x10circuit_breakers\x18\x06 \x01(\v2(.envoy.config.cluster.v3.CircuitBreakersR\x0fcircuitBreakers\x12-\n" +
	"\x12observability_name\x18\a \x01(\tR\x11observabilityName\x12(\n" +
	"\x10eds_service_name\x18\b \x01(\tR\x0eedsServiceName:(\x9aň\x1e#\n" +
	"!envoy.admin.v2alpha.ClusterStatus\"\x81\x04\n" +
	"\n" +
	"HostStatus\x127\n" +
	"\aaddress\x18\x01 \x01(\v2\x1d.envoy.config.core.v3.AddressR\aaddress\x122\n" +
	"\x05stats\x18\x02 \x03(\v2\x1c.envoy.admin.v3.SimpleMetricR\x05stats\x12E\n" +
	"\rhealth_status\x18\x03 \x01(\v2 .envoy.admin.v3.HostHealthStatusR\fhealthStatus\x129\n" +
	"\fsuccess_rate\x18\x04 \x01(\v2\x16.envoy.type.v3.PercentR\vsuccessRate\x12\x16\n" +
	"\x06weight\x18\x05 \x01(\rR\x06weight\x12\x1a\n" +
	"\bhostname\x18\x06 \x01(\tR\bhostname\x12\x1a\n" +
	"\bpriority\x18\a \x01(\rR\bpriority\x12Q\n" +
	"\x19local_origin_success_rate\x18\b \x01(\v2\x16.envoy.type.v3.PercentR\x16localOriginSuccessRate\x12:\n" +
	"\blocality\x18\t \x01(\v2\x1e.envoy.config.core.v3.LocalityR\blocality:%\x9aň\x1e \n" +
	"\x1eenvoy.admin.v2alpha.HostStatus\"\x93\x04\n" +
	"\x10HostHealthStatus\x12;\n" +
	"\x1afailed_active_health_check\x18\x01 \x01(\bR\x17failedActiveHealthCheck\x120\n" +
	"\x14failed_outlier_check\x18\x02 \x01(\bR\x12failedOutlierCheck\x12?\n" +
	"\x1cfailed_active_degraded_check\x18\x04 \x01(\bR\x19failedActiveDegradedCheck\x126\n" +
	"\x17pending_dynamic_removal\x18\x05 \x01(\bR\x15pendingDynamicRemoval\x12*\n" +
	"\x11pending_active_hc\x18\x06 \x01(\bR\x0fpendingActiveHc\x12B\n" +
	"\x1eexcluded_via_immediate_hc_fail\x18\a \x01(\bR\x1aexcludedViaImmediateHcFail\x12*\n" +
	"\x11active_hc_timeout\x18\b \x01(\bR\x0factiveHcTimeout\x12N\n" +
	"\x11eds_health_status\x18\x03 \x01(\x0e2\".envoy.config.core.v3.HealthStatusR\x0fedsHealthStatus:+\x9aň\x1e&\n" +
	"$envoy.admin.v2alpha.HostHealthStatusBv\xba\x80\xc8\xd1\x06\x02\x10\x02\n" +
	"\x1cio.envoyproxy.envoy.admin.v3B\rClustersProtoP\x01Z=github.com/envoyproxy/go-control-plane/envoy/admin/v3;adminv3b\x06proto3"

var (
	file_envoy_admin_v3_clusters_proto_rawDescOnce sync.Once
	file_envoy_admin_v3_clusters_proto_rawDescData []byte
)

func file_envoy_admin_v3_clusters_proto_rawDescGZIP() []byte {
	file_envoy_admin_v3_clusters_proto_rawDescOnce.Do(func() {
		file_envoy_admin_v3_clusters_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_envoy_admin_v3_clusters_proto_rawDesc), len(file_envoy_admin_v3_clusters_proto_rawDesc)))
	})
	return file_envoy_admin_v3_clusters_proto_rawDescData
}

var file_envoy_admin_v3_clusters_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_envoy_admin_v3_clusters_proto_goTypes = []any{
	(*Clusters)(nil),            // 0: envoy.admin.v3.Clusters
	(*ClusterStatus)(nil),       // 1: envoy.admin.v3.ClusterStatus
	(*HostStatus)(nil),          // 2: envoy.admin.v3.HostStatus
	(*HostHealthStatus)(nil),    // 3: envoy.admin.v3.HostHealthStatus
	(*v3.Percent)(nil),          // 4: envoy.type.v3.Percent
	(*v31.CircuitBreakers)(nil), // 5: envoy.config.cluster.v3.CircuitBreakers
	(*v32.Address)(nil),         // 6: envoy.config.core.v3.Address
	(*SimpleMetric)(nil),        // 7: envoy.admin.v3.SimpleMetric
	(*v32.Locality)(nil),        // 8: envoy.config.core.v3.Locality
	(v32.HealthStatus)(0),       // 9: envoy.config.core.v3.HealthStatus
}
var file_envoy_admin_v3_clusters_proto_depIdxs = []int32{
	1,  // 0: envoy.admin.v3.Clusters.cluster_statuses:type_name -> envoy.admin.v3.ClusterStatus
	4,  // 1: envoy.admin.v3.ClusterStatus.success_rate_ejection_threshold:type_name -> envoy.type.v3.Percent
	2,  // 2: envoy.admin.v3.ClusterStatus.host_statuses:type_name -> envoy.admin.v3.HostStatus
	4,  // 3: envoy.admin.v3.ClusterStatus.local_origin_success_rate_ejection_threshold:type_name -> envoy.type.v3.Percent
	5,  // 4: envoy.admin.v3.ClusterStatus.circuit_breakers:type_name -> envoy.config.cluster.v3.CircuitBreakers
	6,  // 5: envoy.admin.v3.HostStatus.address:type_name -> envoy.config.core.v3.Address
	7,  // 6: envoy.admin.v3.HostStatus.stats:type_name -> envoy.admin.v3.SimpleMetric
	3,  // 7: envoy.admin.v3.HostStatus.health_status:type_name -> envoy.admin.v3.HostHealthStatus
	4,  // 8: envoy.admin.v3.HostStatus.success_rate:type_name -> envoy.type.v3.Percent
	4,  // 9: envoy.admin.v3.HostStatus.local_origin_success_rate:type_name -> envoy.type.v3.Percent
	8,  // 10: envoy.admin.v3.HostStatus.locality:type_name -> envoy.config.core.v3.Locality
	9,  // 11: envoy.admin.v3.HostHealthStatus.eds_health_status:type_name -> envoy.config.core.v3.HealthStatus
	12, // [12:12] is the sub-list for method output_type
	12, // [12:12] is the sub-list for method input_type
	12, // [12:12] is the sub-list for extension type_name
	12, // [12:12] is the sub-list for extension extendee
	0,  // [0:12] is the sub-list for field type_name
}

func init() { file_envoy_admin_v3_clusters_proto_init() }
func file_envoy_admin_v3_clusters_proto_init() {
	if File_envoy_admin_v3_clusters_proto != nil {
		return
	}
	file_envoy_admin_v3_metrics_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_envoy_admin_v3_clusters_proto_rawDesc), len(file_envoy_admin_v3_clusters_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   4,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_envoy_admin_v3_clusters_proto_goTypes,
		DependencyIndexes: file_envoy_admin_v3_clusters_proto_depIdxs,
		MessageInfos:      file_envoy_admin_v3_clusters_proto_msgTypes,
	}.Build()
	File_envoy_admin_v3_clusters_proto = out.File
	file_envoy_admin_v3_clusters_proto_goTypes = nil
	file_envoy_admin_v3_clusters_proto_depIdxs = nil
}
