// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v6.33.2
// source: envoy/service/ratelimit/v3/rls.proto

package ratelimitv3

import (
	_ "github.com/cncf/xds/go/udpa/annotations"
	v31 "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
	v3 "github.com/envoyproxy/go-control-plane/envoy/extensions/common/ratelimit/v3"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type RateLimitResponse_Code int32

const (
	// The response code is not known.
	RateLimitResponse_UNKNOWN RateLimitResponse_Code = 0
	// The response code to notify that the number of requests are under limit.
	RateLimitResponse_OK RateLimitResponse_Code = 1
	// The response code to notify that the number of requests are over limit.
	RateLimitResponse_OVER_LIMIT RateLimitResponse_Code = 2
)

// Enum value maps for RateLimitResponse_Code.
var (
	RateLimitResponse_Code_name = map[int32]string{
		0: "UNKNOWN",
		1: "OK",
		2: "OVER_LIMIT",
	}
	RateLimitResponse_Code_value = map[string]int32{
		"UNKNOWN":    0,
		"OK":         1,
		"OVER_LIMIT": 2,
	}
)

func (x RateLimitResponse_Code) Enum() *RateLimitResponse_Code {
	p := new(RateLimitResponse_Code)
	*p = x
	return p
}

func (x RateLimitResponse_Code) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RateLimitResponse_Code) Descriptor() protoreflect.EnumDescriptor {
	return file_envoy_service_ratelimit_v3_rls_proto_enumTypes[0].Descriptor()
}

func (RateLimitResponse_Code) Type() protoreflect.EnumType {
	return &file_envoy_service_ratelimit_v3_rls_proto_enumTypes[0]
}

func (x RateLimitResponse_Code) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RateLimitResponse_Code.Descriptor instead.
func (RateLimitResponse_Code) EnumDescriptor() ([]byte, []int) {
	return file_envoy_service_ratelimit_v3_rls_proto_rawDescGZIP(), []int{1, 0}
}

// Identifies the unit of of time for rate limit.
// [#comment: replace by envoy/type/v3/ratelimit_unit.proto in v4]
type RateLimitResponse_RateLimit_Unit int32

const (
	// The time unit is not known.
	RateLimitResponse_RateLimit_UNKNOWN RateLimitResponse_RateLimit_Unit = 0
	// The time unit representing a second.
	RateLimitResponse_RateLimit_SECOND RateLimitResponse_RateLimit_Unit = 1
	// The time unit representing a minute.
	RateLimitResponse_RateLimit_MINUTE RateLimitResponse_RateLimit_Unit = 2
	// The time unit representing an hour.
	RateLimitResponse_RateLimit_HOUR RateLimitResponse_RateLimit_Unit = 3
	// The time unit representing a day.
	RateLimitResponse_RateLimit_DAY RateLimitResponse_RateLimit_Unit = 4
	// The time unit representing a week.
	RateLimitResponse_RateLimit_WEEK RateLimitResponse_RateLimit_Unit = 7
	// The time unit representing a month.
	RateLimitResponse_RateLimit_MONTH RateLimitResponse_RateLimit_Unit = 5
	// The time unit representing a year.
	RateLimitResponse_RateLimit_YEAR RateLimitResponse_RateLimit_Unit = 6
)

// Enum value maps for RateLimitResponse_RateLimit_Unit.
var (
	RateLimitResponse_RateLimit_Unit_name = map[int32]string{
		0: "UNKNOWN",
		1: "SECOND",
		2: "MINUTE",
		3: "HOUR",
		4: "DAY",
		7: "WEEK",
		5: "MONTH",
		6: "YEAR",
	}
	RateLimitResponse_RateLimit_Unit_value = map[string]int32{
		"UNKNOWN": 0,
		"SECOND":  1,
		"MINUTE":  2,
		"HOUR":    3,
		"DAY":     4,
		"WEEK":    7,
		"MONTH":   5,
		"YEAR":    6,
	}
)

func (x RateLimitResponse_RateLimit_Unit) Enum() *RateLimitResponse_RateLimit_Unit {
	p := new(RateLimitResponse_RateLimit_Unit)
	*p = x
	return p
}

func (x RateLimitResponse_RateLimit_Unit) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RateLimitResponse_RateLimit_Unit) Descriptor() protoreflect.EnumDescriptor {
	return file_envoy_service_ratelimit_v3_rls_proto_enumTypes[1].Descriptor()
}

func (RateLimitResponse_RateLimit_Unit) Type() protoreflect.EnumType {
	return &file_envoy_service_ratelimit_v3_rls_proto_enumTypes[1]
}

func (x RateLimitResponse_RateLimit_Unit) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RateLimitResponse_RateLimit_Unit.Descriptor instead.
func (RateLimitResponse_RateLimit_Unit) EnumDescriptor() ([]byte, []int) {
	return file_envoy_service_ratelimit_v3_rls_proto_rawDescGZIP(), []int{1, 0, 0}
}

// Main message for a rate limit request. The rate limit service is designed to be fully generic
// in the sense that it can operate on arbitrary hierarchical key/value pairs. The loaded
// configuration will parse the request and find the most specific limit to apply. In addition,
// a RateLimitRequest can contain multiple "descriptors" to limit on. When multiple descriptors
// are provided, the server will limit on *ALL* of them and return an OVER_LIMIT response if any
// of them are over limit. This enables more complex application level rate limiting scenarios
// if desired.
type RateLimitRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// All rate limit requests must specify a domain. This enables the configuration to be per
	// application without fear of overlap. E.g., "envoy".
	Domain string `protobuf:"bytes,1,opt,name=domain,proto3" json:"domain,omitempty"`
	// All rate limit requests must specify at least one RateLimitDescriptor. Each descriptor is
	// processed by the service (see below). If any of the descriptors are over limit, the entire
	// request is considered to be over limit.
	Descriptors []*v3.RateLimitDescriptor `protobuf:"bytes,2,rep,name=descriptors,proto3" json:"descriptors,omitempty"`
	// Rate limit requests can optionally specify the number of hits a request adds to the matched
	// limit. If the value is not set in the message, a request increases the matched limit by 1.
	// This value can be overridden by setting filter state value “envoy.ratelimit.hits_addend“
	// to the desired number. Invalid number (< 0) or number will be ignored.
	HitsAddend    uint32 `protobuf:"varint,3,opt,name=hits_addend,json=hitsAddend,proto3" json:"hits_addend,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RateLimitRequest) Reset() {
	*x = RateLimitRequest{}
	mi := &file_envoy_service_ratelimit_v3_rls_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RateLimitRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimitRequest) ProtoMessage() {}

func (x *RateLimitRequest) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_service_ratelimit_v3_rls_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimitRequest.ProtoReflect.Descriptor instead.
func (*RateLimitRequest) Descriptor() ([]byte, []int) {
	return file_envoy_service_ratelimit_v3_rls_proto_rawDescGZIP(), []int{0}
}

func (x *RateLimitRequest) GetDomain() string {
	if x != nil {
		return x.Domain
	}
	return ""
}

func (x *RateLimitRequest) GetDescriptors() []*v3.RateLimitDescriptor {
	if x != nil {
		return x.Descriptors
	}
	return nil
}

func (x *RateLimitRequest) GetHitsAddend() uint32 {
	if x != nil {
		return x.HitsAddend
	}
	return 0
}

// A response from a ShouldRateLimit call.
// [#next-free-field: 8]
type RateLimitResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The overall response code which takes into account all of the descriptors that were passed
	// in the RateLimitRequest message.
	OverallCode RateLimitResponse_Code `protobuf:"varint,1,opt,name=overall_code,json=overallCode,proto3,enum=envoy.service.ratelimit.v3.RateLimitResponse_Code" json:"overall_code,omitempty"`
	// A list of DescriptorStatus messages which matches the length of the descriptor list passed
	// in the RateLimitRequest. This can be used by the caller to determine which individual
	// descriptors failed and/or what the currently configured limits are for all of them.
	Statuses []*RateLimitResponse_DescriptorStatus `protobuf:"bytes,2,rep,name=statuses,proto3" json:"statuses,omitempty"`
	// A list of headers to add to the response
	ResponseHeadersToAdd []*v31.HeaderValue `protobuf:"bytes,3,rep,name=response_headers_to_add,json=responseHeadersToAdd,proto3" json:"response_headers_to_add,omitempty"`
	// A list of headers to add to the request when forwarded
	RequestHeadersToAdd []*v31.HeaderValue `protobuf:"bytes,4,rep,name=request_headers_to_add,json=requestHeadersToAdd,proto3" json:"request_headers_to_add,omitempty"`
	// A response body to send to the downstream client when the response code is not OK.
	RawBody []byte `protobuf:"bytes,5,opt,name=raw_body,json=rawBody,proto3" json:"raw_body,omitempty"`
	// Optional response metadata that will be emitted as dynamic metadata to be consumed by the next
	// filter. This metadata lives in a namespace specified by the canonical name of extension filter
	// that requires it:
	//
	// - :ref:`envoy.filters.http.ratelimit <config_http_filters_ratelimit_dynamic_metadata>` for HTTP filter.
	// - :ref:`envoy.filters.network.ratelimit <config_network_filters_ratelimit_dynamic_metadata>` for network filter.
	// - :ref:`envoy.filters.thrift.rate_limit <config_thrift_filters_rate_limit_dynamic_metadata>` for Thrift filter.
	DynamicMetadata *structpb.Struct `protobuf:"bytes,6,opt,name=dynamic_metadata,json=dynamicMetadata,proto3" json:"dynamic_metadata,omitempty"`
	// Quota is available for a request if its entire descriptor set has cached quota available.
	// This is a union of all descriptors in the descriptor set. Clients can use the quota for future matches if and only if the descriptor set matches what was sent in the request that originated this response.
	//
	// If quota is available, a RLS request will not be made and the quota will be reduced by 1.
	// If quota is not available (i.e., a cached entry doesn't exist for a RLS descriptor set), a RLS request will be triggered.
	// If the server did not provide a quota, such as the quota message is empty then the request admission is determined by the
	// :ref:`overall_code <envoy_v3_api_field_service.ratelimit.v3.RateLimitResponse.overall_code>`.
	//
	// If there is not sufficient quota and the cached entry exists for a RLS descriptor set is out-of-quota but not expired,
	// the request will be treated as OVER_LIMIT.
	// [#not-implemented-hide:]
	Quota         *RateLimitResponse_Quota `protobuf:"bytes,7,opt,name=quota,proto3" json:"quota,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RateLimitResponse) Reset() {
	*x = RateLimitResponse{}
	mi := &file_envoy_service_ratelimit_v3_rls_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RateLimitResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimitResponse) ProtoMessage() {}

func (x *RateLimitResponse) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_service_ratelimit_v3_rls_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimitResponse.ProtoReflect.Descriptor instead.
func (*RateLimitResponse) Descriptor() ([]byte, []int) {
	return file_envoy_service_ratelimit_v3_rls_proto_rawDescGZIP(), []int{1}
}

func (x *RateLimitResponse) GetOverallCode() RateLimitResponse_Code {
	if x != nil {
		return x.OverallCode
	}
	return RateLimitResponse_UNKNOWN
}

func (x *RateLimitResponse) GetStatuses() []*RateLimitResponse_DescriptorStatus {
	if x != nil {
		return x.Statuses
	}
	return nil
}

func (x *RateLimitResponse) GetResponseHeadersToAdd() []*v31.HeaderValue {
	if x != nil {
		return x.ResponseHeadersToAdd
	}
	return nil
}

func (x *RateLimitResponse) GetRequestHeadersToAdd() []*v31.HeaderValue {
	if x != nil {
		return x.RequestHeadersToAdd
	}
	return nil
}

func (x *RateLimitResponse) GetRawBody() []byte {
	if x != nil {
		return x.RawBody
	}
	return nil
}

func (x *RateLimitResponse) GetDynamicMetadata() *structpb.Struct {
	if x != nil {
		return x.DynamicMetadata
	}
	return nil
}

func (x *RateLimitResponse) GetQuota() *RateLimitResponse_Quota {
	if x != nil {
		return x.Quota
	}
	return nil
}

// Defines an actual rate limit in terms of requests per unit of time and the unit itself.
type RateLimitResponse_RateLimit struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A name or description of this limit.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// The number of requests per unit of time.
	RequestsPerUnit uint32 `protobuf:"varint,1,opt,name=requests_per_unit,json=requestsPerUnit,proto3" json:"requests_per_unit,omitempty"`
	// The unit of time.
	Unit          RateLimitResponse_RateLimit_Unit `protobuf:"varint,2,opt,name=unit,proto3,enum=envoy.service.ratelimit.v3.RateLimitResponse_RateLimit_Unit" json:"unit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RateLimitResponse_RateLimit) Reset() {
	*x = RateLimitResponse_RateLimit{}
	mi := &file_envoy_service_ratelimit_v3_rls_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RateLimitResponse_RateLimit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimitResponse_RateLimit) ProtoMessage() {}

func (x *RateLimitResponse_RateLimit) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_service_ratelimit_v3_rls_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimitResponse_RateLimit.ProtoReflect.Descriptor instead.
func (*RateLimitResponse_RateLimit) Descriptor() ([]byte, []int) {
	return file_envoy_service_ratelimit_v3_rls_proto_rawDescGZIP(), []int{1, 0}
}

func (x *RateLimitResponse_RateLimit) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *RateLimitResponse_RateLimit) GetRequestsPerUnit() uint32 {
	if x != nil {
		return x.RequestsPerUnit
	}
	return 0
}

func (x *RateLimitResponse_RateLimit) GetUnit() RateLimitResponse_RateLimit_Unit {
	if x != nil {
		return x.Unit
	}
	return RateLimitResponse_RateLimit_UNKNOWN
}

// Cacheable quota for responses.
// Quota can be granted at different levels: either for each individual descriptor or for the whole descriptor set.
// This is a certain number of requests over a period of time.
// The client may cache this result and apply the effective RateLimitResponse to future matching
// requests without querying rate limit service.
//
// When quota expires due to timeout, a new RLS request will also be made.
// The implementation may choose to preemptively query the rate limit server for more quota on or
// before expiration or before the available quota runs out.
// [#not-implemented-hide:]
type RateLimitResponse_Quota struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Number of matching requests granted in quota. Must be 1 or more.
	Requests uint32 `protobuf:"varint,1,opt,name=requests,proto3" json:"requests,omitempty"`
	// Types that are valid to be assigned to ExpirationSpecifier:
	//
	//	*RateLimitResponse_Quota_ValidUntil
	ExpirationSpecifier isRateLimitResponse_Quota_ExpirationSpecifier `protobuf_oneof:"expiration_specifier"`
	// The unique id that is associated with each Quota either at individual descriptor level or whole descriptor set level.
	//
	// For a matching policy with boolean logic, for example, match: "request.headers['environment'] == 'staging' || request.headers['environment'] == 'dev'"),
	// the request_headers action produces a distinct list of descriptors for each possible value of the ‘environment’ header even though the granted quota is same.
	// Thus, the client will use this id information (returned from RLS server) to correctly correlate the multiple descriptors/descriptor sets that have been granted with same quota (i.e., share the same quota among multiple descriptors or descriptor sets.)
	//
	// If id is empty, this id field will be ignored. If quota for the same id changes (e.g. due to configuration update), the old quota will be overridden by the new one. Shared quotas referenced by ID will still adhere to expiration after `valid_until`.
	Id            string `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RateLimitResponse_Quota) Reset() {
	*x = RateLimitResponse_Quota{}
	mi := &file_envoy_service_ratelimit_v3_rls_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RateLimitResponse_Quota) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimitResponse_Quota) ProtoMessage() {}

func (x *RateLimitResponse_Quota) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_service_ratelimit_v3_rls_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimitResponse_Quota.ProtoReflect.Descriptor instead.
func (*RateLimitResponse_Quota) Descriptor() ([]byte, []int) {
	return file_envoy_service_ratelimit_v3_rls_proto_rawDescGZIP(), []int{1, 1}
}

func (x *RateLimitResponse_Quota) GetRequests() uint32 {
	if x != nil {
		return x.Requests
	}
	return 0
}

func (x *RateLimitResponse_Quota) GetExpirationSpecifier() isRateLimitResponse_Quota_ExpirationSpecifier {
	if x != nil {
		return x.ExpirationSpecifier
	}
	return nil
}

func (x *RateLimitResponse_Quota) GetValidUntil() *timestamppb.Timestamp {
	if x != nil {
		if x, ok := x.ExpirationSpecifier.(*RateLimitResponse_Quota_ValidUntil); ok {
			return x.ValidUntil
		}
	}
	return nil
}

func (x *RateLimitResponse_Quota) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type isRateLimitResponse_Quota_ExpirationSpecifier interface {
	isRateLimitResponse_Quota_ExpirationSpecifier()
}

type RateLimitResponse_Quota_ValidUntil struct {
	// Point in time at which the quota expires.
	ValidUntil *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=valid_until,json=validUntil,proto3,oneof"`
}

func (*RateLimitResponse_Quota_ValidUntil) isRateLimitResponse_Quota_ExpirationSpecifier() {}

// [#next-free-field: 6]
type RateLimitResponse_DescriptorStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The response code for an individual descriptor.
	Code RateLimitResponse_Code `protobuf:"varint,1,opt,name=code,proto3,enum=envoy.service.ratelimit.v3.RateLimitResponse_Code" json:"code,omitempty"`
	// The current limit as configured by the server. Useful for debugging, etc.
	CurrentLimit *RateLimitResponse_RateLimit `protobuf:"bytes,2,opt,name=current_limit,json=currentLimit,proto3" json:"current_limit,omitempty"`
	// The limit remaining in the current time unit.
	LimitRemaining uint32 `protobuf:"varint,3,opt,name=limit_remaining,json=limitRemaining,proto3" json:"limit_remaining,omitempty"`
	// Duration until reset of the current limit window.
	DurationUntilReset *durationpb.Duration `protobuf:"bytes,4,opt,name=duration_until_reset,json=durationUntilReset,proto3" json:"duration_until_reset,omitempty"`
	// Quota is available for a request if its descriptor set has cached quota available for all
	// descriptors.
	// This is for each individual descriptor in the descriptor set. The client will perform matches for each individual descriptor against available per-descriptor quota.
	//
	// If quota is available, a RLS request will not be made and the quota will be reduced by 1 for
	// all matching descriptors.
	//
	// If there is not sufficient quota, there are three cases:
	//  1. A cached entry exists for a RLS descriptor that is out-of-quota, but not expired.
	//     In this case, the request will be treated as OVER_LIMIT.
	//  2. Some RLS descriptors have a cached entry that has valid quota but some RLS descriptors
	//     have no cached entry. This will trigger a new RLS request.
	//     When the result is returned, a single unit will be consumed from the quota for all
	//     matching descriptors.
	//     If the server did not provide a quota, such as the quota message is empty for some of
	//     the descriptors, then the request admission is determined by the
	//     :ref:`overall_code <envoy_v3_api_field_service.ratelimit.v3.RateLimitResponse.overall_code>`.
	//  3. All RLS descriptors lack a cached entry, this will trigger a new RLS request,
	//     When the result is returned, a single unit will be consumed from the quota for all
	//     matching descriptors.
	//     If the server did not provide a quota, such as the quota message is empty for some of
	//     the descriptors, then the request admission is determined by the
	//     :ref:`overall_code <envoy_v3_api_field_service.ratelimit.v3.RateLimitResponse.overall_code>`.
	//
	// [#not-implemented-hide:]
	Quota         *RateLimitResponse_Quota `protobuf:"bytes,5,opt,name=quota,proto3" json:"quota,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RateLimitResponse_DescriptorStatus) Reset() {
	*x = RateLimitResponse_DescriptorStatus{}
	mi := &file_envoy_service_ratelimit_v3_rls_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RateLimitResponse_DescriptorStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimitResponse_DescriptorStatus) ProtoMessage() {}

func (x *RateLimitResponse_DescriptorStatus) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_service_ratelimit_v3_rls_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimitResponse_DescriptorStatus.ProtoReflect.Descriptor instead.
func (*RateLimitResponse_DescriptorStatus) Descriptor() ([]byte, []int) {
	return file_envoy_service_ratelimit_v3_rls_proto_rawDescGZIP(), []int{1, 2}
}

func (x *RateLimitResponse_DescriptorStatus) GetCode() RateLimitResponse_Code {
	if x != nil {
		return x.Code
	}
	return RateLimitResponse_UNKNOWN
}

func (x *RateLimitResponse_DescriptorStatus) GetCurrentLimit() *RateLimitResponse_RateLimit {
	if x != nil {
		return x.CurrentLimit
	}
	return nil
}

func (x *RateLimitResponse_DescriptorStatus) GetLimitRemaining() uint32 {
	if x != nil {
		return x.LimitRemaining
	}
	return 0
}

func (x *RateLimitResponse_DescriptorStatus) GetDurationUntilReset() *durationpb.Duration {
	if x != nil {
		return x.DurationUntilReset
	}
	return nil
}

func (x *RateLimitResponse_DescriptorStatus) GetQuota() *RateLimitResponse_Quota {
	if x != nil {
		return x.Quota
	}
	return nil
}

var File_envoy_service_ratelimit_v3_rls_proto protoreflect.FileDescriptor

const file_envoy_service_ratelimit_v3_rls_proto_rawDesc = "" +
	"\n" +
	"$envoy/service/ratelimit/v3/rls.proto\x12\x1aenvoy.service.ratelimit.v3\x1a\x1fenvoy/config/core/v3/base.proto\x1a4envoy/extensions/common/ratelimit/v3/ratelimit.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1cgoogle/protobuf/struct.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1dudpa/annotations/status.proto\x1a!udpa/annotations/versioning.proto\x1a\x17validate/validate.proto\"\xdc\x01\n" +
	"\x10RateLimitRequest\x12\x16\n" +
	"\x06domain\x18\x01 \x01(\tR\x06domain\x12[\n" +
	"\vdescriptors\x18\x02 \x03(\v29.envoy.extensions.common.ratelimit.v3.RateLimitDescriptorR\vdescriptors\x12\x1f\n" +
	"\vhits_addend\x18\x03 \x01(\rR\n" +
	"hitsAddend:2\x9aň\x1e-\n" +
	"+envoy.service.ratelimit.v2.RateLimitRequest\"\x9a\f\n" +
	"\x11RateLimitResponse\x12U\n" +
	"\foverall_code\x18\x01 \x01(\x0e22.envoy.service.ratelimit.v3.RateLimitResponse.CodeR\voverallCode\x12Z\n" +
	"\bstatuses\x18\x02 \x03(\v2>.envoy.service.ratelimit.v3.RateLimitResponse.DescriptorStatusR\bstatuses\x12X\n" +
	"\x17response_headers_to_add\x18\x03 \x03(\v2!.envoy.config.core.v3.HeaderValueR\x14responseHeadersToAdd\x12V\n" +
	"\x16request_headers_to_add\x18\x04 \x03(\v2!.envoy.config.core.v3.HeaderValueR\x13requestHeadersToAdd\x12\x19\n" +
	"\braw_body\x18\x05 \x01(\fR\arawBody\x12B\n" +
	"\x10dynamic_metadata\x18\x06 \x01(\v2\x17.google.protobuf.StructR\x0fdynamicMetadata\x12I\n" +
	"\x05quota\x18\a \x01(\v23.envoy.service.ratelimit.v3.RateLimitResponse.QuotaR\x05quota\x1a\xbb\x02\n" +
	"\tRateLimit\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12*\n" +
	"\x11requests_per_unit\x18\x01 \x01(\rR\x0frequestsPerUnit\x12P\n" +
	"\x04unit\x18\x02 \x01(\x0e2<.envoy.service.ratelimit.v3.RateLimitResponse.RateLimit.UnitR\x04unit\"]\n" +
	"\x04Unit\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\n" +
	"\n" +
	"\x06SECOND\x10\x01\x12\n" +
	"\n" +
	"\x06MINUTE\x10\x02\x12\b\n" +
	"\x04HOUR\x10\x03\x12\a\n" +
	"\x03DAY\x10\x04\x12\b\n" +
	"\x04WEEK\x10\a\x12\t\n" +
	"\x05MONTH\x10\x05\x12\b\n" +
	"\x04YEAR\x10\x06:=\x9aň\x1e8\n" +
	"6envoy.service.ratelimit.v2.RateLimitResponse.RateLimit\x1a\x93\x01\n" +
	"\x05Quota\x12#\n" +
	"\brequests\x18\x01 \x01(\rB\a\xfaB\x04*\x02 \x00R\brequests\x12=\n" +
	"\vvalid_until\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampH\x00R\n" +
	"validUntil\x12\x0e\n" +
	"\x02id\x18\x03 \x01(\tR\x02idB\x16\n" +
	"\x14expiration_specifier\x1a\xbf\x03\n" +
	"\x10DescriptorStatus\x12F\n" +
	"\x04code\x18\x01 \x01(\x0e22.envoy.service.ratelimit.v3.RateLimitResponse.CodeR\x04code\x12\\\n" +
	"\rcurrent_limit\x18\x02 \x01(\v27.envoy.service.ratelimit.v3.RateLimitResponse.RateLimitR\fcurrentLimit\x12'\n" +
	"\x0flimit_remaining\x18\x03 \x01(\rR\x0elimitRemaining\x12K\n" +
	"\x14duration_until_reset\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\x12durationUntilReset\x12I\n" +
	"\x05quota\x18\x05 \x01(\v23.envoy.service.ratelimit.v3.RateLimitResponse.QuotaR\x05quota:D\x9aň\x1e?\n" +
	"=envoy.service.ratelimit.v2.RateLimitResponse.DescriptorStatus\"+\n" +
	"\x04Code\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\x06\n" +
	"\x02OK\x10\x01\x12\x0e\n" +
	"\n" +
	"OVER_LIMIT\x10\x02:3\x9aň\x1e.\n" +
	",envoy.service.ratelimit.v2.RateLimitResponse2\x84\x01\n" +
	"\x10RateLimitService\x12p\n" +
	"\x0fShouldRateLimit\x12,.envoy.service.ratelimit.v3.RateLimitRequest\x1a-.envoy.service.ratelimit.v3.RateLimitResponse\"\x00B\x8d\x01\xba\x80\xc8\xd1\x06\x02\x10\x02\n" +
	"(io.envoyproxy.envoy.service.ratelimit.v3B\bRlsProtoP\x01ZMgithub.com/envoyproxy/go-control-plane/envoy/service/ratelimit/v3;ratelimitv3b\x06proto3"

var (
	file_envoy_service_ratelimit_v3_rls_proto_rawDescOnce sync.Once
	file_envoy_service_ratelimit_v3_rls_proto_rawDescData []byte
)

func file_envoy_service_ratelimit_v3_rls_proto_rawDescGZIP() []byte {
	file_envoy_service_ratelimit_v3_rls_proto_rawDescOnce.Do(func() {
		file_envoy_service_ratelimit_v3_rls_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_envoy_service_ratelimit_v3_rls_proto_rawDesc), len(file_envoy_service_ratelimit_v3_rls_proto_rawDesc)))
	})
	return file_envoy_service_ratelimit_v3_rls_proto_rawDescData
}

var file_envoy_service_ratelimit_v3_rls_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_envoy_service_ratelimit_v3_rls_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_envoy_service_ratelimit_v3_rls_proto_goTypes = []any{
	(RateLimitResponse_Code)(0),                // 0: envoy.service.ratelimit.v3.RateLimitResponse.Code
	(RateLimitResponse_RateLimit_Unit)(0),      // 1: envoy.service.ratelimit.v3.RateLimitResponse.RateLimit.Unit
	(*RateLimitRequest)(nil),                   // 2: envoy.service.ratelimit.v3.RateLimitRequest
	(*RateLimitResponse)(nil),                  // 3: envoy.service.ratelimit.v3.RateLimitResponse
	(*RateLimitResponse_RateLimit)(nil),        // 4: envoy.service.ratelimit.v3.RateLimitResponse.RateLimit
	(*RateLimitResponse_Quota)(nil),            // 5: envoy.service.ratelimit.v3.RateLimitResponse.Quota
	(*RateLimitResponse_DescriptorStatus)(nil), // 6: envoy.service.ratelimit.v3.RateLimitResponse.DescriptorStatus
	(*v3.RateLimitDescriptor)(nil),             // 7: envoy.extensions.common.ratelimit.v3.RateLimitDescriptor
	(*v31.HeaderValue)(nil),                    // 8: envoy.config.core.v3.HeaderValue
	(*structpb.Struct)(nil),                    // 9: google.protobuf.Struct
	(*timestamppb.Timestamp)(nil),              // 10: google.protobuf.Timestamp
	(*durationpb.Duration)(nil),                // 11: google.protobuf.Duration
}
var file_envoy_service_ratelimit_v3_rls_proto_depIdxs = []int32{
	7,  // 0: envoy.service.ratelimit.v3.RateLimitRequest.descriptors:type_name -> envoy.extensions.common.ratelimit.v3.RateLimitDescriptor
	0,  // 1: envoy.service.ratelimit.v3.RateLimitResponse.overall_code:type_name -> envoy.service.ratelimit.v3.RateLimitResponse.Code
	6,  // 2: envoy.service.ratelimit.v3.RateLimitResponse.statuses:type_name -> envoy.service.ratelimit.v3.RateLimitResponse.DescriptorStatus
	8,  // 3: envoy.service.ratelimit.v3.RateLimitResponse.response_headers_to_add:type_name -> envoy.config.core.v3.HeaderValue
	8,  // 4: envoy.service.ratelimit.v3.RateLimitResponse.request_headers_to_add:type_name -> envoy.config.core.v3.HeaderValue
	9,  // 5: envoy.service.ratelimit.v3.RateLimitResponse.dynamic_metadata:type_name -> google.protobuf.Struct
	5,  // 6: envoy.service.ratelimit.v3.RateLimitResponse.quota:type_name -> envoy.service.ratelimit.v3.RateLimitResponse.Quota
	1,  // 7: envoy.service.ratelimit.v3.RateLimitResponse.RateLimit.unit:type_name -> envoy.service.ratelimit.v3.RateLimitResponse.RateLimit.Unit
	10, // 8: envoy.service.ratelimit.v3.RateLimitResponse.Quota.valid_until:type_name -> google.protobuf.Timestamp
	0,  // 9: envoy.service.ratelimit.v3.RateLimitResponse.DescriptorStatus.code:type_name -> envoy.service.ratelimit.v3.RateLimitResponse.Code
	4,  // 10: envoy.service.ratelimit.v3.RateLimitResponse.DescriptorStatus.current_limit:type_name -> envoy.service.ratelimit.v3.RateLimitResponse.RateLimit
	11, // 11: envoy.service.ratelimit.v3.RateLimitResponse.DescriptorStatus.duration_until_reset:type_name -> google.protobuf.Duration
	5,  // 12: envoy.service.ratelimit.v3.RateLimitResponse.DescriptorStatus.quota:type_name -> envoy.service.ratelimit.v3.RateLimitResponse.Quota
	2,  // 13: envoy.service.ratelimit.v3.RateLimitService.ShouldRateLimit:input_type -> envoy.service.ratelimit.v3.RateLimitRequest
	3,  // 14: envoy.service.ratelimit.v3.RateLimitService.ShouldRateLimit:output_type -> envoy.service.ratelimit.v3.RateLimitResponse
	14, // [14:15] is the sub-list for method output_type
	13, // [13:14] is the sub-list for method input_type
	13, // [13:13] is the sub-list for extension type_name
	13, // [13:13] is the sub-list for extension extendee
	0,  // [0:13] is the sub-list for field type_name
}

func init() { file_envoy_service_ratelimit_v3_rls_proto_init() }
func file_envoy_service_ratelimit_v3_rls_proto_init() {
	if File_envoy_service_ratelimit_v3_rls_proto != nil {
		return
	}
	file_envoy_service_ratelimit_v3_rls_proto_msgTypes[3].OneofWrappers = []any{
		(*RateLimitResponse_Quota_ValidUntil)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_envoy_service_ratelimit_v3_rls_proto_rawDesc), len(file_envoy_service_ratelimit_v3_rls_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   5,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_envoy_service_ratelimit_v3_rls_proto_goTypes,
		DependencyIndexes: file_envoy_service_ratelimit_v3_rls_proto_depIdxs,
		EnumInfos:         file_envoy_service_ratelimit_v3_rls_proto_enumTypes,
		MessageInfos:      file_envoy_service_ratelimit_v3_rls_proto_msgTypes,
	}.Build()
	File_envoy_service_ratelimit_v3_rls_proto = out.File
	file_envoy_service_ratelimit_v3_rls_proto_goTypes = nil
	file_envoy_service_ratelimit_v3_rls_proto_depIdxs = nil
}
