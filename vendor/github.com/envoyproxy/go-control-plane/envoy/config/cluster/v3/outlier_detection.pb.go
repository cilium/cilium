// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v6.33.2
// source: envoy/config/cluster/v3/outlier_detection.proto

package clusterv3

import (
	_ "github.com/cncf/xds/go/udpa/annotations"
	v3 "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// See the :ref:`architecture overview <arch_overview_outlier_detection>` for
// more information on outlier detection.
// [#next-free-field: 26]
type OutlierDetection struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The number of consecutive server-side error responses (for HTTP traffic,
	// 5xx responses; for TCP traffic, connection failures; for Redis, failure to
	// respond PONG; etc.) before a consecutive 5xx ejection occurs. Defaults to 5.
	Consecutive_5Xx *wrapperspb.UInt32Value `protobuf:"bytes,1,opt,name=consecutive_5xx,json=consecutive5xx,proto3" json:"consecutive_5xx,omitempty"`
	// The time interval between ejection analysis sweeps. This can result in
	// both new ejections as well as hosts being returned to service. Defaults
	// to 10000ms or 10s.
	Interval *durationpb.Duration `protobuf:"bytes,2,opt,name=interval,proto3" json:"interval,omitempty"`
	// The base time that a host is ejected for. The real time is equal to the
	// base time multiplied by the number of times the host has been ejected and is
	// capped by :ref:`max_ejection_time<envoy_v3_api_field_config.cluster.v3.OutlierDetection.max_ejection_time>`.
	// Defaults to 30000ms or 30s.
	BaseEjectionTime *durationpb.Duration `protobuf:"bytes,3,opt,name=base_ejection_time,json=baseEjectionTime,proto3" json:"base_ejection_time,omitempty"`
	// The maximum % of an upstream cluster that can be ejected due to outlier detection. Defaults to 10% .
	// Will eject at least one host regardless of the value if :ref:`always_eject_one_host<envoy_v3_api_field_config.cluster.v3.OutlierDetection.always_eject_one_host>` is enabled.
	MaxEjectionPercent *wrapperspb.UInt32Value `protobuf:"bytes,4,opt,name=max_ejection_percent,json=maxEjectionPercent,proto3" json:"max_ejection_percent,omitempty"`
	// The % chance that a host will be actually ejected when an outlier status
	// is detected through consecutive 5xx. This setting can be used to disable
	// ejection or to ramp it up slowly. Defaults to 100.
	EnforcingConsecutive_5Xx *wrapperspb.UInt32Value `protobuf:"bytes,5,opt,name=enforcing_consecutive_5xx,json=enforcingConsecutive5xx,proto3" json:"enforcing_consecutive_5xx,omitempty"`
	// The % chance that a host will be actually ejected when an outlier status
	// is detected through success rate statistics. This setting can be used to
	// disable ejection or to ramp it up slowly. Defaults to 100.
	EnforcingSuccessRate *wrapperspb.UInt32Value `protobuf:"bytes,6,opt,name=enforcing_success_rate,json=enforcingSuccessRate,proto3" json:"enforcing_success_rate,omitempty"`
	// The number of hosts in a cluster that must have enough request volume to
	// detect success rate outliers. If the number of hosts is less than this
	// setting, outlier detection via success rate statistics is not performed
	// for any host in the cluster. Defaults to 5.
	SuccessRateMinimumHosts *wrapperspb.UInt32Value `protobuf:"bytes,7,opt,name=success_rate_minimum_hosts,json=successRateMinimumHosts,proto3" json:"success_rate_minimum_hosts,omitempty"`
	// The minimum number of total requests that must be collected in one
	// interval (as defined by the interval duration above) to include this host
	// in success rate based outlier detection. If the volume is lower than this
	// setting, outlier detection via success rate statistics is not performed
	// for that host. Defaults to 100.
	SuccessRateRequestVolume *wrapperspb.UInt32Value `protobuf:"bytes,8,opt,name=success_rate_request_volume,json=successRateRequestVolume,proto3" json:"success_rate_request_volume,omitempty"`
	// This factor is used to determine the ejection threshold for success rate
	// outlier ejection. The ejection threshold is the difference between the
	// mean success rate, and the product of this factor and the standard
	// deviation of the mean success rate: mean - (stdev *
	// success_rate_stdev_factor). This factor is divided by a thousand to get a
	// double. That is, if the desired factor is 1.9, the runtime value should
	// be 1900. Defaults to 1900.
	SuccessRateStdevFactor *wrapperspb.UInt32Value `protobuf:"bytes,9,opt,name=success_rate_stdev_factor,json=successRateStdevFactor,proto3" json:"success_rate_stdev_factor,omitempty"`
	// The number of consecutive gateway failures (502, 503, 504 status codes)
	// before a consecutive gateway failure ejection occurs. Defaults to 5.
	ConsecutiveGatewayFailure *wrapperspb.UInt32Value `protobuf:"bytes,10,opt,name=consecutive_gateway_failure,json=consecutiveGatewayFailure,proto3" json:"consecutive_gateway_failure,omitempty"`
	// The % chance that a host will be actually ejected when an outlier status
	// is detected through consecutive gateway failures. This setting can be
	// used to disable ejection or to ramp it up slowly. Defaults to 0.
	EnforcingConsecutiveGatewayFailure *wrapperspb.UInt32Value `protobuf:"bytes,11,opt,name=enforcing_consecutive_gateway_failure,json=enforcingConsecutiveGatewayFailure,proto3" json:"enforcing_consecutive_gateway_failure,omitempty"`
	// Determines whether to distinguish local origin failures from external errors. If set to true
	// the following configuration parameters are taken into account:
	// :ref:`consecutive_local_origin_failure<envoy_v3_api_field_config.cluster.v3.OutlierDetection.consecutive_local_origin_failure>`,
	// :ref:`enforcing_consecutive_local_origin_failure<envoy_v3_api_field_config.cluster.v3.OutlierDetection.enforcing_consecutive_local_origin_failure>`
	// and
	// :ref:`enforcing_local_origin_success_rate<envoy_v3_api_field_config.cluster.v3.OutlierDetection.enforcing_local_origin_success_rate>`.
	// Defaults to false.
	SplitExternalLocalOriginErrors bool `protobuf:"varint,12,opt,name=split_external_local_origin_errors,json=splitExternalLocalOriginErrors,proto3" json:"split_external_local_origin_errors,omitempty"`
	// The number of consecutive locally originated failures before ejection
	// occurs. Defaults to 5. Parameter takes effect only when
	// :ref:`split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
	// is set to true.
	ConsecutiveLocalOriginFailure *wrapperspb.UInt32Value `protobuf:"bytes,13,opt,name=consecutive_local_origin_failure,json=consecutiveLocalOriginFailure,proto3" json:"consecutive_local_origin_failure,omitempty"`
	// The % chance that a host will be actually ejected when an outlier status
	// is detected through consecutive locally originated failures. This setting can be
	// used to disable ejection or to ramp it up slowly. Defaults to 100.
	// Parameter takes effect only when
	// :ref:`split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
	// is set to true.
	EnforcingConsecutiveLocalOriginFailure *wrapperspb.UInt32Value `protobuf:"bytes,14,opt,name=enforcing_consecutive_local_origin_failure,json=enforcingConsecutiveLocalOriginFailure,proto3" json:"enforcing_consecutive_local_origin_failure,omitempty"`
	// The % chance that a host will be actually ejected when an outlier status
	// is detected through success rate statistics for locally originated errors.
	// This setting can be used to disable ejection or to ramp it up slowly. Defaults to 100.
	// Parameter takes effect only when
	// :ref:`split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
	// is set to true.
	EnforcingLocalOriginSuccessRate *wrapperspb.UInt32Value `protobuf:"bytes,15,opt,name=enforcing_local_origin_success_rate,json=enforcingLocalOriginSuccessRate,proto3" json:"enforcing_local_origin_success_rate,omitempty"`
	// The failure percentage to use when determining failure percentage-based outlier detection. If
	// the failure percentage of a given host is greater than or equal to this value, it will be
	// ejected. Defaults to 85.
	FailurePercentageThreshold *wrapperspb.UInt32Value `protobuf:"bytes,16,opt,name=failure_percentage_threshold,json=failurePercentageThreshold,proto3" json:"failure_percentage_threshold,omitempty"`
	// The % chance that a host will be actually ejected when an outlier status is detected through
	// failure percentage statistics. This setting can be used to disable ejection or to ramp it up
	// slowly. Defaults to 0.
	//
	// [#next-major-version: setting this without setting failure_percentage_threshold should be
	// invalid in v4.]
	EnforcingFailurePercentage *wrapperspb.UInt32Value `protobuf:"bytes,17,opt,name=enforcing_failure_percentage,json=enforcingFailurePercentage,proto3" json:"enforcing_failure_percentage,omitempty"`
	// The % chance that a host will be actually ejected when an outlier status is detected through
	// local-origin failure percentage statistics. This setting can be used to disable ejection or to
	// ramp it up slowly. Defaults to 0.
	EnforcingFailurePercentageLocalOrigin *wrapperspb.UInt32Value `protobuf:"bytes,18,opt,name=enforcing_failure_percentage_local_origin,json=enforcingFailurePercentageLocalOrigin,proto3" json:"enforcing_failure_percentage_local_origin,omitempty"`
	// The minimum number of hosts in a cluster in order to perform failure percentage-based ejection.
	// If the total number of hosts in the cluster is less than this value, failure percentage-based
	// ejection will not be performed. Defaults to 5.
	FailurePercentageMinimumHosts *wrapperspb.UInt32Value `protobuf:"bytes,19,opt,name=failure_percentage_minimum_hosts,json=failurePercentageMinimumHosts,proto3" json:"failure_percentage_minimum_hosts,omitempty"`
	// The minimum number of total requests that must be collected in one interval (as defined by the
	// interval duration above) to perform failure percentage-based ejection for this host. If the
	// volume is lower than this setting, failure percentage-based ejection will not be performed for
	// this host. Defaults to 50.
	FailurePercentageRequestVolume *wrapperspb.UInt32Value `protobuf:"bytes,20,opt,name=failure_percentage_request_volume,json=failurePercentageRequestVolume,proto3" json:"failure_percentage_request_volume,omitempty"`
	// The maximum time that a host is ejected for. See :ref:`base_ejection_time<envoy_v3_api_field_config.cluster.v3.OutlierDetection.base_ejection_time>`
	// for more information. If not specified, the default value (300000ms or 300s) or
	// :ref:`base_ejection_time<envoy_v3_api_field_config.cluster.v3.OutlierDetection.base_ejection_time>` value is applied, whatever is larger.
	MaxEjectionTime *durationpb.Duration `protobuf:"bytes,21,opt,name=max_ejection_time,json=maxEjectionTime,proto3" json:"max_ejection_time,omitempty"`
	// The maximum amount of jitter to add to the ejection time, in order to prevent
	// a 'thundering herd' effect where all proxies try to reconnect to host at the same time.
	// See :ref:`max_ejection_time_jitter<envoy_v3_api_field_config.cluster.v3.OutlierDetection.base_ejection_time>`
	// Defaults to 0s.
	MaxEjectionTimeJitter *durationpb.Duration `protobuf:"bytes,22,opt,name=max_ejection_time_jitter,json=maxEjectionTimeJitter,proto3" json:"max_ejection_time_jitter,omitempty"`
	// If active health checking is enabled and a host is ejected by outlier detection, a successful active health check
	// unejects the host by default and considers it as healthy. Unejection also clears all the outlier detection counters.
	// To change this default behavior set this config to “false“ where active health checking will not uneject the host.
	// Defaults to true.
	SuccessfulActiveHealthCheckUnejectHost *wrapperspb.BoolValue `protobuf:"bytes,23,opt,name=successful_active_health_check_uneject_host,json=successfulActiveHealthCheckUnejectHost,proto3" json:"successful_active_health_check_uneject_host,omitempty"`
	// Set of host's passive monitors.
	// [#not-implemented-hide:]
	Monitors []*v3.TypedExtensionConfig `protobuf:"bytes,24,rep,name=monitors,proto3" json:"monitors,omitempty"`
	// If enabled, at least one host is ejected regardless of the value of :ref:`max_ejection_percent<envoy_v3_api_field_config.cluster.v3.OutlierDetection.max_ejection_percent>`.
	// Defaults to false.
	AlwaysEjectOneHost *wrapperspb.BoolValue `protobuf:"bytes,25,opt,name=always_eject_one_host,json=alwaysEjectOneHost,proto3" json:"always_eject_one_host,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *OutlierDetection) Reset() {
	*x = OutlierDetection{}
	mi := &file_envoy_config_cluster_v3_outlier_detection_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OutlierDetection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OutlierDetection) ProtoMessage() {}

func (x *OutlierDetection) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_outlier_detection_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OutlierDetection.ProtoReflect.Descriptor instead.
func (*OutlierDetection) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_outlier_detection_proto_rawDescGZIP(), []int{0}
}

func (x *OutlierDetection) GetConsecutive_5Xx() *wrapperspb.UInt32Value {
	if x != nil {
		return x.Consecutive_5Xx
	}
	return nil
}

func (x *OutlierDetection) GetInterval() *durationpb.Duration {
	if x != nil {
		return x.Interval
	}
	return nil
}

func (x *OutlierDetection) GetBaseEjectionTime() *durationpb.Duration {
	if x != nil {
		return x.BaseEjectionTime
	}
	return nil
}

func (x *OutlierDetection) GetMaxEjectionPercent() *wrapperspb.UInt32Value {
	if x != nil {
		return x.MaxEjectionPercent
	}
	return nil
}

func (x *OutlierDetection) GetEnforcingConsecutive_5Xx() *wrapperspb.UInt32Value {
	if x != nil {
		return x.EnforcingConsecutive_5Xx
	}
	return nil
}

func (x *OutlierDetection) GetEnforcingSuccessRate() *wrapperspb.UInt32Value {
	if x != nil {
		return x.EnforcingSuccessRate
	}
	return nil
}

func (x *OutlierDetection) GetSuccessRateMinimumHosts() *wrapperspb.UInt32Value {
	if x != nil {
		return x.SuccessRateMinimumHosts
	}
	return nil
}

func (x *OutlierDetection) GetSuccessRateRequestVolume() *wrapperspb.UInt32Value {
	if x != nil {
		return x.SuccessRateRequestVolume
	}
	return nil
}

func (x *OutlierDetection) GetSuccessRateStdevFactor() *wrapperspb.UInt32Value {
	if x != nil {
		return x.SuccessRateStdevFactor
	}
	return nil
}

func (x *OutlierDetection) GetConsecutiveGatewayFailure() *wrapperspb.UInt32Value {
	if x != nil {
		return x.ConsecutiveGatewayFailure
	}
	return nil
}

func (x *OutlierDetection) GetEnforcingConsecutiveGatewayFailure() *wrapperspb.UInt32Value {
	if x != nil {
		return x.EnforcingConsecutiveGatewayFailure
	}
	return nil
}

func (x *OutlierDetection) GetSplitExternalLocalOriginErrors() bool {
	if x != nil {
		return x.SplitExternalLocalOriginErrors
	}
	return false
}

func (x *OutlierDetection) GetConsecutiveLocalOriginFailure() *wrapperspb.UInt32Value {
	if x != nil {
		return x.ConsecutiveLocalOriginFailure
	}
	return nil
}

func (x *OutlierDetection) GetEnforcingConsecutiveLocalOriginFailure() *wrapperspb.UInt32Value {
	if x != nil {
		return x.EnforcingConsecutiveLocalOriginFailure
	}
	return nil
}

func (x *OutlierDetection) GetEnforcingLocalOriginSuccessRate() *wrapperspb.UInt32Value {
	if x != nil {
		return x.EnforcingLocalOriginSuccessRate
	}
	return nil
}

func (x *OutlierDetection) GetFailurePercentageThreshold() *wrapperspb.UInt32Value {
	if x != nil {
		return x.FailurePercentageThreshold
	}
	return nil
}

func (x *OutlierDetection) GetEnforcingFailurePercentage() *wrapperspb.UInt32Value {
	if x != nil {
		return x.EnforcingFailurePercentage
	}
	return nil
}

func (x *OutlierDetection) GetEnforcingFailurePercentageLocalOrigin() *wrapperspb.UInt32Value {
	if x != nil {
		return x.EnforcingFailurePercentageLocalOrigin
	}
	return nil
}

func (x *OutlierDetection) GetFailurePercentageMinimumHosts() *wrapperspb.UInt32Value {
	if x != nil {
		return x.FailurePercentageMinimumHosts
	}
	return nil
}

func (x *OutlierDetection) GetFailurePercentageRequestVolume() *wrapperspb.UInt32Value {
	if x != nil {
		return x.FailurePercentageRequestVolume
	}
	return nil
}

func (x *OutlierDetection) GetMaxEjectionTime() *durationpb.Duration {
	if x != nil {
		return x.MaxEjectionTime
	}
	return nil
}

func (x *OutlierDetection) GetMaxEjectionTimeJitter() *durationpb.Duration {
	if x != nil {
		return x.MaxEjectionTimeJitter
	}
	return nil
}

func (x *OutlierDetection) GetSuccessfulActiveHealthCheckUnejectHost() *wrapperspb.BoolValue {
	if x != nil {
		return x.SuccessfulActiveHealthCheckUnejectHost
	}
	return nil
}

func (x *OutlierDetection) GetMonitors() []*v3.TypedExtensionConfig {
	if x != nil {
		return x.Monitors
	}
	return nil
}

func (x *OutlierDetection) GetAlwaysEjectOneHost() *wrapperspb.BoolValue {
	if x != nil {
		return x.AlwaysEjectOneHost
	}
	return nil
}

var File_envoy_config_cluster_v3_outlier_detection_proto protoreflect.FileDescriptor

const file_envoy_config_cluster_v3_outlier_detection_proto_rawDesc = "" +
	"\n" +
	"/envoy/config/cluster/v3/outlier_detection.proto\x12\x17envoy.config.cluster.v3\x1a$envoy/config/core/v3/extension.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1egoogle/protobuf/wrappers.proto\x1a\x1dudpa/annotations/status.proto\x1a!udpa/annotations/versioning.proto\x1a\x17validate/validate.proto\"\xa1\x13\n" +
	"\x10OutlierDetection\x12E\n" +
	"\x0fconsecutive_5xx\x18\x01 \x01(\v2\x1c.google.protobuf.UInt32ValueR\x0econsecutive5xx\x12?\n" +
	"\binterval\x18\x02 \x01(\v2\x19.google.protobuf.DurationB\b\xfaB\x05\xaa\x01\x02*\x00R\binterval\x12Q\n" +
	"\x12base_ejection_time\x18\x03 \x01(\v2\x19.google.protobuf.DurationB\b\xfaB\x05\xaa\x01\x02*\x00R\x10baseEjectionTime\x12W\n" +
	"\x14max_ejection_percent\x18\x04 \x01(\v2\x1c.google.protobuf.UInt32ValueB\a\xfaB\x04*\x02\x18dR\x12maxEjectionPercent\x12a\n" +
	"\x19enforcing_consecutive_5xx\x18\x05 \x01(\v2\x1c.google.protobuf.UInt32ValueB\a\xfaB\x04*\x02\x18dR\x17enforcingConsecutive5xx\x12[\n" +
	"\x16enforcing_success_rate\x18\x06 \x01(\v2\x1c.google.protobuf.UInt32ValueB\a\xfaB\x04*\x02\x18dR\x14enforcingSuccessRate\x12Y\n" +
	"\x1asuccess_rate_minimum_hosts\x18\a \x01(\v2\x1c.google.protobuf.UInt32ValueR\x17successRateMinimumHosts\x12[\n" +
	"\x1bsuccess_rate_request_volume\x18\b \x01(\v2\x1c.google.protobuf.UInt32ValueR\x18successRateRequestVolume\x12W\n" +
	"\x19success_rate_stdev_factor\x18\t \x01(\v2\x1c.google.protobuf.UInt32ValueR\x16successRateStdevFactor\x12\\\n" +
	"\x1bconsecutive_gateway_failure\x18\n" +
	" \x01(\v2\x1c.google.protobuf.UInt32ValueR\x19consecutiveGatewayFailure\x12x\n" +
	"%enforcing_consecutive_gateway_failure\x18\v \x01(\v2\x1c.google.protobuf.UInt32ValueB\a\xfaB\x04*\x02\x18dR\"enforcingConsecutiveGatewayFailure\x12J\n" +
	"\"split_external_local_origin_errors\x18\f \x01(\bR\x1esplitExternalLocalOriginErrors\x12e\n" +
	" consecutive_local_origin_failure\x18\r \x01(\v2\x1c.google.protobuf.UInt32ValueR\x1dconsecutiveLocalOriginFailure\x12\x81\x01\n" +
	"*enforcing_consecutive_local_origin_failure\x18\x0e \x01(\v2\x1c.google.protobuf.UInt32ValueB\a\xfaB\x04*\x02\x18dR&enforcingConsecutiveLocalOriginFailure\x12s\n" +
	"#enforcing_local_origin_success_rate\x18\x0f \x01(\v2\x1c.google.protobuf.UInt32ValueB\a\xfaB\x04*\x02\x18dR\x1fenforcingLocalOriginSuccessRate\x12g\n" +
	"\x1cfailure_percentage_threshold\x18\x10 \x01(\v2\x1c.google.protobuf.UInt32ValueB\a\xfaB\x04*\x02\x18dR\x1afailurePercentageThreshold\x12g\n" +
	"\x1cenforcing_failure_percentage\x18\x11 \x01(\v2\x1c.google.protobuf.UInt32ValueB\a\xfaB\x04*\x02\x18dR\x1aenforcingFailurePercentage\x12\x7f\n" +
	")enforcing_failure_percentage_local_origin\x18\x12 \x01(\v2\x1c.google.protobuf.UInt32ValueB\a\xfaB\x04*\x02\x18dR%enforcingFailurePercentageLocalOrigin\x12e\n" +
	" failure_percentage_minimum_hosts\x18\x13 \x01(\v2\x1c.google.protobuf.UInt32ValueR\x1dfailurePercentageMinimumHosts\x12g\n" +
	"!failure_percentage_request_volume\x18\x14 \x01(\v2\x1c.google.protobuf.UInt32ValueR\x1efailurePercentageRequestVolume\x12O\n" +
	"\x11max_ejection_time\x18\x15 \x01(\v2\x19.google.protobuf.DurationB\b\xfaB\x05\xaa\x01\x02*\x00R\x0fmaxEjectionTime\x12R\n" +
	"\x18max_ejection_time_jitter\x18\x16 \x01(\v2\x19.google.protobuf.DurationR\x15maxEjectionTimeJitter\x12w\n" +
	"+successful_active_health_check_uneject_host\x18\x17 \x01(\v2\x1a.google.protobuf.BoolValueR&successfulActiveHealthCheckUnejectHost\x12F\n" +
	"\bmonitors\x18\x18 \x03(\v2*.envoy.config.core.v3.TypedExtensionConfigR\bmonitors\x12M\n" +
	"\x15always_eject_one_host\x18\x19 \x01(\v2\x1a.google.protobuf.BoolValueR\x12alwaysEjectOneHost:,\x9aň\x1e'\n" +
	"%envoy.api.v2.cluster.OutlierDetectionB\x92\x01\xba\x80\xc8\xd1\x06\x02\x10\x02\n" +
	"%io.envoyproxy.envoy.config.cluster.v3B\x15OutlierDetectionProtoP\x01ZHgithub.com/envoyproxy/go-control-plane/envoy/config/cluster/v3;clusterv3b\x06proto3"

var (
	file_envoy_config_cluster_v3_outlier_detection_proto_rawDescOnce sync.Once
	file_envoy_config_cluster_v3_outlier_detection_proto_rawDescData []byte
)

func file_envoy_config_cluster_v3_outlier_detection_proto_rawDescGZIP() []byte {
	file_envoy_config_cluster_v3_outlier_detection_proto_rawDescOnce.Do(func() {
		file_envoy_config_cluster_v3_outlier_detection_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_envoy_config_cluster_v3_outlier_detection_proto_rawDesc), len(file_envoy_config_cluster_v3_outlier_detection_proto_rawDesc)))
	})
	return file_envoy_config_cluster_v3_outlier_detection_proto_rawDescData
}

var file_envoy_config_cluster_v3_outlier_detection_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_envoy_config_cluster_v3_outlier_detection_proto_goTypes = []any{
	(*OutlierDetection)(nil),        // 0: envoy.config.cluster.v3.OutlierDetection
	(*wrapperspb.UInt32Value)(nil),  // 1: google.protobuf.UInt32Value
	(*durationpb.Duration)(nil),     // 2: google.protobuf.Duration
	(*wrapperspb.BoolValue)(nil),    // 3: google.protobuf.BoolValue
	(*v3.TypedExtensionConfig)(nil), // 4: envoy.config.core.v3.TypedExtensionConfig
}
var file_envoy_config_cluster_v3_outlier_detection_proto_depIdxs = []int32{
	1,  // 0: envoy.config.cluster.v3.OutlierDetection.consecutive_5xx:type_name -> google.protobuf.UInt32Value
	2,  // 1: envoy.config.cluster.v3.OutlierDetection.interval:type_name -> google.protobuf.Duration
	2,  // 2: envoy.config.cluster.v3.OutlierDetection.base_ejection_time:type_name -> google.protobuf.Duration
	1,  // 3: envoy.config.cluster.v3.OutlierDetection.max_ejection_percent:type_name -> google.protobuf.UInt32Value
	1,  // 4: envoy.config.cluster.v3.OutlierDetection.enforcing_consecutive_5xx:type_name -> google.protobuf.UInt32Value
	1,  // 5: envoy.config.cluster.v3.OutlierDetection.enforcing_success_rate:type_name -> google.protobuf.UInt32Value
	1,  // 6: envoy.config.cluster.v3.OutlierDetection.success_rate_minimum_hosts:type_name -> google.protobuf.UInt32Value
	1,  // 7: envoy.config.cluster.v3.OutlierDetection.success_rate_request_volume:type_name -> google.protobuf.UInt32Value
	1,  // 8: envoy.config.cluster.v3.OutlierDetection.success_rate_stdev_factor:type_name -> google.protobuf.UInt32Value
	1,  // 9: envoy.config.cluster.v3.OutlierDetection.consecutive_gateway_failure:type_name -> google.protobuf.UInt32Value
	1,  // 10: envoy.config.cluster.v3.OutlierDetection.enforcing_consecutive_gateway_failure:type_name -> google.protobuf.UInt32Value
	1,  // 11: envoy.config.cluster.v3.OutlierDetection.consecutive_local_origin_failure:type_name -> google.protobuf.UInt32Value
	1,  // 12: envoy.config.cluster.v3.OutlierDetection.enforcing_consecutive_local_origin_failure:type_name -> google.protobuf.UInt32Value
	1,  // 13: envoy.config.cluster.v3.OutlierDetection.enforcing_local_origin_success_rate:type_name -> google.protobuf.UInt32Value
	1,  // 14: envoy.config.cluster.v3.OutlierDetection.failure_percentage_threshold:type_name -> google.protobuf.UInt32Value
	1,  // 15: envoy.config.cluster.v3.OutlierDetection.enforcing_failure_percentage:type_name -> google.protobuf.UInt32Value
	1,  // 16: envoy.config.cluster.v3.OutlierDetection.enforcing_failure_percentage_local_origin:type_name -> google.protobuf.UInt32Value
	1,  // 17: envoy.config.cluster.v3.OutlierDetection.failure_percentage_minimum_hosts:type_name -> google.protobuf.UInt32Value
	1,  // 18: envoy.config.cluster.v3.OutlierDetection.failure_percentage_request_volume:type_name -> google.protobuf.UInt32Value
	2,  // 19: envoy.config.cluster.v3.OutlierDetection.max_ejection_time:type_name -> google.protobuf.Duration
	2,  // 20: envoy.config.cluster.v3.OutlierDetection.max_ejection_time_jitter:type_name -> google.protobuf.Duration
	3,  // 21: envoy.config.cluster.v3.OutlierDetection.successful_active_health_check_uneject_host:type_name -> google.protobuf.BoolValue
	4,  // 22: envoy.config.cluster.v3.OutlierDetection.monitors:type_name -> envoy.config.core.v3.TypedExtensionConfig
	3,  // 23: envoy.config.cluster.v3.OutlierDetection.always_eject_one_host:type_name -> google.protobuf.BoolValue
	24, // [24:24] is the sub-list for method output_type
	24, // [24:24] is the sub-list for method input_type
	24, // [24:24] is the sub-list for extension type_name
	24, // [24:24] is the sub-list for extension extendee
	0,  // [0:24] is the sub-list for field type_name
}

func init() { file_envoy_config_cluster_v3_outlier_detection_proto_init() }
func file_envoy_config_cluster_v3_outlier_detection_proto_init() {
	if File_envoy_config_cluster_v3_outlier_detection_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_envoy_config_cluster_v3_outlier_detection_proto_rawDesc), len(file_envoy_config_cluster_v3_outlier_detection_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   1,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_envoy_config_cluster_v3_outlier_detection_proto_goTypes,
		DependencyIndexes: file_envoy_config_cluster_v3_outlier_detection_proto_depIdxs,
		MessageInfos:      file_envoy_config_cluster_v3_outlier_detection_proto_msgTypes,
	}.Build()
	File_envoy_config_cluster_v3_outlier_detection_proto = out.File
	file_envoy_config_cluster_v3_outlier_detection_proto_goTypes = nil
	file_envoy_config_cluster_v3_outlier_detection_proto_depIdxs = nil
}
