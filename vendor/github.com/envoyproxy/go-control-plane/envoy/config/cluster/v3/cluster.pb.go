// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v6.33.2
// source: envoy/config/cluster/v3/cluster.proto

package clusterv3

import (
	_ "github.com/cncf/xds/go/udpa/annotations"
	v3 "github.com/cncf/xds/go/xds/core/v3"
	v31 "github.com/cncf/xds/go/xds/type/matcher/v3"
	_ "github.com/envoyproxy/go-control-plane/envoy/annotations"
	v33 "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
	v32 "github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3"
	v35 "github.com/envoyproxy/go-control-plane/envoy/type/metadata/v3"
	v34 "github.com/envoyproxy/go-control-plane/envoy/type/v3"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	anypb "google.golang.org/protobuf/types/known/anypb"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Refer to :ref:`service discovery type <arch_overview_service_discovery_types>`
// for an explanation on each type.
type Cluster_DiscoveryType int32

const (
	// Refer to the :ref:`static discovery type<arch_overview_service_discovery_types_static>`
	// for an explanation.
	Cluster_STATIC Cluster_DiscoveryType = 0
	// Refer to the :ref:`strict DNS discovery
	// type<arch_overview_service_discovery_types_strict_dns>`
	// for an explanation.
	Cluster_STRICT_DNS Cluster_DiscoveryType = 1
	// Refer to the :ref:`logical DNS discovery
	// type<arch_overview_service_discovery_types_logical_dns>`
	// for an explanation.
	Cluster_LOGICAL_DNS Cluster_DiscoveryType = 2
	// Refer to the :ref:`service discovery type<arch_overview_service_discovery_types_eds>`
	// for an explanation.
	Cluster_EDS Cluster_DiscoveryType = 3
	// Refer to the :ref:`original destination discovery
	// type<arch_overview_service_discovery_types_original_destination>`
	// for an explanation.
	Cluster_ORIGINAL_DST Cluster_DiscoveryType = 4
)

// Enum value maps for Cluster_DiscoveryType.
var (
	Cluster_DiscoveryType_name = map[int32]string{
		0: "STATIC",
		1: "STRICT_DNS",
		2: "LOGICAL_DNS",
		3: "EDS",
		4: "ORIGINAL_DST",
	}
	Cluster_DiscoveryType_value = map[string]int32{
		"STATIC":       0,
		"STRICT_DNS":   1,
		"LOGICAL_DNS":  2,
		"EDS":          3,
		"ORIGINAL_DST": 4,
	}
)

func (x Cluster_DiscoveryType) Enum() *Cluster_DiscoveryType {
	p := new(Cluster_DiscoveryType)
	*p = x
	return p
}

func (x Cluster_DiscoveryType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Cluster_DiscoveryType) Descriptor() protoreflect.EnumDescriptor {
	return file_envoy_config_cluster_v3_cluster_proto_enumTypes[0].Descriptor()
}

func (Cluster_DiscoveryType) Type() protoreflect.EnumType {
	return &file_envoy_config_cluster_v3_cluster_proto_enumTypes[0]
}

func (x Cluster_DiscoveryType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Cluster_DiscoveryType.Descriptor instead.
func (Cluster_DiscoveryType) EnumDescriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 0}
}

// Refer to :ref:`load balancer type <arch_overview_load_balancing_types>` architecture
// overview section for information on each type.
type Cluster_LbPolicy int32

const (
	// Refer to the :ref:`round robin load balancing
	// policy<arch_overview_load_balancing_types_round_robin>`
	// for an explanation.
	Cluster_ROUND_ROBIN Cluster_LbPolicy = 0
	// Refer to the :ref:`least request load balancing
	// policy<arch_overview_load_balancing_types_least_request>`
	// for an explanation.
	Cluster_LEAST_REQUEST Cluster_LbPolicy = 1
	// Refer to the :ref:`ring hash load balancing
	// policy<arch_overview_load_balancing_types_ring_hash>`
	// for an explanation.
	Cluster_RING_HASH Cluster_LbPolicy = 2
	// Refer to the :ref:`random load balancing
	// policy<arch_overview_load_balancing_types_random>`
	// for an explanation.
	Cluster_RANDOM Cluster_LbPolicy = 3
	// Refer to the :ref:`Maglev load balancing policy<arch_overview_load_balancing_types_maglev>`
	// for an explanation.
	Cluster_MAGLEV Cluster_LbPolicy = 5
	// This load balancer type must be specified if the configured cluster provides a cluster
	// specific load balancer. Consult the configured cluster's documentation for whether to set
	// this option or not.
	Cluster_CLUSTER_PROVIDED Cluster_LbPolicy = 6
	// Use the new :ref:`load_balancing_policy
	// <envoy_v3_api_field_config.cluster.v3.Cluster.load_balancing_policy>` field to determine the LB policy.
	// This has been deprecated in favor of using the :ref:`load_balancing_policy
	// <envoy_v3_api_field_config.cluster.v3.Cluster.load_balancing_policy>` field without
	// setting any value in :ref:`lb_policy<envoy_v3_api_field_config.cluster.v3.Cluster.lb_policy>`.
	Cluster_LOAD_BALANCING_POLICY_CONFIG Cluster_LbPolicy = 7
)

// Enum value maps for Cluster_LbPolicy.
var (
	Cluster_LbPolicy_name = map[int32]string{
		0: "ROUND_ROBIN",
		1: "LEAST_REQUEST",
		2: "RING_HASH",
		3: "RANDOM",
		5: "MAGLEV",
		6: "CLUSTER_PROVIDED",
		7: "LOAD_BALANCING_POLICY_CONFIG",
	}
	Cluster_LbPolicy_value = map[string]int32{
		"ROUND_ROBIN":                  0,
		"LEAST_REQUEST":                1,
		"RING_HASH":                    2,
		"RANDOM":                       3,
		"MAGLEV":                       5,
		"CLUSTER_PROVIDED":             6,
		"LOAD_BALANCING_POLICY_CONFIG": 7,
	}
)

func (x Cluster_LbPolicy) Enum() *Cluster_LbPolicy {
	p := new(Cluster_LbPolicy)
	*p = x
	return p
}

func (x Cluster_LbPolicy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Cluster_LbPolicy) Descriptor() protoreflect.EnumDescriptor {
	return file_envoy_config_cluster_v3_cluster_proto_enumTypes[1].Descriptor()
}

func (Cluster_LbPolicy) Type() protoreflect.EnumType {
	return &file_envoy_config_cluster_v3_cluster_proto_enumTypes[1]
}

func (x Cluster_LbPolicy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Cluster_LbPolicy.Descriptor instead.
func (Cluster_LbPolicy) EnumDescriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 1}
}

// When V4_ONLY is selected, the DNS resolver will only perform a lookup for
// addresses in the IPv4 family. If V6_ONLY is selected, the DNS resolver will
// only perform a lookup for addresses in the IPv6 family. If AUTO is
// specified, the DNS resolver will first perform a lookup for addresses in
// the IPv6 family and fallback to a lookup for addresses in the IPv4 family.
// This is semantically equivalent to a non-existent V6_PREFERRED option.
// AUTO is a legacy name that is more opaque than
// necessary and will be deprecated in favor of V6_PREFERRED in a future major version of the API.
// If V4_PREFERRED is specified, the DNS resolver will first perform a lookup for addresses in the
// IPv4 family and fallback to a lookup for addresses in the IPv6 family. i.e., the callback
// target will only get v6 addresses if there were NO v4 addresses to return.
// If ALL is specified, the DNS resolver will perform a lookup for both IPv4 and IPv6 families,
// and return all resolved addresses. When this is used, Happy Eyeballs will be enabled for
// upstream connections. Refer to :ref:`Happy Eyeballs Support <arch_overview_happy_eyeballs>`
// for more information.
// For cluster types other than
// :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>` and
// :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
// this setting is
// ignored.
// [#next-major-version: deprecate AUTO in favor of a V6_PREFERRED option.]
type Cluster_DnsLookupFamily int32

const (
	Cluster_AUTO         Cluster_DnsLookupFamily = 0
	Cluster_V4_ONLY      Cluster_DnsLookupFamily = 1
	Cluster_V6_ONLY      Cluster_DnsLookupFamily = 2
	Cluster_V4_PREFERRED Cluster_DnsLookupFamily = 3
	Cluster_ALL          Cluster_DnsLookupFamily = 4
)

// Enum value maps for Cluster_DnsLookupFamily.
var (
	Cluster_DnsLookupFamily_name = map[int32]string{
		0: "AUTO",
		1: "V4_ONLY",
		2: "V6_ONLY",
		3: "V4_PREFERRED",
		4: "ALL",
	}
	Cluster_DnsLookupFamily_value = map[string]int32{
		"AUTO":         0,
		"V4_ONLY":      1,
		"V6_ONLY":      2,
		"V4_PREFERRED": 3,
		"ALL":          4,
	}
)

func (x Cluster_DnsLookupFamily) Enum() *Cluster_DnsLookupFamily {
	p := new(Cluster_DnsLookupFamily)
	*p = x
	return p
}

func (x Cluster_DnsLookupFamily) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Cluster_DnsLookupFamily) Descriptor() protoreflect.EnumDescriptor {
	return file_envoy_config_cluster_v3_cluster_proto_enumTypes[2].Descriptor()
}

func (Cluster_DnsLookupFamily) Type() protoreflect.EnumType {
	return &file_envoy_config_cluster_v3_cluster_proto_enumTypes[2]
}

func (x Cluster_DnsLookupFamily) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Cluster_DnsLookupFamily.Descriptor instead.
func (Cluster_DnsLookupFamily) EnumDescriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 2}
}

type Cluster_ClusterProtocolSelection int32

const (
	// Cluster can only operate on one of the possible upstream protocols (HTTP1.1, HTTP2).
	// If :ref:`http2_protocol_options <envoy_v3_api_field_config.cluster.v3.Cluster.http2_protocol_options>` are
	// present, HTTP2 will be used, otherwise HTTP1.1 will be used.
	Cluster_USE_CONFIGURED_PROTOCOL Cluster_ClusterProtocolSelection = 0
	// Use HTTP1.1 or HTTP2, depending on which one is used on the downstream connection.
	Cluster_USE_DOWNSTREAM_PROTOCOL Cluster_ClusterProtocolSelection = 1
)

// Enum value maps for Cluster_ClusterProtocolSelection.
var (
	Cluster_ClusterProtocolSelection_name = map[int32]string{
		0: "USE_CONFIGURED_PROTOCOL",
		1: "USE_DOWNSTREAM_PROTOCOL",
	}
	Cluster_ClusterProtocolSelection_value = map[string]int32{
		"USE_CONFIGURED_PROTOCOL": 0,
		"USE_DOWNSTREAM_PROTOCOL": 1,
	}
)

func (x Cluster_ClusterProtocolSelection) Enum() *Cluster_ClusterProtocolSelection {
	p := new(Cluster_ClusterProtocolSelection)
	*p = x
	return p
}

func (x Cluster_ClusterProtocolSelection) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Cluster_ClusterProtocolSelection) Descriptor() protoreflect.EnumDescriptor {
	return file_envoy_config_cluster_v3_cluster_proto_enumTypes[3].Descriptor()
}

func (Cluster_ClusterProtocolSelection) Type() protoreflect.EnumType {
	return &file_envoy_config_cluster_v3_cluster_proto_enumTypes[3]
}

func (x Cluster_ClusterProtocolSelection) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Cluster_ClusterProtocolSelection.Descriptor instead.
func (Cluster_ClusterProtocolSelection) EnumDescriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 3}
}

// If NO_FALLBACK is selected, a result
// equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
// any cluster endpoint may be returned (subject to policy, health checks,
// etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
// endpoints matching the values from the default_subset field.
type Cluster_LbSubsetConfig_LbSubsetFallbackPolicy int32

const (
	Cluster_LbSubsetConfig_NO_FALLBACK    Cluster_LbSubsetConfig_LbSubsetFallbackPolicy = 0
	Cluster_LbSubsetConfig_ANY_ENDPOINT   Cluster_LbSubsetConfig_LbSubsetFallbackPolicy = 1
	Cluster_LbSubsetConfig_DEFAULT_SUBSET Cluster_LbSubsetConfig_LbSubsetFallbackPolicy = 2
)

// Enum value maps for Cluster_LbSubsetConfig_LbSubsetFallbackPolicy.
var (
	Cluster_LbSubsetConfig_LbSubsetFallbackPolicy_name = map[int32]string{
		0: "NO_FALLBACK",
		1: "ANY_ENDPOINT",
		2: "DEFAULT_SUBSET",
	}
	Cluster_LbSubsetConfig_LbSubsetFallbackPolicy_value = map[string]int32{
		"NO_FALLBACK":    0,
		"ANY_ENDPOINT":   1,
		"DEFAULT_SUBSET": 2,
	}
)

func (x Cluster_LbSubsetConfig_LbSubsetFallbackPolicy) Enum() *Cluster_LbSubsetConfig_LbSubsetFallbackPolicy {
	p := new(Cluster_LbSubsetConfig_LbSubsetFallbackPolicy)
	*p = x
	return p
}

func (x Cluster_LbSubsetConfig_LbSubsetFallbackPolicy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Cluster_LbSubsetConfig_LbSubsetFallbackPolicy) Descriptor() protoreflect.EnumDescriptor {
	return file_envoy_config_cluster_v3_cluster_proto_enumTypes[4].Descriptor()
}

func (Cluster_LbSubsetConfig_LbSubsetFallbackPolicy) Type() protoreflect.EnumType {
	return &file_envoy_config_cluster_v3_cluster_proto_enumTypes[4]
}

func (x Cluster_LbSubsetConfig_LbSubsetFallbackPolicy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Cluster_LbSubsetConfig_LbSubsetFallbackPolicy.Descriptor instead.
func (Cluster_LbSubsetConfig_LbSubsetFallbackPolicy) EnumDescriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 3, 0}
}

type Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy int32

const (
	// No fallback. Route metadata will be used as-is.
	Cluster_LbSubsetConfig_METADATA_NO_FALLBACK Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy = 0
	// A special metadata key “fallback_list“ will be used to provide variants of metadata to try.
	// Value of “fallback_list“ key has to be a list. Every list element has to be a struct - it will
	// be merged with route metadata, overriding keys that appear in both places.
	// “fallback_list“ entries will be used in order until a host is found.
	//
	// “fallback_list“ key itself is removed from metadata before subset load balancing is performed.
	//
	// Example:
	//
	// for metadata:
	//
	// .. code-block:: yaml
	//
	//	version: 1.0
	//	fallback_list:
	//	  - version: 2.0
	//	    hardware: c64
	//	  - hardware: c32
	//	  - version: 3.0
	//
	// at first, metadata:
	//
	// .. code-block:: json
	//
	//	{"version": "2.0", "hardware": "c64"}
	//
	// will be used for load balancing. If no host is found, metadata:
	//
	// .. code-block:: json
	//
	//	{"version": "1.0", "hardware": "c32"}
	//
	// is next to try. If it still results in no host, finally metadata:
	//
	// .. code-block:: json
	//
	//	{"version": "3.0"}
	//
	// is used.
	Cluster_LbSubsetConfig_FALLBACK_LIST Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy = 1
)

// Enum value maps for Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy.
var (
	Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy_name = map[int32]string{
		0: "METADATA_NO_FALLBACK",
		1: "FALLBACK_LIST",
	}
	Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy_value = map[string]int32{
		"METADATA_NO_FALLBACK": 0,
		"FALLBACK_LIST":        1,
	}
)

func (x Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy) Enum() *Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy {
	p := new(Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy)
	*p = x
	return p
}

func (x Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy) Descriptor() protoreflect.EnumDescriptor {
	return file_envoy_config_cluster_v3_cluster_proto_enumTypes[5].Descriptor()
}

func (Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy) Type() protoreflect.EnumType {
	return &file_envoy_config_cluster_v3_cluster_proto_enumTypes[5]
}

func (x Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy.Descriptor instead.
func (Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy) EnumDescriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 3, 1}
}

// Allows to override top level fallback policy per selector.
type Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy int32

const (
	// If NOT_DEFINED top level config fallback policy is used instead.
	Cluster_LbSubsetConfig_LbSubsetSelector_NOT_DEFINED Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy = 0
	// If NO_FALLBACK is selected, a result equivalent to no healthy hosts is reported.
	Cluster_LbSubsetConfig_LbSubsetSelector_NO_FALLBACK Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy = 1
	// If ANY_ENDPOINT is selected, any cluster endpoint may be returned
	// (subject to policy, health checks, etc).
	Cluster_LbSubsetConfig_LbSubsetSelector_ANY_ENDPOINT Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy = 2
	// If DEFAULT_SUBSET is selected, load balancing is performed over the
	// endpoints matching the values from the default_subset field.
	Cluster_LbSubsetConfig_LbSubsetSelector_DEFAULT_SUBSET Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy = 3
	// If KEYS_SUBSET is selected, subset selector matching is performed again with metadata
	// keys reduced to
	// :ref:`fallback_keys_subset<envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.fallback_keys_subset>`.
	// It allows for a fallback to a different, less specific selector if some of the keys of
	// the selector are considered optional.
	Cluster_LbSubsetConfig_LbSubsetSelector_KEYS_SUBSET Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy = 4
)

// Enum value maps for Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.
var (
	Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy_name = map[int32]string{
		0: "NOT_DEFINED",
		1: "NO_FALLBACK",
		2: "ANY_ENDPOINT",
		3: "DEFAULT_SUBSET",
		4: "KEYS_SUBSET",
	}
	Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy_value = map[string]int32{
		"NOT_DEFINED":    0,
		"NO_FALLBACK":    1,
		"ANY_ENDPOINT":   2,
		"DEFAULT_SUBSET": 3,
		"KEYS_SUBSET":    4,
	}
)

func (x Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy) Enum() *Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy {
	p := new(Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy)
	*p = x
	return p
}

func (x Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy) Descriptor() protoreflect.EnumDescriptor {
	return file_envoy_config_cluster_v3_cluster_proto_enumTypes[6].Descriptor()
}

func (Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy) Type() protoreflect.EnumType {
	return &file_envoy_config_cluster_v3_cluster_proto_enumTypes[6]
}

func (x Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy.Descriptor instead.
func (Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy) EnumDescriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 3, 0, 0}
}

// The hash function used to hash hosts onto the ketama ring.
type Cluster_RingHashLbConfig_HashFunction int32

const (
	// Use `xxHash <https://github.com/Cyan4973/xxHash>`_, this is the default hash function.
	Cluster_RingHashLbConfig_XX_HASH Cluster_RingHashLbConfig_HashFunction = 0
	// Use `MurmurHash2 <https://sites.google.com/site/murmurhash/>`_, this is compatible with
	// std:hash<string> in GNU libstdc++ 3.4.20 or above. This is typically the case when compiled
	// on Linux and not macOS.
	Cluster_RingHashLbConfig_MURMUR_HASH_2 Cluster_RingHashLbConfig_HashFunction = 1
)

// Enum value maps for Cluster_RingHashLbConfig_HashFunction.
var (
	Cluster_RingHashLbConfig_HashFunction_name = map[int32]string{
		0: "XX_HASH",
		1: "MURMUR_HASH_2",
	}
	Cluster_RingHashLbConfig_HashFunction_value = map[string]int32{
		"XX_HASH":       0,
		"MURMUR_HASH_2": 1,
	}
)

func (x Cluster_RingHashLbConfig_HashFunction) Enum() *Cluster_RingHashLbConfig_HashFunction {
	p := new(Cluster_RingHashLbConfig_HashFunction)
	*p = x
	return p
}

func (x Cluster_RingHashLbConfig_HashFunction) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Cluster_RingHashLbConfig_HashFunction) Descriptor() protoreflect.EnumDescriptor {
	return file_envoy_config_cluster_v3_cluster_proto_enumTypes[7].Descriptor()
}

func (Cluster_RingHashLbConfig_HashFunction) Type() protoreflect.EnumType {
	return &file_envoy_config_cluster_v3_cluster_proto_enumTypes[7]
}

func (x Cluster_RingHashLbConfig_HashFunction) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Cluster_RingHashLbConfig_HashFunction.Descriptor instead.
func (Cluster_RingHashLbConfig_HashFunction) EnumDescriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 7, 0}
}

type UpstreamConnectionOptions_FirstAddressFamilyVersion int32

const (
	// respect the native ranking of destination ip addresses returned from dns
	// resolution
	UpstreamConnectionOptions_DEFAULT UpstreamConnectionOptions_FirstAddressFamilyVersion = 0
	UpstreamConnectionOptions_V4      UpstreamConnectionOptions_FirstAddressFamilyVersion = 1
	UpstreamConnectionOptions_V6      UpstreamConnectionOptions_FirstAddressFamilyVersion = 2
)

// Enum value maps for UpstreamConnectionOptions_FirstAddressFamilyVersion.
var (
	UpstreamConnectionOptions_FirstAddressFamilyVersion_name = map[int32]string{
		0: "DEFAULT",
		1: "V4",
		2: "V6",
	}
	UpstreamConnectionOptions_FirstAddressFamilyVersion_value = map[string]int32{
		"DEFAULT": 0,
		"V4":      1,
		"V6":      2,
	}
)

func (x UpstreamConnectionOptions_FirstAddressFamilyVersion) Enum() *UpstreamConnectionOptions_FirstAddressFamilyVersion {
	p := new(UpstreamConnectionOptions_FirstAddressFamilyVersion)
	*p = x
	return p
}

func (x UpstreamConnectionOptions_FirstAddressFamilyVersion) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (UpstreamConnectionOptions_FirstAddressFamilyVersion) Descriptor() protoreflect.EnumDescriptor {
	return file_envoy_config_cluster_v3_cluster_proto_enumTypes[8].Descriptor()
}

func (UpstreamConnectionOptions_FirstAddressFamilyVersion) Type() protoreflect.EnumType {
	return &file_envoy_config_cluster_v3_cluster_proto_enumTypes[8]
}

func (x UpstreamConnectionOptions_FirstAddressFamilyVersion) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use UpstreamConnectionOptions_FirstAddressFamilyVersion.Descriptor instead.
func (UpstreamConnectionOptions_FirstAddressFamilyVersion) EnumDescriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{3, 0}
}

// Cluster list collections. Entries are “Cluster“ resources or references.
// [#not-implemented-hide:]
type ClusterCollection struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Entries       *v3.CollectionEntry    `protobuf:"bytes,1,opt,name=entries,proto3" json:"entries,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClusterCollection) Reset() {
	*x = ClusterCollection{}
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClusterCollection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClusterCollection) ProtoMessage() {}

func (x *ClusterCollection) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClusterCollection.ProtoReflect.Descriptor instead.
func (*ClusterCollection) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{0}
}

func (x *ClusterCollection) GetEntries() *v3.CollectionEntry {
	if x != nil {
		return x.Entries
	}
	return nil
}

// Configuration for a single upstream cluster.
// [#next-free-field: 60]
type Cluster struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Configuration to use different transport sockets for different endpoints. The entry of
	// “envoy.transport_socket_match“ in the :ref:`LbEndpoint.Metadata
	// <envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata>` is used to match against the
	// transport sockets as they appear in the list. If a match is not found, the search continues in
	// :ref:`LocalityLbEndpoints.Metadata
	// <envoy_v3_api_field_config.endpoint.v3.LocalityLbEndpoints.metadata>`. The first :ref:`match
	// <envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>` is used. For example, with
	// the following match
	//
	// .. code-block:: yaml
	//
	//	transport_socket_matches:
	//	- name: "enableMTLS"
	//	  match:
	//	    acceptMTLS: true
	//	  transport_socket:
	//	    name: envoy.transport_sockets.tls
	//	    config: { ... } # tls socket configuration
	//	- name: "defaultToPlaintext"
	//	  match: {}
	//	  transport_socket:
	//	    name: envoy.transport_sockets.raw_buffer
	//
	// Connections to the endpoints whose metadata value under “envoy.transport_socket_match“
	// having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
	//
	// If a :ref:`socket match <envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>` with empty match
	// criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
	// socket match in case above.
	//
	// If an endpoint metadata's value under “envoy.transport_socket_match“ does not match any
	// “TransportSocketMatch“, the locality metadata is then checked for a match. Barring any
	// matches in the endpoint or locality metadata, the socket configuration fallbacks to use the
	// “tls_context“ or “transport_socket“ specified in this cluster.
	//
	// This field allows gradual and flexible transport socket configuration changes.
	//
	// The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
	// an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
	// "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
	// has "acceptPlaintext": "true" metadata information.
	//
	// Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
	// traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
	// “TransportSocketMatch“ in this field. Other client Envoys receive CDS without
	// “transport_socket_match“ set, and still send plain text traffic to the same cluster.
	//
	// This field can be used to specify custom transport socket configurations for health
	// checks by adding matching key/value pairs in a health check's
	// :ref:`transport socket match criteria <envoy_v3_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria>` field.
	//
	// [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
	TransportSocketMatches []*Cluster_TransportSocketMatch `protobuf:"bytes,43,rep,name=transport_socket_matches,json=transportSocketMatches,proto3" json:"transport_socket_matches,omitempty"`
	// Optional matcher that selects a transport socket from
	// :ref:`transport_socket_matches <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches>`.
	//
	// This matcher uses the generic xDS matcher framework to select a named transport socket
	// based on various inputs available at transport socket selection time.
	//
	// Supported matching inputs:
	//
	//   - “endpoint_metadata“: Extract values from the selected endpoint's metadata.
	//
	//   - “locality_metadata“: Extract values from the endpoint's locality metadata.
	//
	//   - “transport_socket_filter_state“: Extract values from filter state that was explicitly shared from
	//     downstream to upstream via “TransportSocketOptions“. This enables flexible
	//     downstream-connection-based matching, such as:
	//
	//   - Network namespace matching.
	//
	//   - Custom connection attributes.
	//
	//   - Any data explicitly passed via filter state.
	//
	// .. note::
	//
	//	Filter state sharing follows the same pattern as tunneling in Envoy. Filters must explicitly
	//	share data by setting filter state with the appropriate sharing mode. The filter state is
	//	then accessible via the ``transport_socket_filter_state`` input during transport socket selection.
	//
	// If this field is set, it takes precedence over legacy metadata-based selection
	// performed by :ref:`transport_socket_matches
	// <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches>` alone.
	// If the matcher does not yield a match, Envoy uses the default transport socket
	// configured for the cluster.
	//
	// When using this field, each entry in
	// :ref:`transport_socket_matches <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches>`
	// must have a unique “name“. The matcher outcome is expected to reference one of
	// these names.
	TransportSocketMatcher *v31.Matcher `protobuf:"bytes,59,opt,name=transport_socket_matcher,json=transportSocketMatcher,proto3" json:"transport_socket_matcher,omitempty"`
	// Supplies the name of the cluster which must be unique across all clusters.
	// The cluster name is used when emitting
	// :ref:`statistics <config_cluster_manager_cluster_stats>` if :ref:`alt_stat_name
	// <envoy_v3_api_field_config.cluster.v3.Cluster.alt_stat_name>` is not provided.
	// Any “:“ in the cluster name will be converted to “_“ when emitting statistics.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// An optional alternative to the cluster name to be used for observability. This name is used
	// for emitting stats for the cluster and access logging the cluster name. This will appear as
	// additional information in configuration dumps of a cluster's current status as
	// :ref:`observability_name <envoy_v3_api_field_admin.v3.ClusterStatus.observability_name>`
	// and as an additional tag "upstream_cluster.name" while tracing.
	//
	// .. note::
	//
	//	Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be confused with
	//	:ref:`Router Filter Header <config_http_filters_router_x-envoy-upstream-alt-stat-name>`.
	AltStatName string `protobuf:"bytes,28,opt,name=alt_stat_name,json=altStatName,proto3" json:"alt_stat_name,omitempty"`
	// Types that are valid to be assigned to ClusterDiscoveryType:
	//
	//	*Cluster_Type
	//	*Cluster_ClusterType
	ClusterDiscoveryType isCluster_ClusterDiscoveryType `protobuf_oneof:"cluster_discovery_type"`
	// Configuration to use for EDS updates for the Cluster.
	EdsClusterConfig *Cluster_EdsClusterConfig `protobuf:"bytes,3,opt,name=eds_cluster_config,json=edsClusterConfig,proto3" json:"eds_cluster_config,omitempty"`
	// The timeout for new network connections to hosts in the cluster.
	// If not set, a default value of 5s will be used.
	ConnectTimeout *durationpb.Duration `protobuf:"bytes,4,opt,name=connect_timeout,json=connectTimeout,proto3" json:"connect_timeout,omitempty"`
	// Soft limit on size of the cluster’s connections read and write buffers. If
	// unspecified, an implementation defined default is applied (1MiB).
	PerConnectionBufferLimitBytes *wrapperspb.UInt32Value `protobuf:"bytes,5,opt,name=per_connection_buffer_limit_bytes,json=perConnectionBufferLimitBytes,proto3" json:"per_connection_buffer_limit_bytes,omitempty"`
	// The :ref:`load balancer type <arch_overview_load_balancing_types>` to use
	// when picking a host in the cluster.
	LbPolicy Cluster_LbPolicy `protobuf:"varint,6,opt,name=lb_policy,json=lbPolicy,proto3,enum=envoy.config.cluster.v3.Cluster_LbPolicy" json:"lb_policy,omitempty"`
	// Setting this is required for specifying members of
	// :ref:`STATIC<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC>`,
	// :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
	// or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>` clusters.
	// This field supersedes the “hosts“ field in the v2 API.
	//
	// .. attention::
	//
	//	Setting this allows non-EDS cluster types to contain embedded EDS equivalent
	//	:ref:`endpoint assignments<envoy_v3_api_msg_config.endpoint.v3.ClusterLoadAssignment>`.
	LoadAssignment *v32.ClusterLoadAssignment `protobuf:"bytes,33,opt,name=load_assignment,json=loadAssignment,proto3" json:"load_assignment,omitempty"`
	// Optional :ref:`active health checking <arch_overview_health_checking>`
	// configuration for the cluster. If no
	// configuration is specified no health checking will be done and all cluster
	// members will be considered healthy at all times.
	HealthChecks []*v33.HealthCheck `protobuf:"bytes,8,rep,name=health_checks,json=healthChecks,proto3" json:"health_checks,omitempty"`
	// Optional maximum requests for a single upstream connection. This parameter
	// is respected by both the HTTP/1.1 and HTTP/2 connection pool
	// implementations. If not specified, there is no limit. Setting this
	// parameter to 1 will effectively disable keep alive.
	//
	// .. attention::
	//
	//	This field has been deprecated in favor of the :ref:`max_requests_per_connection <envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_requests_per_connection>` field.
	//
	// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
	MaxRequestsPerConnection *wrapperspb.UInt32Value `protobuf:"bytes,9,opt,name=max_requests_per_connection,json=maxRequestsPerConnection,proto3" json:"max_requests_per_connection,omitempty"`
	// Optional :ref:`circuit breaking <arch_overview_circuit_break>` for the cluster.
	CircuitBreakers *CircuitBreakers `protobuf:"bytes,10,opt,name=circuit_breakers,json=circuitBreakers,proto3" json:"circuit_breakers,omitempty"`
	// HTTP protocol options that are applied only to upstream HTTP connections.
	// These options apply to all HTTP versions.
	// This has been deprecated in favor of
	// :ref:`upstream_http_protocol_options <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
	// in the :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
	// upstream_http_protocol_options can be set via the cluster's
	// :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
	// See :ref:`upstream_http_protocol_options
	// <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
	// for example usage.
	//
	// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
	UpstreamHttpProtocolOptions *v33.UpstreamHttpProtocolOptions `protobuf:"bytes,46,opt,name=upstream_http_protocol_options,json=upstreamHttpProtocolOptions,proto3" json:"upstream_http_protocol_options,omitempty"`
	// Additional options when handling HTTP requests upstream. These options will be applicable to
	// both HTTP1 and HTTP2 requests.
	// This has been deprecated in favor of
	// :ref:`common_http_protocol_options <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.common_http_protocol_options>`
	// in the :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
	// common_http_protocol_options can be set via the cluster's
	// :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
	// See :ref:`upstream_http_protocol_options
	// <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
	// for example usage.
	//
	// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
	CommonHttpProtocolOptions *v33.HttpProtocolOptions `protobuf:"bytes,29,opt,name=common_http_protocol_options,json=commonHttpProtocolOptions,proto3" json:"common_http_protocol_options,omitempty"`
	// Additional options when handling HTTP1 requests.
	// This has been deprecated in favor of http_protocol_options fields in the
	// :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
	// http_protocol_options can be set via the cluster's
	// :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
	// See :ref:`upstream_http_protocol_options
	// <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
	// for example usage.
	//
	// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
	HttpProtocolOptions *v33.Http1ProtocolOptions `protobuf:"bytes,13,opt,name=http_protocol_options,json=httpProtocolOptions,proto3" json:"http_protocol_options,omitempty"`
	// Even if default HTTP2 protocol options are desired, this field must be
	// set so that Envoy will assume that the upstream supports HTTP/2 when
	// making new HTTP connection pool connections. Currently, Envoy only
	// supports prior knowledge for upstream connections. Even if TLS is used
	// with ALPN, “http2_protocol_options“ must be specified. As an aside this allows HTTP/2
	// connections to happen over plain text.
	// This has been deprecated in favor of http2_protocol_options fields in the
	// :ref:`http_protocol_options <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>`
	// message. http2_protocol_options can be set via the cluster's
	// :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
	// See :ref:`upstream_http_protocol_options
	// <envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
	// for example usage.
	//
	// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
	Http2ProtocolOptions *v33.Http2ProtocolOptions `protobuf:"bytes,14,opt,name=http2_protocol_options,json=http2ProtocolOptions,proto3" json:"http2_protocol_options,omitempty"`
	// The extension_protocol_options field is used to provide extension-specific protocol options
	// for upstream connections. The key should match the extension filter name, such as
	// "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
	// specific options.
	// [#next-major-version: make this a list of typed extensions.]
	// [#extension-category: envoy.upstream_options]
	TypedExtensionProtocolOptions map[string]*anypb.Any `protobuf:"bytes,36,rep,name=typed_extension_protocol_options,json=typedExtensionProtocolOptions,proto3" json:"typed_extension_protocol_options,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// If the DNS refresh rate is specified and the cluster type is either
	// :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
	// or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
	// this value is used as the cluster’s DNS refresh
	// rate. The value configured must be at least 1ms. If this setting is not specified, the
	// value defaults to 5000ms. For cluster types other than
	// :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
	// and :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`
	// this setting is ignored.
	// This field is deprecated in favor of using the :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>`
	// extension point and configuring it with :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`.
	// If :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>` is configured with
	// :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`, this field will be ignored.
	//
	// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
	DnsRefreshRate *durationpb.Duration `protobuf:"bytes,16,opt,name=dns_refresh_rate,json=dnsRefreshRate,proto3" json:"dns_refresh_rate,omitempty"`
	// DNS jitter can be optionally specified if the cluster type is either
	// :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
	// or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`.
	// DNS jitter causes the cluster to refresh DNS entries later by a random amount of time to avoid a
	// stampede of DNS requests. This value sets the upper bound (exclusive) for the random amount.
	// There will be no jitter if this value is omitted. For cluster types other than
	// :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
	// and :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`
	// this setting is ignored.
	// This field is deprecated in favor of using the :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>`
	// extension point and configuring it with :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`.
	// If :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>` is configured with
	// :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`, this field will be ignored.
	//
	// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
	DnsJitter *durationpb.Duration `protobuf:"bytes,58,opt,name=dns_jitter,json=dnsJitter,proto3" json:"dns_jitter,omitempty"`
	// If the DNS failure refresh rate is specified and the cluster type is either
	// :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
	// or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
	// this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
	// not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
	// other than :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>` and
	// :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>` this setting is
	// ignored.
	// This field is deprecated in favor of using the :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>`
	// extension point and configuring it with :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`.
	// If :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>` is configured with
	// :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`, this field will be ignored.
	//
	// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
	DnsFailureRefreshRate *Cluster_RefreshRate `protobuf:"bytes,44,opt,name=dns_failure_refresh_rate,json=dnsFailureRefreshRate,proto3" json:"dns_failure_refresh_rate,omitempty"`
	// Optional configuration for setting cluster's DNS refresh rate. If the value is set to true,
	// cluster's DNS refresh rate will be set to resource record's TTL which comes from DNS
	// resolution.
	// This field is deprecated in favor of using the :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>`
	// extension point and configuring it with :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`.
	// If :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>` is configured with
	// :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`, this field will be ignored.
	//
	// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
	RespectDnsTtl bool `protobuf:"varint,39,opt,name=respect_dns_ttl,json=respectDnsTtl,proto3" json:"respect_dns_ttl,omitempty"`
	// The DNS IP address resolution policy. If this setting is not specified, the
	// value defaults to
	// :ref:`AUTO<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DnsLookupFamily.AUTO>`.
	// For logical and strict dns cluster, this field is deprecated in favor of using the
	// :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>`
	// extension point and configuring it with :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`.
	// If :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>` is configured with
	// :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`, this field will be ignored.
	DnsLookupFamily Cluster_DnsLookupFamily `protobuf:"varint,17,opt,name=dns_lookup_family,json=dnsLookupFamily,proto3,enum=envoy.config.cluster.v3.Cluster_DnsLookupFamily" json:"dns_lookup_family,omitempty"`
	// If DNS resolvers are specified and the cluster type is either
	// :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
	// or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
	// this value is used to specify the cluster’s dns resolvers.
	// If this setting is not specified, the value defaults to the default
	// resolver, which uses /etc/resolv.conf for configuration. For cluster types
	// other than
	// :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
	// and :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`
	// this setting is ignored.
	// This field is deprecated in favor of “dns_resolution_config“
	// which aggregates all of the DNS resolver configuration in a single message.
	//
	// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
	DnsResolvers []*v33.Address `protobuf:"bytes,18,rep,name=dns_resolvers,json=dnsResolvers,proto3" json:"dns_resolvers,omitempty"`
	// Always use TCP queries instead of UDP queries for DNS lookups.
	// This field is deprecated in favor of “dns_resolution_config“
	// which aggregates all of the DNS resolver configuration in a single message.
	//
	// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
	UseTcpForDnsLookups bool `protobuf:"varint,45,opt,name=use_tcp_for_dns_lookups,json=useTcpForDnsLookups,proto3" json:"use_tcp_for_dns_lookups,omitempty"`
	// DNS resolution configuration which includes the underlying dns resolver addresses and options.
	// This field is deprecated in favor of
	// :ref:`typed_dns_resolver_config <envoy_v3_api_field_config.cluster.v3.Cluster.typed_dns_resolver_config>`.
	//
	// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
	DnsResolutionConfig *v33.DnsResolutionConfig `protobuf:"bytes,53,opt,name=dns_resolution_config,json=dnsResolutionConfig,proto3" json:"dns_resolution_config,omitempty"`
	// DNS resolver type configuration extension. This extension can be used to configure c-ares, apple,
	// or any other DNS resolver types and the related parameters.
	// For example, an object of
	// :ref:`CaresDnsResolverConfig <envoy_v3_api_msg_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig>`
	// can be packed into this “typed_dns_resolver_config“. This configuration replaces the
	// :ref:`dns_resolution_config <envoy_v3_api_field_config.cluster.v3.Cluster.dns_resolution_config>`
	// configuration.
	// During the transition period when both “dns_resolution_config“ and “typed_dns_resolver_config“ exists,
	// when “typed_dns_resolver_config“ is in place, Envoy will use it and ignore “dns_resolution_config“.
	// When “typed_dns_resolver_config“ is missing, the default behavior is in place.
	// Also note that this field is deprecated for logical dns and strict dns clusters and will be ignored when
	// :ref:`cluster_type<envoy_v3_api_field_config.cluster.v3.Cluster.cluster_type>` is configured with
	// :ref:`DnsCluster<envoy_v3_api_msg_extensions.clusters.dns.v3.DnsCluster>`.
	// [#extension-category: envoy.network.dns_resolver]
	TypedDnsResolverConfig *v33.TypedExtensionConfig `protobuf:"bytes,55,opt,name=typed_dns_resolver_config,json=typedDnsResolverConfig,proto3" json:"typed_dns_resolver_config,omitempty"`
	// Optional configuration for having cluster readiness block on warm-up. Currently, only applicable for
	// :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
	// or :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
	// or :ref:`Redis Cluster<arch_overview_redis>`.
	// If true, cluster readiness blocks on warm-up. If false, the cluster will complete
	// initialization whether or not warm-up has completed. Defaults to true.
	WaitForWarmOnInit *wrapperspb.BoolValue `protobuf:"bytes,54,opt,name=wait_for_warm_on_init,json=waitForWarmOnInit,proto3" json:"wait_for_warm_on_init,omitempty"`
	// If specified, outlier detection will be enabled for this upstream cluster.
	// Each of the configuration values can be overridden via
	// :ref:`runtime values <config_cluster_manager_cluster_runtime_outlier_detection>`.
	OutlierDetection *OutlierDetection `protobuf:"bytes,19,opt,name=outlier_detection,json=outlierDetection,proto3" json:"outlier_detection,omitempty"`
	// The interval for removing stale hosts from a cluster type
	// :ref:`ORIGINAL_DST<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST>`.
	// Hosts are considered stale if they have not been used
	// as upstream destinations during this interval. New hosts are added
	// to original destination clusters on demand as new connections are
	// redirected to Envoy, causing the number of hosts in the cluster to
	// grow over time. Hosts that are not stale (they are actively used as
	// destinations) are kept in the cluster, which allows connections to
	// them remain open, saving the latency that would otherwise be spent
	// on opening new connections. If this setting is not specified, the
	// value defaults to 5000ms. For cluster types other than
	// :ref:`ORIGINAL_DST<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST>`
	// this setting is ignored.
	CleanupInterval *durationpb.Duration `protobuf:"bytes,20,opt,name=cleanup_interval,json=cleanupInterval,proto3" json:"cleanup_interval,omitempty"`
	// Optional configuration used to bind newly established upstream connections.
	// This overrides any bind_config specified in the bootstrap proto.
	// If the address and port are empty, no bind will be performed.
	UpstreamBindConfig *v33.BindConfig `protobuf:"bytes,21,opt,name=upstream_bind_config,json=upstreamBindConfig,proto3" json:"upstream_bind_config,omitempty"`
	// Configuration for load balancing subsetting.
	LbSubsetConfig *Cluster_LbSubsetConfig `protobuf:"bytes,22,opt,name=lb_subset_config,json=lbSubsetConfig,proto3" json:"lb_subset_config,omitempty"`
	// Optional configuration for the load balancing algorithm selected by
	// LbPolicy. Currently only
	// :ref:`RING_HASH<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.RING_HASH>`,
	// :ref:`MAGLEV<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.MAGLEV>` and
	// :ref:`LEAST_REQUEST<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LEAST_REQUEST>`
	// has additional configuration options.
	// Specifying ring_hash_lb_config or maglev_lb_config or least_request_lb_config without setting the corresponding
	// LbPolicy will generate an error at runtime.
	//
	// Types that are valid to be assigned to LbConfig:
	//
	//	*Cluster_RingHashLbConfig_
	//	*Cluster_MaglevLbConfig_
	//	*Cluster_OriginalDstLbConfig_
	//	*Cluster_LeastRequestLbConfig_
	//	*Cluster_RoundRobinLbConfig_
	LbConfig isCluster_LbConfig `protobuf_oneof:"lb_config"`
	// Common configuration for all load balancer implementations.
	CommonLbConfig *Cluster_CommonLbConfig `protobuf:"bytes,27,opt,name=common_lb_config,json=commonLbConfig,proto3" json:"common_lb_config,omitempty"`
	// Optional custom transport socket implementation to use for upstream connections.
	// To setup TLS, set a transport socket with name “envoy.transport_sockets.tls“ and
	// :ref:`UpstreamTlsContexts <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext>` in the “typed_config“.
	// If no transport socket configuration is specified, new connections
	// will be set up with plaintext.
	TransportSocket *v33.TransportSocket `protobuf:"bytes,24,opt,name=transport_socket,json=transportSocket,proto3" json:"transport_socket,omitempty"`
	// The Metadata field can be used to provide additional information about the
	// cluster. It can be used for stats, logging, and varying filter behavior.
	// Fields should use reverse DNS notation to denote which entity within Envoy
	// will need the information. For instance, if the metadata is intended for
	// the Router filter, the filter name should be specified as “envoy.filters.http.router“.
	Metadata *v33.Metadata `protobuf:"bytes,25,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Determines how Envoy selects the protocol used to speak to upstream hosts.
	// This has been deprecated in favor of setting explicit protocol selection
	// in the :ref:`http_protocol_options
	// <envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
	// http_protocol_options can be set via the cluster's
	// :ref:`extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
	//
	// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
	ProtocolSelection Cluster_ClusterProtocolSelection `protobuf:"varint,26,opt,name=protocol_selection,json=protocolSelection,proto3,enum=envoy.config.cluster.v3.Cluster_ClusterProtocolSelection" json:"protocol_selection,omitempty"`
	// Optional options for upstream connections.
	UpstreamConnectionOptions *UpstreamConnectionOptions `protobuf:"bytes,30,opt,name=upstream_connection_options,json=upstreamConnectionOptions,proto3" json:"upstream_connection_options,omitempty"`
	// If an upstream host becomes unhealthy (as determined by the configured health checks
	// or outlier detection), immediately close all connections to the failed host.
	//
	// .. note::
	//
	//	This is currently only supported for connections created by tcp_proxy.
	//
	// .. note::
	//
	//	The current implementation of this feature closes all connections immediately when
	//	the unhealthy status is detected. If there are a large number of connections open
	//	to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of
	//	time exclusively closing these connections, and not processing any other traffic.
	CloseConnectionsOnHostHealthFailure bool `protobuf:"varint,31,opt,name=close_connections_on_host_health_failure,json=closeConnectionsOnHostHealthFailure,proto3" json:"close_connections_on_host_health_failure,omitempty"`
	// If set to true, Envoy will ignore the health value of a host when processing its removal
	// from service discovery. This means that if active health checking is used, Envoy will *not*
	// wait for the endpoint to go unhealthy before removing it.
	IgnoreHealthOnHostRemoval bool `protobuf:"varint,32,opt,name=ignore_health_on_host_removal,json=ignoreHealthOnHostRemoval,proto3" json:"ignore_health_on_host_removal,omitempty"`
	// An (optional) network filter chain, listed in the order the filters should be applied.
	// The chain will be applied to all outgoing connections that Envoy makes to the upstream
	// servers of this cluster.
	Filters []*Filter `protobuf:"bytes,40,rep,name=filters,proto3" json:"filters,omitempty"`
	// If this field is set and is supported by the client, it will supersede the value of
	// :ref:`lb_policy<envoy_v3_api_field_config.cluster.v3.Cluster.lb_policy>`.
	LoadBalancingPolicy *LoadBalancingPolicy `protobuf:"bytes,41,opt,name=load_balancing_policy,json=loadBalancingPolicy,proto3" json:"load_balancing_policy,omitempty"`
	// [#not-implemented-hide:]
	// If present, tells the client where to send load reports via LRS. If not present, the
	// client will fall back to a client-side default, which may be either (a) don't send any
	// load reports or (b) send load reports for all clusters to a single default server
	// (which may be configured in the bootstrap file).
	//
	// Note that if multiple clusters point to the same LRS server, the client may choose to
	// create a separate stream for each cluster or it may choose to coalesce the data for
	// multiple clusters onto a single stream. Either way, the client must make sure to send
	// the data for any given cluster on no more than one stream.
	//
	// [#next-major-version: In the v3 API, we should consider restructuring this somehow,
	// maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
	// from the LRS stream here.]
	LrsServer *v33.ConfigSource `protobuf:"bytes,42,opt,name=lrs_server,json=lrsServer,proto3" json:"lrs_server,omitempty"`
	// A list of metric names from :ref:`ORCA load reports <envoy_v3_api_msg_.xds.data.orca.v3.OrcaLoadReport>` to propagate to LRS.
	//
	// If not specified, then ORCA load reports will not be propagated to LRS.
	//
	// For map fields in the ORCA proto, the string will be of the form “<map_field_name>.<map_key>“.
	// For example, the string “named_metrics.foo“ will mean to look for the key “foo“ in the ORCA
	// :ref:`named_metrics <envoy_v3_api_field_.xds.data.orca.v3.OrcaLoadReport.named_metrics>` field.
	//
	// The special map key “*“ means to report all entries in the map (e.g., “named_metrics.*“ means to
	// report all entries in the ORCA named_metrics field). Note that this should be used only with trusted
	// backends.
	//
	// The metric names in LRS will follow the same semantics as this field. In other words, if this field
	// contains “named_metrics.foo“, then the LRS load report will include the data with that same string
	// as the key.
	LrsReportEndpointMetrics []string `protobuf:"bytes,57,rep,name=lrs_report_endpoint_metrics,json=lrsReportEndpointMetrics,proto3" json:"lrs_report_endpoint_metrics,omitempty"`
	// If track_timeout_budgets is true, the :ref:`timeout budget histograms
	// <config_cluster_manager_cluster_stats_timeout_budgets>` will be published for each
	// request. These show what percentage of a request's per try and global timeout was used. A value
	// of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
	// of 100 would indicate that the request took the entirety of the timeout given to it.
	//
	// .. attention::
	//
	//	This field has been deprecated in favor of ``timeout_budgets``, part of
	//	:ref:`track_cluster_stats <envoy_v3_api_field_config.cluster.v3.Cluster.track_cluster_stats>`.
	//
	// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
	TrackTimeoutBudgets bool `protobuf:"varint,47,opt,name=track_timeout_budgets,json=trackTimeoutBudgets,proto3" json:"track_timeout_budgets,omitempty"`
	// Optional customization and configuration of upstream connection pool, and upstream type.
	//
	// Currently this field only applies for HTTP traffic but is designed for eventual use for custom
	// TCP upstreams.
	//
	// For HTTP traffic, Envoy will generally take downstream HTTP and send it upstream as upstream
	// HTTP, using the http connection pool and the codec from “http2_protocol_options“
	//
	// For routes where CONNECT termination is configured, Envoy will take downstream CONNECT
	// requests and forward the CONNECT payload upstream over raw TCP using the tcp connection pool.
	//
	// The default pool used is the generic connection pool which creates the HTTP upstream for most
	// HTTP requests, and the TCP upstream if CONNECT termination is configured.
	//
	// If users desire custom connection pool or upstream behavior, for example terminating
	// CONNECT only if a custom filter indicates it is appropriate, the custom factories
	// can be registered and configured here.
	// [#extension-category: envoy.upstreams]
	UpstreamConfig *v33.TypedExtensionConfig `protobuf:"bytes,48,opt,name=upstream_config,json=upstreamConfig,proto3" json:"upstream_config,omitempty"`
	// Configuration to track optional cluster stats.
	TrackClusterStats *TrackClusterStats `protobuf:"bytes,49,opt,name=track_cluster_stats,json=trackClusterStats,proto3" json:"track_cluster_stats,omitempty"`
	// Preconnect configuration for this cluster.
	PreconnectPolicy *Cluster_PreconnectPolicy `protobuf:"bytes,50,opt,name=preconnect_policy,json=preconnectPolicy,proto3" json:"preconnect_policy,omitempty"`
	// If “connection_pool_per_downstream_connection“ is true, the cluster will use a separate
	// connection pool for every downstream connection
	ConnectionPoolPerDownstreamConnection bool `protobuf:"varint,51,opt,name=connection_pool_per_downstream_connection,json=connectionPoolPerDownstreamConnection,proto3" json:"connection_pool_per_downstream_connection,omitempty"`
	unknownFields                         protoimpl.UnknownFields
	sizeCache                             protoimpl.SizeCache
}

func (x *Cluster) Reset() {
	*x = Cluster{}
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cluster) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cluster) ProtoMessage() {}

func (x *Cluster) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cluster.ProtoReflect.Descriptor instead.
func (*Cluster) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1}
}

func (x *Cluster) GetTransportSocketMatches() []*Cluster_TransportSocketMatch {
	if x != nil {
		return x.TransportSocketMatches
	}
	return nil
}

func (x *Cluster) GetTransportSocketMatcher() *v31.Matcher {
	if x != nil {
		return x.TransportSocketMatcher
	}
	return nil
}

func (x *Cluster) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Cluster) GetAltStatName() string {
	if x != nil {
		return x.AltStatName
	}
	return ""
}

func (x *Cluster) GetClusterDiscoveryType() isCluster_ClusterDiscoveryType {
	if x != nil {
		return x.ClusterDiscoveryType
	}
	return nil
}

func (x *Cluster) GetType() Cluster_DiscoveryType {
	if x != nil {
		if x, ok := x.ClusterDiscoveryType.(*Cluster_Type); ok {
			return x.Type
		}
	}
	return Cluster_STATIC
}

func (x *Cluster) GetClusterType() *Cluster_CustomClusterType {
	if x != nil {
		if x, ok := x.ClusterDiscoveryType.(*Cluster_ClusterType); ok {
			return x.ClusterType
		}
	}
	return nil
}

func (x *Cluster) GetEdsClusterConfig() *Cluster_EdsClusterConfig {
	if x != nil {
		return x.EdsClusterConfig
	}
	return nil
}

func (x *Cluster) GetConnectTimeout() *durationpb.Duration {
	if x != nil {
		return x.ConnectTimeout
	}
	return nil
}

func (x *Cluster) GetPerConnectionBufferLimitBytes() *wrapperspb.UInt32Value {
	if x != nil {
		return x.PerConnectionBufferLimitBytes
	}
	return nil
}

func (x *Cluster) GetLbPolicy() Cluster_LbPolicy {
	if x != nil {
		return x.LbPolicy
	}
	return Cluster_ROUND_ROBIN
}

func (x *Cluster) GetLoadAssignment() *v32.ClusterLoadAssignment {
	if x != nil {
		return x.LoadAssignment
	}
	return nil
}

func (x *Cluster) GetHealthChecks() []*v33.HealthCheck {
	if x != nil {
		return x.HealthChecks
	}
	return nil
}

// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
func (x *Cluster) GetMaxRequestsPerConnection() *wrapperspb.UInt32Value {
	if x != nil {
		return x.MaxRequestsPerConnection
	}
	return nil
}

func (x *Cluster) GetCircuitBreakers() *CircuitBreakers {
	if x != nil {
		return x.CircuitBreakers
	}
	return nil
}

// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
func (x *Cluster) GetUpstreamHttpProtocolOptions() *v33.UpstreamHttpProtocolOptions {
	if x != nil {
		return x.UpstreamHttpProtocolOptions
	}
	return nil
}

// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
func (x *Cluster) GetCommonHttpProtocolOptions() *v33.HttpProtocolOptions {
	if x != nil {
		return x.CommonHttpProtocolOptions
	}
	return nil
}

// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
func (x *Cluster) GetHttpProtocolOptions() *v33.Http1ProtocolOptions {
	if x != nil {
		return x.HttpProtocolOptions
	}
	return nil
}

// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
func (x *Cluster) GetHttp2ProtocolOptions() *v33.Http2ProtocolOptions {
	if x != nil {
		return x.Http2ProtocolOptions
	}
	return nil
}

func (x *Cluster) GetTypedExtensionProtocolOptions() map[string]*anypb.Any {
	if x != nil {
		return x.TypedExtensionProtocolOptions
	}
	return nil
}

// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
func (x *Cluster) GetDnsRefreshRate() *durationpb.Duration {
	if x != nil {
		return x.DnsRefreshRate
	}
	return nil
}

// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
func (x *Cluster) GetDnsJitter() *durationpb.Duration {
	if x != nil {
		return x.DnsJitter
	}
	return nil
}

// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
func (x *Cluster) GetDnsFailureRefreshRate() *Cluster_RefreshRate {
	if x != nil {
		return x.DnsFailureRefreshRate
	}
	return nil
}

// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
func (x *Cluster) GetRespectDnsTtl() bool {
	if x != nil {
		return x.RespectDnsTtl
	}
	return false
}

func (x *Cluster) GetDnsLookupFamily() Cluster_DnsLookupFamily {
	if x != nil {
		return x.DnsLookupFamily
	}
	return Cluster_AUTO
}

// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
func (x *Cluster) GetDnsResolvers() []*v33.Address {
	if x != nil {
		return x.DnsResolvers
	}
	return nil
}

// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
func (x *Cluster) GetUseTcpForDnsLookups() bool {
	if x != nil {
		return x.UseTcpForDnsLookups
	}
	return false
}

// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
func (x *Cluster) GetDnsResolutionConfig() *v33.DnsResolutionConfig {
	if x != nil {
		return x.DnsResolutionConfig
	}
	return nil
}

func (x *Cluster) GetTypedDnsResolverConfig() *v33.TypedExtensionConfig {
	if x != nil {
		return x.TypedDnsResolverConfig
	}
	return nil
}

func (x *Cluster) GetWaitForWarmOnInit() *wrapperspb.BoolValue {
	if x != nil {
		return x.WaitForWarmOnInit
	}
	return nil
}

func (x *Cluster) GetOutlierDetection() *OutlierDetection {
	if x != nil {
		return x.OutlierDetection
	}
	return nil
}

func (x *Cluster) GetCleanupInterval() *durationpb.Duration {
	if x != nil {
		return x.CleanupInterval
	}
	return nil
}

func (x *Cluster) GetUpstreamBindConfig() *v33.BindConfig {
	if x != nil {
		return x.UpstreamBindConfig
	}
	return nil
}

func (x *Cluster) GetLbSubsetConfig() *Cluster_LbSubsetConfig {
	if x != nil {
		return x.LbSubsetConfig
	}
	return nil
}

func (x *Cluster) GetLbConfig() isCluster_LbConfig {
	if x != nil {
		return x.LbConfig
	}
	return nil
}

func (x *Cluster) GetRingHashLbConfig() *Cluster_RingHashLbConfig {
	if x != nil {
		if x, ok := x.LbConfig.(*Cluster_RingHashLbConfig_); ok {
			return x.RingHashLbConfig
		}
	}
	return nil
}

func (x *Cluster) GetMaglevLbConfig() *Cluster_MaglevLbConfig {
	if x != nil {
		if x, ok := x.LbConfig.(*Cluster_MaglevLbConfig_); ok {
			return x.MaglevLbConfig
		}
	}
	return nil
}

func (x *Cluster) GetOriginalDstLbConfig() *Cluster_OriginalDstLbConfig {
	if x != nil {
		if x, ok := x.LbConfig.(*Cluster_OriginalDstLbConfig_); ok {
			return x.OriginalDstLbConfig
		}
	}
	return nil
}

func (x *Cluster) GetLeastRequestLbConfig() *Cluster_LeastRequestLbConfig {
	if x != nil {
		if x, ok := x.LbConfig.(*Cluster_LeastRequestLbConfig_); ok {
			return x.LeastRequestLbConfig
		}
	}
	return nil
}

func (x *Cluster) GetRoundRobinLbConfig() *Cluster_RoundRobinLbConfig {
	if x != nil {
		if x, ok := x.LbConfig.(*Cluster_RoundRobinLbConfig_); ok {
			return x.RoundRobinLbConfig
		}
	}
	return nil
}

func (x *Cluster) GetCommonLbConfig() *Cluster_CommonLbConfig {
	if x != nil {
		return x.CommonLbConfig
	}
	return nil
}

func (x *Cluster) GetTransportSocket() *v33.TransportSocket {
	if x != nil {
		return x.TransportSocket
	}
	return nil
}

func (x *Cluster) GetMetadata() *v33.Metadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
func (x *Cluster) GetProtocolSelection() Cluster_ClusterProtocolSelection {
	if x != nil {
		return x.ProtocolSelection
	}
	return Cluster_USE_CONFIGURED_PROTOCOL
}

func (x *Cluster) GetUpstreamConnectionOptions() *UpstreamConnectionOptions {
	if x != nil {
		return x.UpstreamConnectionOptions
	}
	return nil
}

func (x *Cluster) GetCloseConnectionsOnHostHealthFailure() bool {
	if x != nil {
		return x.CloseConnectionsOnHostHealthFailure
	}
	return false
}

func (x *Cluster) GetIgnoreHealthOnHostRemoval() bool {
	if x != nil {
		return x.IgnoreHealthOnHostRemoval
	}
	return false
}

func (x *Cluster) GetFilters() []*Filter {
	if x != nil {
		return x.Filters
	}
	return nil
}

func (x *Cluster) GetLoadBalancingPolicy() *LoadBalancingPolicy {
	if x != nil {
		return x.LoadBalancingPolicy
	}
	return nil
}

func (x *Cluster) GetLrsServer() *v33.ConfigSource {
	if x != nil {
		return x.LrsServer
	}
	return nil
}

func (x *Cluster) GetLrsReportEndpointMetrics() []string {
	if x != nil {
		return x.LrsReportEndpointMetrics
	}
	return nil
}

// Deprecated: Marked as deprecated in envoy/config/cluster/v3/cluster.proto.
func (x *Cluster) GetTrackTimeoutBudgets() bool {
	if x != nil {
		return x.TrackTimeoutBudgets
	}
	return false
}

func (x *Cluster) GetUpstreamConfig() *v33.TypedExtensionConfig {
	if x != nil {
		return x.UpstreamConfig
	}
	return nil
}

func (x *Cluster) GetTrackClusterStats() *TrackClusterStats {
	if x != nil {
		return x.TrackClusterStats
	}
	return nil
}

func (x *Cluster) GetPreconnectPolicy() *Cluster_PreconnectPolicy {
	if x != nil {
		return x.PreconnectPolicy
	}
	return nil
}

func (x *Cluster) GetConnectionPoolPerDownstreamConnection() bool {
	if x != nil {
		return x.ConnectionPoolPerDownstreamConnection
	}
	return false
}

type isCluster_ClusterDiscoveryType interface {
	isCluster_ClusterDiscoveryType()
}

type Cluster_Type struct {
	// The :ref:`service discovery type <arch_overview_service_discovery_types>`
	// to use for resolving the cluster.
	Type Cluster_DiscoveryType `protobuf:"varint,2,opt,name=type,proto3,enum=envoy.config.cluster.v3.Cluster_DiscoveryType,oneof"`
}

type Cluster_ClusterType struct {
	// The custom cluster type.
	ClusterType *Cluster_CustomClusterType `protobuf:"bytes,38,opt,name=cluster_type,json=clusterType,proto3,oneof"`
}

func (*Cluster_Type) isCluster_ClusterDiscoveryType() {}

func (*Cluster_ClusterType) isCluster_ClusterDiscoveryType() {}

type isCluster_LbConfig interface {
	isCluster_LbConfig()
}

type Cluster_RingHashLbConfig_ struct {
	// Optional configuration for the Ring Hash load balancing policy.
	RingHashLbConfig *Cluster_RingHashLbConfig `protobuf:"bytes,23,opt,name=ring_hash_lb_config,json=ringHashLbConfig,proto3,oneof"`
}

type Cluster_MaglevLbConfig_ struct {
	// Optional configuration for the Maglev load balancing policy.
	MaglevLbConfig *Cluster_MaglevLbConfig `protobuf:"bytes,52,opt,name=maglev_lb_config,json=maglevLbConfig,proto3,oneof"`
}

type Cluster_OriginalDstLbConfig_ struct {
	// Optional configuration for the Original Destination load balancing policy.
	OriginalDstLbConfig *Cluster_OriginalDstLbConfig `protobuf:"bytes,34,opt,name=original_dst_lb_config,json=originalDstLbConfig,proto3,oneof"`
}

type Cluster_LeastRequestLbConfig_ struct {
	// Optional configuration for the LeastRequest load balancing policy.
	LeastRequestLbConfig *Cluster_LeastRequestLbConfig `protobuf:"bytes,37,opt,name=least_request_lb_config,json=leastRequestLbConfig,proto3,oneof"`
}

type Cluster_RoundRobinLbConfig_ struct {
	// Optional configuration for the RoundRobin load balancing policy.
	RoundRobinLbConfig *Cluster_RoundRobinLbConfig `protobuf:"bytes,56,opt,name=round_robin_lb_config,json=roundRobinLbConfig,proto3,oneof"`
}

func (*Cluster_RingHashLbConfig_) isCluster_LbConfig() {}

func (*Cluster_MaglevLbConfig_) isCluster_LbConfig() {}

func (*Cluster_OriginalDstLbConfig_) isCluster_LbConfig() {}

func (*Cluster_LeastRequestLbConfig_) isCluster_LbConfig() {}

func (*Cluster_RoundRobinLbConfig_) isCluster_LbConfig() {}

// Extensible load balancing policy configuration.
//
// Every LB policy defined via this mechanism will be identified via a unique name using reverse
// DNS notation. If the policy needs configuration parameters, it must define a message for its
// own configuration, which will be stored in the config field. The name of the policy will tell
// clients which type of message they should expect to see in the config field.
//
// Note that there are cases where it is useful to be able to independently select LB policies
// for choosing a locality and for choosing an endpoint within that locality. For example, a
// given deployment may always use the same policy to choose the locality, but for choosing the
// endpoint within the locality, some clusters may use weighted-round-robin, while others may
// use some sort of session-based balancing.
//
// This can be accomplished via hierarchical LB policies, where the parent LB policy creates a
// child LB policy for each locality. For each request, the parent chooses the locality and then
// delegates to the child policy for that locality to choose the endpoint within the locality.
//
// To facilitate this, the config message for the top-level LB policy may include a field of
// type LoadBalancingPolicy that specifies the child policy.
type LoadBalancingPolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Each client will iterate over the list in order and stop at the first policy that it
	// supports. This provides a mechanism for starting to use new LB policies that are not yet
	// supported by all clients.
	Policies      []*LoadBalancingPolicy_Policy `protobuf:"bytes,1,rep,name=policies,proto3" json:"policies,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LoadBalancingPolicy) Reset() {
	*x = LoadBalancingPolicy{}
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LoadBalancingPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadBalancingPolicy) ProtoMessage() {}

func (x *LoadBalancingPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadBalancingPolicy.ProtoReflect.Descriptor instead.
func (*LoadBalancingPolicy) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{2}
}

func (x *LoadBalancingPolicy) GetPolicies() []*LoadBalancingPolicy_Policy {
	if x != nil {
		return x.Policies
	}
	return nil
}

type UpstreamConnectionOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
	TcpKeepalive *v33.TcpKeepalive `protobuf:"bytes,1,opt,name=tcp_keepalive,json=tcpKeepalive,proto3" json:"tcp_keepalive,omitempty"`
	// If enabled, associates the interface name of the local address with the upstream connection.
	// This can be used by extensions during processing of requests. The association mechanism is
	// implementation specific. Defaults to false due to performance concerns.
	SetLocalInterfaceNameOnUpstreamConnections bool `protobuf:"varint,2,opt,name=set_local_interface_name_on_upstream_connections,json=setLocalInterfaceNameOnUpstreamConnections,proto3" json:"set_local_interface_name_on_upstream_connections,omitempty"`
	// Configurations for happy eyeballs algorithm.
	// Add configs for first_address_family_version and first_address_family_count
	// when sorting destination ip addresses.
	HappyEyeballsConfig *UpstreamConnectionOptions_HappyEyeballsConfig `protobuf:"bytes,3,opt,name=happy_eyeballs_config,json=happyEyeballsConfig,proto3" json:"happy_eyeballs_config,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *UpstreamConnectionOptions) Reset() {
	*x = UpstreamConnectionOptions{}
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpstreamConnectionOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpstreamConnectionOptions) ProtoMessage() {}

func (x *UpstreamConnectionOptions) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpstreamConnectionOptions.ProtoReflect.Descriptor instead.
func (*UpstreamConnectionOptions) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{3}
}

func (x *UpstreamConnectionOptions) GetTcpKeepalive() *v33.TcpKeepalive {
	if x != nil {
		return x.TcpKeepalive
	}
	return nil
}

func (x *UpstreamConnectionOptions) GetSetLocalInterfaceNameOnUpstreamConnections() bool {
	if x != nil {
		return x.SetLocalInterfaceNameOnUpstreamConnections
	}
	return false
}

func (x *UpstreamConnectionOptions) GetHappyEyeballsConfig() *UpstreamConnectionOptions_HappyEyeballsConfig {
	if x != nil {
		return x.HappyEyeballsConfig
	}
	return nil
}

type TrackClusterStats struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If timeout_budgets is true, the :ref:`timeout budget histograms
	// <config_cluster_manager_cluster_stats_timeout_budgets>` will be published for each
	// request. These show what percentage of a request's per try and global timeout was used. A value
	// of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
	// of 100 would indicate that the request took the entirety of the timeout given to it.
	TimeoutBudgets bool `protobuf:"varint,1,opt,name=timeout_budgets,json=timeoutBudgets,proto3" json:"timeout_budgets,omitempty"`
	// If request_response_sizes is true, then the :ref:`histograms
	// <config_cluster_manager_cluster_stats_request_response_sizes>`  tracking header and body sizes
	// of requests and responses will be published. Additionally, number of headers in the requests and responses will be tracked.
	RequestResponseSizes bool `protobuf:"varint,2,opt,name=request_response_sizes,json=requestResponseSizes,proto3" json:"request_response_sizes,omitempty"`
	// If true, some stats will be emitted per-endpoint, similar to the stats in admin “/clusters“
	// output.
	//
	// This does not currently output correct stats during a hot-restart.
	//
	// This is not currently implemented by all stat sinks.
	//
	// These stats do not honor filtering or tag extraction rules in :ref:`StatsConfig
	// <envoy_v3_api_msg_config.metrics.v3.StatsConfig>` (but fixed-value tags are supported). Admin
	// endpoint filtering is supported.
	//
	// This may not be used at the same time as
	// :ref:`load_stats_config <envoy_v3_api_field_config.bootstrap.v3.ClusterManager.load_stats_config>`.
	PerEndpointStats bool `protobuf:"varint,3,opt,name=per_endpoint_stats,json=perEndpointStats,proto3" json:"per_endpoint_stats,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *TrackClusterStats) Reset() {
	*x = TrackClusterStats{}
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TrackClusterStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TrackClusterStats) ProtoMessage() {}

func (x *TrackClusterStats) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TrackClusterStats.ProtoReflect.Descriptor instead.
func (*TrackClusterStats) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{4}
}

func (x *TrackClusterStats) GetTimeoutBudgets() bool {
	if x != nil {
		return x.TimeoutBudgets
	}
	return false
}

func (x *TrackClusterStats) GetRequestResponseSizes() bool {
	if x != nil {
		return x.RequestResponseSizes
	}
	return false
}

func (x *TrackClusterStats) GetPerEndpointStats() bool {
	if x != nil {
		return x.PerEndpointStats
	}
	return false
}

// TransportSocketMatch specifies what transport socket config will be used
// when the match conditions are satisfied.
type Cluster_TransportSocketMatch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the match, used in stats generation.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Optional metadata match criteria.
	// The connection to the endpoint with metadata matching what is set in this field
	// will use the transport socket configuration specified here.
	// The endpoint's metadata entry in “envoy.transport_socket_match“ is used to match
	// against the values specified in this field.
	Match *structpb.Struct `protobuf:"bytes,2,opt,name=match,proto3" json:"match,omitempty"`
	// The configuration of the transport socket.
	// [#extension-category: envoy.transport_sockets.upstream]
	TransportSocket *v33.TransportSocket `protobuf:"bytes,3,opt,name=transport_socket,json=transportSocket,proto3" json:"transport_socket,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *Cluster_TransportSocketMatch) Reset() {
	*x = Cluster_TransportSocketMatch{}
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cluster_TransportSocketMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cluster_TransportSocketMatch) ProtoMessage() {}

func (x *Cluster_TransportSocketMatch) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cluster_TransportSocketMatch.ProtoReflect.Descriptor instead.
func (*Cluster_TransportSocketMatch) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 0}
}

func (x *Cluster_TransportSocketMatch) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Cluster_TransportSocketMatch) GetMatch() *structpb.Struct {
	if x != nil {
		return x.Match
	}
	return nil
}

func (x *Cluster_TransportSocketMatch) GetTransportSocket() *v33.TransportSocket {
	if x != nil {
		return x.TransportSocket
	}
	return nil
}

// Extended cluster type.
type Cluster_CustomClusterType struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type of the cluster to instantiate. The name must match a supported cluster type.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Cluster specific configuration which depends on the cluster being instantiated.
	// See the supported cluster for further documentation.
	// [#extension-category: envoy.clusters]
	TypedConfig   *anypb.Any `protobuf:"bytes,2,opt,name=typed_config,json=typedConfig,proto3" json:"typed_config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Cluster_CustomClusterType) Reset() {
	*x = Cluster_CustomClusterType{}
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cluster_CustomClusterType) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cluster_CustomClusterType) ProtoMessage() {}

func (x *Cluster_CustomClusterType) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cluster_CustomClusterType.ProtoReflect.Descriptor instead.
func (*Cluster_CustomClusterType) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 1}
}

func (x *Cluster_CustomClusterType) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Cluster_CustomClusterType) GetTypedConfig() *anypb.Any {
	if x != nil {
		return x.TypedConfig
	}
	return nil
}

// Only valid when discovery type is EDS.
type Cluster_EdsClusterConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Configuration for the source of EDS updates for this Cluster.
	EdsConfig *v33.ConfigSource `protobuf:"bytes,1,opt,name=eds_config,json=edsConfig,proto3" json:"eds_config,omitempty"`
	// Optional alternative to cluster name to present to EDS. This does not
	// have the same restrictions as cluster name, i.e. it may be arbitrary
	// length. This may be a xdstp:// URL.
	ServiceName   string `protobuf:"bytes,2,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Cluster_EdsClusterConfig) Reset() {
	*x = Cluster_EdsClusterConfig{}
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cluster_EdsClusterConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cluster_EdsClusterConfig) ProtoMessage() {}

func (x *Cluster_EdsClusterConfig) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cluster_EdsClusterConfig.ProtoReflect.Descriptor instead.
func (*Cluster_EdsClusterConfig) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 2}
}

func (x *Cluster_EdsClusterConfig) GetEdsConfig() *v33.ConfigSource {
	if x != nil {
		return x.EdsConfig
	}
	return nil
}

func (x *Cluster_EdsClusterConfig) GetServiceName() string {
	if x != nil {
		return x.ServiceName
	}
	return ""
}

// Optionally divide the endpoints in this cluster into subsets defined by
// endpoint metadata and selected by route and weighted cluster metadata.
// [#next-free-field: 9]
type Cluster_LbSubsetConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The behavior used when no endpoint subset matches the selected route's
	// metadata. The value defaults to
	// :ref:`NO_FALLBACK<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
	FallbackPolicy Cluster_LbSubsetConfig_LbSubsetFallbackPolicy `protobuf:"varint,1,opt,name=fallback_policy,json=fallbackPolicy,proto3,enum=envoy.config.cluster.v3.Cluster_LbSubsetConfig_LbSubsetFallbackPolicy" json:"fallback_policy,omitempty"`
	// Specifies the default subset of endpoints used during fallback if
	// fallback_policy is
	// :ref:`DEFAULT_SUBSET<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET>`.
	// Each field in default_subset is
	// compared to the matching LbEndpoint.Metadata under the “envoy.lb“
	// namespace. It is valid for no hosts to match, in which case the behavior
	// is the same as a fallback_policy of
	// :ref:`NO_FALLBACK<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
	DefaultSubset *structpb.Struct `protobuf:"bytes,2,opt,name=default_subset,json=defaultSubset,proto3" json:"default_subset,omitempty"`
	// For each entry, LbEndpoint.Metadata's
	// “envoy.lb“ namespace is traversed and a subset is created for each unique
	// combination of key and value. For example:
	//
	// .. code-block:: json
	//
	//	{ "subset_selectors": [
	//	    { "keys": [ "version" ] },
	//	    { "keys": [ "stage", "hardware_type" ] }
	//	]}
	//
	// A subset is matched when the metadata from the selected route and
	// weighted cluster contains the same keys and values as the subset's
	// metadata. The same host may appear in multiple subsets.
	SubsetSelectors []*Cluster_LbSubsetConfig_LbSubsetSelector `protobuf:"bytes,3,rep,name=subset_selectors,json=subsetSelectors,proto3" json:"subset_selectors,omitempty"`
	// If true, routing to subsets will take into account the localities and locality weights of the
	// endpoints when making the routing decision.
	//
	// There are some potential pitfalls associated with enabling this feature, as the resulting
	// traffic split after applying both a subset match and locality weights might be undesirable.
	//
	// Consider for example a situation in which you have 50/50 split across two localities X/Y
	// which have 100 hosts each without subsetting. If the subset LB results in X having only 1
	// host selected but Y having 100, then a lot more load is being dumped on the single host in X
	// than originally anticipated in the load balancing assignment delivered via EDS.
	LocalityWeightAware bool `protobuf:"varint,4,opt,name=locality_weight_aware,json=localityWeightAware,proto3" json:"locality_weight_aware,omitempty"`
	// When used with locality_weight_aware, scales the weight of each locality by the ratio
	// of hosts in the subset vs hosts in the original subset. This aims to even out the load
	// going to an individual locality if said locality is disproportionately affected by the
	// subset predicate.
	ScaleLocalityWeight bool `protobuf:"varint,5,opt,name=scale_locality_weight,json=scaleLocalityWeight,proto3" json:"scale_locality_weight,omitempty"`
	// If true, when a fallback policy is configured and its corresponding subset fails to find
	// a host this will cause any host to be selected instead.
	//
	// This is useful when using the default subset as the fallback policy, given the default
	// subset might become empty. With this option enabled, if that happens the LB will attempt
	// to select a host from the entire cluster.
	PanicModeAny bool `protobuf:"varint,6,opt,name=panic_mode_any,json=panicModeAny,proto3" json:"panic_mode_any,omitempty"`
	// If true, metadata specified for a metadata key will be matched against the corresponding
	// endpoint metadata if the endpoint metadata matches the value exactly OR it is a list value
	// and any of the elements in the list matches the criteria.
	ListAsAny bool `protobuf:"varint,7,opt,name=list_as_any,json=listAsAny,proto3" json:"list_as_any,omitempty"`
	// Fallback mechanism that allows to try different route metadata until a host is found.
	// If load balancing process, including all its mechanisms (like
	// :ref:`fallback_policy<envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.fallback_policy>`)
	// fails to select a host, this policy decides if and how the process is repeated using another metadata.
	//
	// The value defaults to
	// :ref:`METADATA_NO_FALLBACK<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetMetadataFallbackPolicy.METADATA_NO_FALLBACK>`.
	MetadataFallbackPolicy Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy `protobuf:"varint,8,opt,name=metadata_fallback_policy,json=metadataFallbackPolicy,proto3,enum=envoy.config.cluster.v3.Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy" json:"metadata_fallback_policy,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *Cluster_LbSubsetConfig) Reset() {
	*x = Cluster_LbSubsetConfig{}
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cluster_LbSubsetConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cluster_LbSubsetConfig) ProtoMessage() {}

func (x *Cluster_LbSubsetConfig) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cluster_LbSubsetConfig.ProtoReflect.Descriptor instead.
func (*Cluster_LbSubsetConfig) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 3}
}

func (x *Cluster_LbSubsetConfig) GetFallbackPolicy() Cluster_LbSubsetConfig_LbSubsetFallbackPolicy {
	if x != nil {
		return x.FallbackPolicy
	}
	return Cluster_LbSubsetConfig_NO_FALLBACK
}

func (x *Cluster_LbSubsetConfig) GetDefaultSubset() *structpb.Struct {
	if x != nil {
		return x.DefaultSubset
	}
	return nil
}

func (x *Cluster_LbSubsetConfig) GetSubsetSelectors() []*Cluster_LbSubsetConfig_LbSubsetSelector {
	if x != nil {
		return x.SubsetSelectors
	}
	return nil
}

func (x *Cluster_LbSubsetConfig) GetLocalityWeightAware() bool {
	if x != nil {
		return x.LocalityWeightAware
	}
	return false
}

func (x *Cluster_LbSubsetConfig) GetScaleLocalityWeight() bool {
	if x != nil {
		return x.ScaleLocalityWeight
	}
	return false
}

func (x *Cluster_LbSubsetConfig) GetPanicModeAny() bool {
	if x != nil {
		return x.PanicModeAny
	}
	return false
}

func (x *Cluster_LbSubsetConfig) GetListAsAny() bool {
	if x != nil {
		return x.ListAsAny
	}
	return false
}

func (x *Cluster_LbSubsetConfig) GetMetadataFallbackPolicy() Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy {
	if x != nil {
		return x.MetadataFallbackPolicy
	}
	return Cluster_LbSubsetConfig_METADATA_NO_FALLBACK
}

// Configuration for :ref:`slow start mode <arch_overview_load_balancing_slow_start>`.
type Cluster_SlowStartConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Represents the size of slow start window.
	// If set, the newly created host remains in slow start mode starting from its creation time
	// for the duration of slow start window.
	SlowStartWindow *durationpb.Duration `protobuf:"bytes,1,opt,name=slow_start_window,json=slowStartWindow,proto3" json:"slow_start_window,omitempty"`
	// This parameter controls the speed of traffic increase over the slow start window. Defaults to 1.0,
	// so that endpoint would get linearly increasing amount of traffic.
	// When increasing the value for this parameter, the speed of traffic ramp-up increases non-linearly.
	// The value of aggression parameter should be greater than 0.0.
	// By tuning the parameter, is possible to achieve polynomial or exponential shape of ramp-up curve.
	//
	// During slow start window, effective weight of an endpoint would be scaled with time factor and aggression:
	// “new_weight = weight * max(min_weight_percent, time_factor ^ (1 / aggression))“,
	// where “time_factor=(time_since_start_seconds / slow_start_time_seconds)“.
	//
	// As time progresses, more and more traffic would be sent to endpoint, which is in slow start window.
	// Once host exits slow start, time_factor and aggression no longer affect its weight.
	Aggression *v33.RuntimeDouble `protobuf:"bytes,2,opt,name=aggression,proto3" json:"aggression,omitempty"`
	// Configures the minimum percentage of origin weight that avoids too small new weight,
	// which may cause endpoints in slow start mode receive no traffic in slow start window.
	// If not specified, the default is 10%.
	MinWeightPercent *v34.Percent `protobuf:"bytes,3,opt,name=min_weight_percent,json=minWeightPercent,proto3" json:"min_weight_percent,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *Cluster_SlowStartConfig) Reset() {
	*x = Cluster_SlowStartConfig{}
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cluster_SlowStartConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cluster_SlowStartConfig) ProtoMessage() {}

func (x *Cluster_SlowStartConfig) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cluster_SlowStartConfig.ProtoReflect.Descriptor instead.
func (*Cluster_SlowStartConfig) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 4}
}

func (x *Cluster_SlowStartConfig) GetSlowStartWindow() *durationpb.Duration {
	if x != nil {
		return x.SlowStartWindow
	}
	return nil
}

func (x *Cluster_SlowStartConfig) GetAggression() *v33.RuntimeDouble {
	if x != nil {
		return x.Aggression
	}
	return nil
}

func (x *Cluster_SlowStartConfig) GetMinWeightPercent() *v34.Percent {
	if x != nil {
		return x.MinWeightPercent
	}
	return nil
}

// Specific configuration for the RoundRobin load balancing policy.
type Cluster_RoundRobinLbConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Configuration for slow start mode.
	// If this configuration is not set, slow start will not be not enabled.
	SlowStartConfig *Cluster_SlowStartConfig `protobuf:"bytes,1,opt,name=slow_start_config,json=slowStartConfig,proto3" json:"slow_start_config,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *Cluster_RoundRobinLbConfig) Reset() {
	*x = Cluster_RoundRobinLbConfig{}
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cluster_RoundRobinLbConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cluster_RoundRobinLbConfig) ProtoMessage() {}

func (x *Cluster_RoundRobinLbConfig) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cluster_RoundRobinLbConfig.ProtoReflect.Descriptor instead.
func (*Cluster_RoundRobinLbConfig) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 5}
}

func (x *Cluster_RoundRobinLbConfig) GetSlowStartConfig() *Cluster_SlowStartConfig {
	if x != nil {
		return x.SlowStartConfig
	}
	return nil
}

// Specific configuration for the LeastRequest load balancing policy.
type Cluster_LeastRequestLbConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The number of random healthy hosts from which the host with the fewest active requests will
	// be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
	ChoiceCount *wrapperspb.UInt32Value `protobuf:"bytes,1,opt,name=choice_count,json=choiceCount,proto3" json:"choice_count,omitempty"`
	// The following formula is used to calculate the dynamic weights when hosts have different load
	// balancing weights:
	//
	// “weight = load_balancing_weight / (active_requests + 1)^active_request_bias“
	//
	// The larger the active request bias is, the more aggressively active requests will lower the
	// effective weight when all host weights are not equal.
	//
	// “active_request_bias“ must be greater than or equal to 0.0.
	//
	// When “active_request_bias == 0.0“ the Least Request Load Balancer doesn't consider the number
	// of active requests at the time it picks a host and behaves like the Round Robin Load
	// Balancer.
	//
	// When “active_request_bias > 0.0“ the Least Request Load Balancer scales the load balancing
	// weight by the number of active requests at the time it does a pick.
	//
	// The value is cached for performance reasons and refreshed whenever one of the Load Balancer's
	// host sets changes, e.g., whenever there is a host membership update or a host load balancing
	// weight change.
	//
	// .. note::
	//
	//	This setting only takes effect if all host weights are not equal.
	ActiveRequestBias *v33.RuntimeDouble `protobuf:"bytes,2,opt,name=active_request_bias,json=activeRequestBias,proto3" json:"active_request_bias,omitempty"`
	// Configuration for slow start mode.
	// If this configuration is not set, slow start will not be not enabled.
	SlowStartConfig *Cluster_SlowStartConfig `protobuf:"bytes,3,opt,name=slow_start_config,json=slowStartConfig,proto3" json:"slow_start_config,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *Cluster_LeastRequestLbConfig) Reset() {
	*x = Cluster_LeastRequestLbConfig{}
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cluster_LeastRequestLbConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cluster_LeastRequestLbConfig) ProtoMessage() {}

func (x *Cluster_LeastRequestLbConfig) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cluster_LeastRequestLbConfig.ProtoReflect.Descriptor instead.
func (*Cluster_LeastRequestLbConfig) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 6}
}

func (x *Cluster_LeastRequestLbConfig) GetChoiceCount() *wrapperspb.UInt32Value {
	if x != nil {
		return x.ChoiceCount
	}
	return nil
}

func (x *Cluster_LeastRequestLbConfig) GetActiveRequestBias() *v33.RuntimeDouble {
	if x != nil {
		return x.ActiveRequestBias
	}
	return nil
}

func (x *Cluster_LeastRequestLbConfig) GetSlowStartConfig() *Cluster_SlowStartConfig {
	if x != nil {
		return x.SlowStartConfig
	}
	return nil
}

// Specific configuration for the :ref:`RingHash<arch_overview_load_balancing_types_ring_hash>`
// load balancing policy.
type Cluster_RingHashLbConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
	// provided host) the better the request distribution will reflect the desired weights. Defaults
	// to 1024 entries, and limited to 8M entries. See also
	// :ref:`maximum_ring_size<envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size>`.
	MinimumRingSize *wrapperspb.UInt64Value `protobuf:"bytes,1,opt,name=minimum_ring_size,json=minimumRingSize,proto3" json:"minimum_ring_size,omitempty"`
	// The hash function used to hash hosts onto the ketama ring. The value defaults to
	// :ref:`XX_HASH<envoy_v3_api_enum_value_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.XX_HASH>`.
	HashFunction Cluster_RingHashLbConfig_HashFunction `protobuf:"varint,3,opt,name=hash_function,json=hashFunction,proto3,enum=envoy.config.cluster.v3.Cluster_RingHashLbConfig_HashFunction" json:"hash_function,omitempty"`
	// Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
	// to further constrain resource use. See also
	// :ref:`minimum_ring_size<envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size>`.
	MaximumRingSize *wrapperspb.UInt64Value `protobuf:"bytes,4,opt,name=maximum_ring_size,json=maximumRingSize,proto3" json:"maximum_ring_size,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *Cluster_RingHashLbConfig) Reset() {
	*x = Cluster_RingHashLbConfig{}
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cluster_RingHashLbConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cluster_RingHashLbConfig) ProtoMessage() {}

func (x *Cluster_RingHashLbConfig) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cluster_RingHashLbConfig.ProtoReflect.Descriptor instead.
func (*Cluster_RingHashLbConfig) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 7}
}

func (x *Cluster_RingHashLbConfig) GetMinimumRingSize() *wrapperspb.UInt64Value {
	if x != nil {
		return x.MinimumRingSize
	}
	return nil
}

func (x *Cluster_RingHashLbConfig) GetHashFunction() Cluster_RingHashLbConfig_HashFunction {
	if x != nil {
		return x.HashFunction
	}
	return Cluster_RingHashLbConfig_XX_HASH
}

func (x *Cluster_RingHashLbConfig) GetMaximumRingSize() *wrapperspb.UInt64Value {
	if x != nil {
		return x.MaximumRingSize
	}
	return nil
}

// Specific configuration for the :ref:`Maglev<arch_overview_load_balancing_types_maglev>`
// load balancing policy.
type Cluster_MaglevLbConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The table size for Maglev hashing. Maglev aims for "minimal disruption" rather than an absolute guarantee.
	// Minimal disruption means that when the set of upstream hosts change, a connection will likely be sent to the same
	// upstream as it was before. Increasing the table size reduces the amount of disruption.
	// The table size must be prime number limited to 5000011. If it is not specified, the default is 65537.
	TableSize     *wrapperspb.UInt64Value `protobuf:"bytes,1,opt,name=table_size,json=tableSize,proto3" json:"table_size,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Cluster_MaglevLbConfig) Reset() {
	*x = Cluster_MaglevLbConfig{}
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cluster_MaglevLbConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cluster_MaglevLbConfig) ProtoMessage() {}

func (x *Cluster_MaglevLbConfig) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cluster_MaglevLbConfig.ProtoReflect.Descriptor instead.
func (*Cluster_MaglevLbConfig) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 8}
}

func (x *Cluster_MaglevLbConfig) GetTableSize() *wrapperspb.UInt64Value {
	if x != nil {
		return x.TableSize
	}
	return nil
}

// Specific configuration for the
// :ref:`Original Destination <arch_overview_load_balancing_types_original_destination>`
// load balancing policy.
// [#extension: envoy.clusters.original_dst]
type Cluster_OriginalDstLbConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// When true, a HTTP header can be used to override the original dst address. The default header is
	// :ref:`x-envoy-original-dst-host <config_http_conn_man_headers_x-envoy-original-dst-host>`.
	//
	// .. attention::
	//
	//	This header isn't sanitized by default, so enabling this feature allows HTTP clients to
	//	route traffic to arbitrary hosts and/or ports, which may have serious security
	//	consequences.
	//
	// .. note::
	//
	//	If the header appears multiple times only the first value is used.
	UseHttpHeader bool `protobuf:"varint,1,opt,name=use_http_header,json=useHttpHeader,proto3" json:"use_http_header,omitempty"`
	// The http header to override destination address if :ref:`use_http_header <envoy_v3_api_field_config.cluster.v3.Cluster.OriginalDstLbConfig.use_http_header>`.
	// is set to true. If the value is empty, :ref:`x-envoy-original-dst-host <config_http_conn_man_headers_x-envoy-original-dst-host>` will be used.
	HttpHeaderName string `protobuf:"bytes,2,opt,name=http_header_name,json=httpHeaderName,proto3" json:"http_header_name,omitempty"`
	// The port to override for the original dst address. This port
	// will take precedence over filter state and header override ports
	UpstreamPortOverride *wrapperspb.UInt32Value `protobuf:"bytes,3,opt,name=upstream_port_override,json=upstreamPortOverride,proto3" json:"upstream_port_override,omitempty"`
	// The dynamic metadata key to override destination address.
	// First the request metadata is considered, then the connection one.
	MetadataKey   *v35.MetadataKey `protobuf:"bytes,4,opt,name=metadata_key,json=metadataKey,proto3" json:"metadata_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Cluster_OriginalDstLbConfig) Reset() {
	*x = Cluster_OriginalDstLbConfig{}
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cluster_OriginalDstLbConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cluster_OriginalDstLbConfig) ProtoMessage() {}

func (x *Cluster_OriginalDstLbConfig) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cluster_OriginalDstLbConfig.ProtoReflect.Descriptor instead.
func (*Cluster_OriginalDstLbConfig) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 9}
}

func (x *Cluster_OriginalDstLbConfig) GetUseHttpHeader() bool {
	if x != nil {
		return x.UseHttpHeader
	}
	return false
}

func (x *Cluster_OriginalDstLbConfig) GetHttpHeaderName() string {
	if x != nil {
		return x.HttpHeaderName
	}
	return ""
}

func (x *Cluster_OriginalDstLbConfig) GetUpstreamPortOverride() *wrapperspb.UInt32Value {
	if x != nil {
		return x.UpstreamPortOverride
	}
	return nil
}

func (x *Cluster_OriginalDstLbConfig) GetMetadataKey() *v35.MetadataKey {
	if x != nil {
		return x.MetadataKey
	}
	return nil
}

// Common configuration for all load balancer implementations.
// [#next-free-field: 9]
type Cluster_CommonLbConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Configures the :ref:`healthy panic threshold <arch_overview_load_balancing_panic_threshold>`.
	// If not specified, the default is 50%.
	// To disable panic mode, set to 0%.
	//
	// .. note::
	//
	//	The specified percent will be truncated to the nearest 1%.
	HealthyPanicThreshold *v34.Percent `protobuf:"bytes,1,opt,name=healthy_panic_threshold,json=healthyPanicThreshold,proto3" json:"healthy_panic_threshold,omitempty"`
	// Types that are valid to be assigned to LocalityConfigSpecifier:
	//
	//	*Cluster_CommonLbConfig_ZoneAwareLbConfig_
	//	*Cluster_CommonLbConfig_LocalityWeightedLbConfig_
	LocalityConfigSpecifier isCluster_CommonLbConfig_LocalityConfigSpecifier `protobuf_oneof:"locality_config_specifier"`
	// If set, all health check/weight/metadata updates that happen within this duration will be
	// merged and delivered in one shot when the duration expires. The start of the duration is when
	// the first update happens. This is useful for big clusters, with potentially noisy deploys
	// that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
	// or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
	// cluster). Please always keep in mind that the use of sandbox technologies may change this
	// behavior.
	//
	// If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
	// window to 0.
	//
	// .. note::
	//
	//	Merging does not apply to cluster membership changes (e.g.: adds/removes); this is
	//	because merging those updates isn't currently safe. See
	//	https://github.com/envoyproxy/envoy/pull/3941.
	UpdateMergeWindow *durationpb.Duration `protobuf:"bytes,4,opt,name=update_merge_window,json=updateMergeWindow,proto3" json:"update_merge_window,omitempty"`
	// If set to true, Envoy will :ref:`exclude <arch_overview_load_balancing_excluded>` new hosts
	// when computing load balancing weights until they have been health checked for the first time.
	// This will have no effect unless active health checking is also configured.
	IgnoreNewHostsUntilFirstHc bool `protobuf:"varint,5,opt,name=ignore_new_hosts_until_first_hc,json=ignoreNewHostsUntilFirstHc,proto3" json:"ignore_new_hosts_until_first_hc,omitempty"`
	// If set to “true“, the cluster manager will drain all existing
	// connections to upstream hosts whenever hosts are added or removed from the cluster.
	CloseConnectionsOnHostSetChange bool `protobuf:"varint,6,opt,name=close_connections_on_host_set_change,json=closeConnectionsOnHostSetChange,proto3" json:"close_connections_on_host_set_change,omitempty"`
	// Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
	ConsistentHashingLbConfig *Cluster_CommonLbConfig_ConsistentHashingLbConfig `protobuf:"bytes,7,opt,name=consistent_hashing_lb_config,json=consistentHashingLbConfig,proto3" json:"consistent_hashing_lb_config,omitempty"`
	// This controls what hosts are considered valid when using
	// :ref:`host overrides <arch_overview_load_balancing_override_host>`, which is used by some
	// filters to modify the load balancing decision.
	//
	// If this is unset then [UNKNOWN, HEALTHY, DEGRADED] will be applied by default. If this is
	// set with an empty set of statuses then host overrides will be ignored by the load balancing.
	OverrideHostStatus *v33.HealthStatusSet `protobuf:"bytes,8,opt,name=override_host_status,json=overrideHostStatus,proto3" json:"override_host_status,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *Cluster_CommonLbConfig) Reset() {
	*x = Cluster_CommonLbConfig{}
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cluster_CommonLbConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cluster_CommonLbConfig) ProtoMessage() {}

func (x *Cluster_CommonLbConfig) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cluster_CommonLbConfig.ProtoReflect.Descriptor instead.
func (*Cluster_CommonLbConfig) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 10}
}

func (x *Cluster_CommonLbConfig) GetHealthyPanicThreshold() *v34.Percent {
	if x != nil {
		return x.HealthyPanicThreshold
	}
	return nil
}

func (x *Cluster_CommonLbConfig) GetLocalityConfigSpecifier() isCluster_CommonLbConfig_LocalityConfigSpecifier {
	if x != nil {
		return x.LocalityConfigSpecifier
	}
	return nil
}

func (x *Cluster_CommonLbConfig) GetZoneAwareLbConfig() *Cluster_CommonLbConfig_ZoneAwareLbConfig {
	if x != nil {
		if x, ok := x.LocalityConfigSpecifier.(*Cluster_CommonLbConfig_ZoneAwareLbConfig_); ok {
			return x.ZoneAwareLbConfig
		}
	}
	return nil
}

func (x *Cluster_CommonLbConfig) GetLocalityWeightedLbConfig() *Cluster_CommonLbConfig_LocalityWeightedLbConfig {
	if x != nil {
		if x, ok := x.LocalityConfigSpecifier.(*Cluster_CommonLbConfig_LocalityWeightedLbConfig_); ok {
			return x.LocalityWeightedLbConfig
		}
	}
	return nil
}

func (x *Cluster_CommonLbConfig) GetUpdateMergeWindow() *durationpb.Duration {
	if x != nil {
		return x.UpdateMergeWindow
	}
	return nil
}

func (x *Cluster_CommonLbConfig) GetIgnoreNewHostsUntilFirstHc() bool {
	if x != nil {
		return x.IgnoreNewHostsUntilFirstHc
	}
	return false
}

func (x *Cluster_CommonLbConfig) GetCloseConnectionsOnHostSetChange() bool {
	if x != nil {
		return x.CloseConnectionsOnHostSetChange
	}
	return false
}

func (x *Cluster_CommonLbConfig) GetConsistentHashingLbConfig() *Cluster_CommonLbConfig_ConsistentHashingLbConfig {
	if x != nil {
		return x.ConsistentHashingLbConfig
	}
	return nil
}

func (x *Cluster_CommonLbConfig) GetOverrideHostStatus() *v33.HealthStatusSet {
	if x != nil {
		return x.OverrideHostStatus
	}
	return nil
}

type isCluster_CommonLbConfig_LocalityConfigSpecifier interface {
	isCluster_CommonLbConfig_LocalityConfigSpecifier()
}

type Cluster_CommonLbConfig_ZoneAwareLbConfig_ struct {
	ZoneAwareLbConfig *Cluster_CommonLbConfig_ZoneAwareLbConfig `protobuf:"bytes,2,opt,name=zone_aware_lb_config,json=zoneAwareLbConfig,proto3,oneof"`
}

type Cluster_CommonLbConfig_LocalityWeightedLbConfig_ struct {
	LocalityWeightedLbConfig *Cluster_CommonLbConfig_LocalityWeightedLbConfig `protobuf:"bytes,3,opt,name=locality_weighted_lb_config,json=localityWeightedLbConfig,proto3,oneof"`
}

func (*Cluster_CommonLbConfig_ZoneAwareLbConfig_) isCluster_CommonLbConfig_LocalityConfigSpecifier() {
}

func (*Cluster_CommonLbConfig_LocalityWeightedLbConfig_) isCluster_CommonLbConfig_LocalityConfigSpecifier() {
}

type Cluster_RefreshRate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Specifies the base interval between refreshes. This parameter is required and must be greater
	// than zero and less than
	// :ref:`max_interval <envoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval>`.
	BaseInterval *durationpb.Duration `protobuf:"bytes,1,opt,name=base_interval,json=baseInterval,proto3" json:"base_interval,omitempty"`
	// Specifies the maximum interval between refreshes. This parameter is optional, but must be
	// greater than or equal to the
	// :ref:`base_interval <envoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval>`  if set. The default
	// is 10 times the :ref:`base_interval <envoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval>`.
	MaxInterval   *durationpb.Duration `protobuf:"bytes,2,opt,name=max_interval,json=maxInterval,proto3" json:"max_interval,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Cluster_RefreshRate) Reset() {
	*x = Cluster_RefreshRate{}
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cluster_RefreshRate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cluster_RefreshRate) ProtoMessage() {}

func (x *Cluster_RefreshRate) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cluster_RefreshRate.ProtoReflect.Descriptor instead.
func (*Cluster_RefreshRate) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 11}
}

func (x *Cluster_RefreshRate) GetBaseInterval() *durationpb.Duration {
	if x != nil {
		return x.BaseInterval
	}
	return nil
}

func (x *Cluster_RefreshRate) GetMaxInterval() *durationpb.Duration {
	if x != nil {
		return x.MaxInterval
	}
	return nil
}

type Cluster_PreconnectPolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Indicates how many streams (rounded up) can be anticipated per-upstream for each
	// incoming stream. This is useful for high-QPS or latency-sensitive services. Preconnecting
	// will only be done if the upstream is healthy and the cluster has traffic.
	//
	// For example if this is 2, for an incoming HTTP/1.1 stream, 2 connections will be
	// established, one for the new incoming stream, and one for a presumed follow-up stream. For
	// HTTP/2, only one connection would be established by default as one connection can
	// serve both the original and presumed follow-up stream.
	//
	// In steady state for non-multiplexed connections a value of 1.5 would mean if there were 100
	// active streams, there would be 100 connections in use, and 50 connections preconnected.
	// This might be a useful value for something like short lived single-use connections,
	// for example proxying HTTP/1.1 if keep-alive were false and each stream resulted in connection
	// termination. It would likely be overkill for long lived connections, such as TCP proxying SMTP
	// or regular HTTP/1.1 with keep-alive. For long lived traffic, a value of 1.05 would be more
	// reasonable, where for every 100 connections, 5 preconnected connections would be in the queue
	// in case of unexpected disconnects where the connection could not be reused.
	//
	// If this value is not set, or set explicitly to one, Envoy will fetch as many connections
	// as needed to serve streams in flight. This means in steady state if a connection is torn down,
	// a subsequent streams will pay an upstream-rtt latency penalty waiting for a new connection.
	//
	// This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can
	// harm latency more than the preconnecting helps.
	PerUpstreamPreconnectRatio *wrapperspb.DoubleValue `protobuf:"bytes,1,opt,name=per_upstream_preconnect_ratio,json=perUpstreamPreconnectRatio,proto3" json:"per_upstream_preconnect_ratio,omitempty"`
	// Indicates how many streams (rounded up) can be anticipated across a cluster for each
	// stream, useful for low QPS services. This is currently supported for a subset of
	// deterministic non-hash-based load-balancing algorithms (weighted round robin, random).
	// Unlike “per_upstream_preconnect_ratio“ this preconnects across the upstream instances in a
	// cluster, doing best effort predictions of what upstream would be picked next and
	// pre-establishing a connection.
	//
	// Preconnecting will be limited to one preconnect per configured upstream in the cluster and will
	// only be done if there are healthy upstreams and the cluster has traffic.
	//
	// For example if preconnecting is set to 2 for a round robin HTTP/2 cluster, on the first
	// incoming stream, 2 connections will be preconnected - one to the first upstream for this
	// cluster, one to the second on the assumption there will be a follow-up stream.
	//
	// If this value is not set, or set explicitly to one, Envoy will fetch as many connections
	// as needed to serve streams in flight, so during warm up and in steady state if a connection
	// is closed (and per_upstream_preconnect_ratio is not set), there will be a latency hit for
	// connection establishment.
	//
	// If both this and preconnect_ratio are set, Envoy will make sure both predicted needs are met,
	// basically preconnecting max(predictive-preconnect, per-upstream-preconnect), for each
	// upstream.
	//
	// This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can
	// harm latency more than the preconnecting helps.
	PredictivePreconnectRatio *wrapperspb.DoubleValue `protobuf:"bytes,2,opt,name=predictive_preconnect_ratio,json=predictivePreconnectRatio,proto3" json:"predictive_preconnect_ratio,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *Cluster_PreconnectPolicy) Reset() {
	*x = Cluster_PreconnectPolicy{}
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cluster_PreconnectPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cluster_PreconnectPolicy) ProtoMessage() {}

func (x *Cluster_PreconnectPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cluster_PreconnectPolicy.ProtoReflect.Descriptor instead.
func (*Cluster_PreconnectPolicy) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 12}
}

func (x *Cluster_PreconnectPolicy) GetPerUpstreamPreconnectRatio() *wrapperspb.DoubleValue {
	if x != nil {
		return x.PerUpstreamPreconnectRatio
	}
	return nil
}

func (x *Cluster_PreconnectPolicy) GetPredictivePreconnectRatio() *wrapperspb.DoubleValue {
	if x != nil {
		return x.PredictivePreconnectRatio
	}
	return nil
}

// Specifications for subsets.
type Cluster_LbSubsetConfig_LbSubsetSelector struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of keys to match with the weighted cluster metadata.
	Keys []string `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
	// Selects a mode of operation in which each subset has only one host. This mode uses the same rules for
	// choosing a host, but updating hosts is faster, especially for large numbers of hosts.
	//
	// If a match is found to a host, that host will be used regardless of priority levels.
	//
	// When this mode is enabled, configurations that contain more than one host with the same metadata value for the single key in “keys“
	// will use only one of the hosts with the given key; no requests will be routed to the others. The cluster gauge
	// :ref:`lb_subsets_single_host_per_subset_duplicate<config_cluster_manager_cluster_stats_subset_lb>` indicates how many duplicates are
	// present in the current configuration.
	SingleHostPerSubset bool `protobuf:"varint,4,opt,name=single_host_per_subset,json=singleHostPerSubset,proto3" json:"single_host_per_subset,omitempty"`
	// The behavior used when no endpoint subset matches the selected route's
	// metadata.
	FallbackPolicy Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy `protobuf:"varint,2,opt,name=fallback_policy,json=fallbackPolicy,proto3,enum=envoy.config.cluster.v3.Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy" json:"fallback_policy,omitempty"`
	// Subset of
	// :ref:`keys<envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys>` used by
	// :ref:`KEYS_SUBSET<envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET>`
	// fallback policy.
	// It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
	// For any other fallback policy the parameter is not used and should not be set.
	// Only values also present in
	// :ref:`keys<envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys>` are allowed, but
	// “fallback_keys_subset“ cannot be equal to “keys“.
	FallbackKeysSubset []string `protobuf:"bytes,3,rep,name=fallback_keys_subset,json=fallbackKeysSubset,proto3" json:"fallback_keys_subset,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *Cluster_LbSubsetConfig_LbSubsetSelector) Reset() {
	*x = Cluster_LbSubsetConfig_LbSubsetSelector{}
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cluster_LbSubsetConfig_LbSubsetSelector) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cluster_LbSubsetConfig_LbSubsetSelector) ProtoMessage() {}

func (x *Cluster_LbSubsetConfig_LbSubsetSelector) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cluster_LbSubsetConfig_LbSubsetSelector.ProtoReflect.Descriptor instead.
func (*Cluster_LbSubsetConfig_LbSubsetSelector) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 3, 0}
}

func (x *Cluster_LbSubsetConfig_LbSubsetSelector) GetKeys() []string {
	if x != nil {
		return x.Keys
	}
	return nil
}

func (x *Cluster_LbSubsetConfig_LbSubsetSelector) GetSingleHostPerSubset() bool {
	if x != nil {
		return x.SingleHostPerSubset
	}
	return false
}

func (x *Cluster_LbSubsetConfig_LbSubsetSelector) GetFallbackPolicy() Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy {
	if x != nil {
		return x.FallbackPolicy
	}
	return Cluster_LbSubsetConfig_LbSubsetSelector_NOT_DEFINED
}

func (x *Cluster_LbSubsetConfig_LbSubsetSelector) GetFallbackKeysSubset() []string {
	if x != nil {
		return x.FallbackKeysSubset
	}
	return nil
}

// Configuration for :ref:`zone aware routing
// <arch_overview_load_balancing_zone_aware_routing>`.
type Cluster_CommonLbConfig_ZoneAwareLbConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Configures percentage of requests that will be considered for zone aware routing
	// if zone aware routing is configured. If not specified, the default is 100%.
	// * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
	// * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
	RoutingEnabled *v34.Percent `protobuf:"bytes,1,opt,name=routing_enabled,json=routingEnabled,proto3" json:"routing_enabled,omitempty"`
	// Configures minimum upstream cluster size required for zone aware routing
	// If upstream cluster size is less than specified, zone aware routing is not performed
	// even if zone aware routing is configured. If not specified, the default is 6.
	// * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
	// * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
	MinClusterSize *wrapperspb.UInt64Value `protobuf:"bytes,2,opt,name=min_cluster_size,json=minClusterSize,proto3" json:"min_cluster_size,omitempty"`
	// If set to true, Envoy will not consider any hosts when the cluster is in :ref:`panic
	// mode<arch_overview_load_balancing_panic_threshold>`. Instead, the cluster will fail all
	// requests as if all hosts are unhealthy. This can help avoid potentially overwhelming a
	// failing service.
	FailTrafficOnPanic bool `protobuf:"varint,3,opt,name=fail_traffic_on_panic,json=failTrafficOnPanic,proto3" json:"fail_traffic_on_panic,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *Cluster_CommonLbConfig_ZoneAwareLbConfig) Reset() {
	*x = Cluster_CommonLbConfig_ZoneAwareLbConfig{}
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cluster_CommonLbConfig_ZoneAwareLbConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cluster_CommonLbConfig_ZoneAwareLbConfig) ProtoMessage() {}

func (x *Cluster_CommonLbConfig_ZoneAwareLbConfig) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cluster_CommonLbConfig_ZoneAwareLbConfig.ProtoReflect.Descriptor instead.
func (*Cluster_CommonLbConfig_ZoneAwareLbConfig) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 10, 0}
}

func (x *Cluster_CommonLbConfig_ZoneAwareLbConfig) GetRoutingEnabled() *v34.Percent {
	if x != nil {
		return x.RoutingEnabled
	}
	return nil
}

func (x *Cluster_CommonLbConfig_ZoneAwareLbConfig) GetMinClusterSize() *wrapperspb.UInt64Value {
	if x != nil {
		return x.MinClusterSize
	}
	return nil
}

func (x *Cluster_CommonLbConfig_ZoneAwareLbConfig) GetFailTrafficOnPanic() bool {
	if x != nil {
		return x.FailTrafficOnPanic
	}
	return false
}

// Configuration for :ref:`locality weighted load balancing
// <arch_overview_load_balancing_locality_weighted_lb>`
type Cluster_CommonLbConfig_LocalityWeightedLbConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Cluster_CommonLbConfig_LocalityWeightedLbConfig) Reset() {
	*x = Cluster_CommonLbConfig_LocalityWeightedLbConfig{}
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cluster_CommonLbConfig_LocalityWeightedLbConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cluster_CommonLbConfig_LocalityWeightedLbConfig) ProtoMessage() {}

func (x *Cluster_CommonLbConfig_LocalityWeightedLbConfig) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cluster_CommonLbConfig_LocalityWeightedLbConfig.ProtoReflect.Descriptor instead.
func (*Cluster_CommonLbConfig_LocalityWeightedLbConfig) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 10, 1}
}

// Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
type Cluster_CommonLbConfig_ConsistentHashingLbConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If set to “true“, the cluster will use hostname instead of the resolved
	// address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address.
	UseHostnameForHashing bool `protobuf:"varint,1,opt,name=use_hostname_for_hashing,json=useHostnameForHashing,proto3" json:"use_hostname_for_hashing,omitempty"`
	// Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
	// no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
	// If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
	// Minimum is 100.
	//
	// Applies to both Ring Hash and Maglev load balancers.
	//
	// This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
	// “hash_balance_factor“, requests to any upstream host are capped at “hash_balance_factor/100“ times the average number of requests
	// across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
	// is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
	// the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
	// cascading overflow effect when choosing the next host in the ring/table).
	//
	// If weights are specified on the hosts, they are respected.
	//
	// This is an O(N) algorithm, unlike other load balancers. Using a lower “hash_balance_factor“ results in more hosts
	// being probed, so use a higher value if you require better performance.
	HashBalanceFactor *wrapperspb.UInt32Value `protobuf:"bytes,2,opt,name=hash_balance_factor,json=hashBalanceFactor,proto3" json:"hash_balance_factor,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *Cluster_CommonLbConfig_ConsistentHashingLbConfig) Reset() {
	*x = Cluster_CommonLbConfig_ConsistentHashingLbConfig{}
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cluster_CommonLbConfig_ConsistentHashingLbConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cluster_CommonLbConfig_ConsistentHashingLbConfig) ProtoMessage() {}

func (x *Cluster_CommonLbConfig_ConsistentHashingLbConfig) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cluster_CommonLbConfig_ConsistentHashingLbConfig.ProtoReflect.Descriptor instead.
func (*Cluster_CommonLbConfig_ConsistentHashingLbConfig) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{1, 10, 2}
}

func (x *Cluster_CommonLbConfig_ConsistentHashingLbConfig) GetUseHostnameForHashing() bool {
	if x != nil {
		return x.UseHostnameForHashing
	}
	return false
}

func (x *Cluster_CommonLbConfig_ConsistentHashingLbConfig) GetHashBalanceFactor() *wrapperspb.UInt32Value {
	if x != nil {
		return x.HashBalanceFactor
	}
	return nil
}

type LoadBalancingPolicy_Policy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// [#extension-category: envoy.load_balancing_policies]
	TypedExtensionConfig *v33.TypedExtensionConfig `protobuf:"bytes,4,opt,name=typed_extension_config,json=typedExtensionConfig,proto3" json:"typed_extension_config,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *LoadBalancingPolicy_Policy) Reset() {
	*x = LoadBalancingPolicy_Policy{}
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LoadBalancingPolicy_Policy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoadBalancingPolicy_Policy) ProtoMessage() {}

func (x *LoadBalancingPolicy_Policy) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoadBalancingPolicy_Policy.ProtoReflect.Descriptor instead.
func (*LoadBalancingPolicy_Policy) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{2, 0}
}

func (x *LoadBalancingPolicy_Policy) GetTypedExtensionConfig() *v33.TypedExtensionConfig {
	if x != nil {
		return x.TypedExtensionConfig
	}
	return nil
}

type UpstreamConnectionOptions_HappyEyeballsConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Specify the IP address family to attempt connection first in happy
	// eyeballs algorithm according to RFC8305#section-4.
	FirstAddressFamilyVersion UpstreamConnectionOptions_FirstAddressFamilyVersion `protobuf:"varint,1,opt,name=first_address_family_version,json=firstAddressFamilyVersion,proto3,enum=envoy.config.cluster.v3.UpstreamConnectionOptions_FirstAddressFamilyVersion" json:"first_address_family_version,omitempty"`
	// Specify the number of addresses of the first_address_family_version being
	// attempted for connection before the other address family.
	FirstAddressFamilyCount *wrapperspb.UInt32Value `protobuf:"bytes,2,opt,name=first_address_family_count,json=firstAddressFamilyCount,proto3" json:"first_address_family_count,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *UpstreamConnectionOptions_HappyEyeballsConfig) Reset() {
	*x = UpstreamConnectionOptions_HappyEyeballsConfig{}
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpstreamConnectionOptions_HappyEyeballsConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpstreamConnectionOptions_HappyEyeballsConfig) ProtoMessage() {}

func (x *UpstreamConnectionOptions_HappyEyeballsConfig) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_config_cluster_v3_cluster_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpstreamConnectionOptions_HappyEyeballsConfig.ProtoReflect.Descriptor instead.
func (*UpstreamConnectionOptions_HappyEyeballsConfig) Descriptor() ([]byte, []int) {
	return file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP(), []int{3, 0}
}

func (x *UpstreamConnectionOptions_HappyEyeballsConfig) GetFirstAddressFamilyVersion() UpstreamConnectionOptions_FirstAddressFamilyVersion {
	if x != nil {
		return x.FirstAddressFamilyVersion
	}
	return UpstreamConnectionOptions_DEFAULT
}

func (x *UpstreamConnectionOptions_HappyEyeballsConfig) GetFirstAddressFamilyCount() *wrapperspb.UInt32Value {
	if x != nil {
		return x.FirstAddressFamilyCount
	}
	return nil
}

var File_envoy_config_cluster_v3_cluster_proto protoreflect.FileDescriptor

const file_envoy_config_cluster_v3_cluster_proto_rawDesc = "" +
	"\n" +
	"%envoy/config/cluster/v3/cluster.proto\x12\x17envoy.config.cluster.v3\x1a-envoy/config/cluster/v3/circuit_breaker.proto\x1a$envoy/config/cluster/v3/filter.proto\x1a/envoy/config/cluster/v3/outlier_detection.proto\x1a\"envoy/config/core/v3/address.proto\x1a\x1fenvoy/config/core/v3/base.proto\x1a(envoy/config/core/v3/config_source.proto\x1a$envoy/config/core/v3/extension.proto\x1a'envoy/config/core/v3/health_check.proto\x1a#envoy/config/core/v3/protocol.proto\x1a#envoy/config/core/v3/resolver.proto\x1a'envoy/config/endpoint/v3/endpoint.proto\x1a%envoy/type/metadata/v3/metadata.proto\x1a\x1benvoy/type/v3/percent.proto\x1a\x19google/protobuf/any.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1cgoogle/protobuf/struct.proto\x1a\x1egoogle/protobuf/wrappers.proto\x1a\"xds/core/v3/collection_entry.proto\x1a!xds/type/matcher/v3/matcher.proto\x1a#envoy/annotations/deprecation.proto\x1a\x1eudpa/annotations/migrate.proto\x1a\x1fudpa/annotations/security.proto\x1a\x1dudpa/annotations/status.proto\x1a!udpa/annotations/versioning.proto\x1a\x17validate/validate.proto\"K\n" +
	"\x11ClusterCollection\x126\n" +
	"\aentries\x18\x01 \x01(\v2\x1c.xds.core.v3.CollectionEntryR\aentries\"\xa2U\n" +
	"\aCluster\x12o\n" +
	"\x18transport_socket_matches\x18+ \x03(\v25.envoy.config.cluster.v3.Cluster.TransportSocketMatchR\x16transportSocketMatches\x12V\n" +
	"\x18transport_socket_matcher\x18; \x01(\v2\x1c.xds.type.matcher.v3.MatcherR\x16transportSocketMatcher\x12\x1b\n" +
	"\x04name\x18\x01 \x01(\tB\a\xfaB\x04r\x02\x10\x01R\x04name\x12>\n" +
	"\ralt_stat_name\x18\x1c \x01(\tB\x1a\xf2\x98\xfe\x8f\x05\x14\n" +
	"\x12observability_nameR\valtStatName\x12N\n" +
	"\x04type\x18\x02 \x01(\x0e2..envoy.config.cluster.v3.Cluster.DiscoveryTypeB\b\xfaB\x05\x82\x01\x02\x10\x01H\x00R\x04type\x12W\n" +
	"\fcluster_type\x18& \x01(\v22.envoy.config.cluster.v3.Cluster.CustomClusterTypeH\x00R\vclusterType\x12_\n" +
	"\x12eds_cluster_config\x18\x03 \x01(\v21.envoy.config.cluster.v3.Cluster.EdsClusterConfigR\x10edsClusterConfig\x12L\n" +
	"\x0fconnect_timeout\x18\x04 \x01(\v2\x19.google.protobuf.DurationB\b\xfaB\x05\xaa\x01\x02*\x00R\x0econnectTimeout\x12o\n" +
	"!per_connection_buffer_limit_bytes\x18\x05 \x01(\v2\x1c.google.protobuf.UInt32ValueB\a\x8a\x93\xb7*\x02\x10\x01R\x1dperConnectionBufferLimitBytes\x12P\n" +
	"\tlb_policy\x18\x06 \x01(\x0e2).envoy.config.cluster.v3.Cluster.LbPolicyB\b\xfaB\x05\x82\x01\x02\x10\x01R\blbPolicy\x12X\n" +
	"\x0fload_assignment\x18! \x01(\v2/.envoy.config.endpoint.v3.ClusterLoadAssignmentR\x0eloadAssignment\x12F\n" +
	"\rhealth_checks\x18\b \x03(\v2!.envoy.config.core.v3.HealthCheckR\fhealthChecks\x12h\n" +
	"\x1bmax_requests_per_connection\x18\t \x01(\v2\x1c.google.protobuf.UInt32ValueB\v\x92ǆ\xd8\x04\x033.0\x18\x01R\x18maxRequestsPerConnection\x12S\n" +
	"\x10circuit_breakers\x18\n" +
	" \x01(\v2(.envoy.config.cluster.v3.CircuitBreakersR\x0fcircuitBreakers\x12\x83\x01\n" +
	"\x1eupstream_http_protocol_options\x18. \x01(\v21.envoy.config.core.v3.UpstreamHttpProtocolOptionsB\v\x92ǆ\xd8\x04\x033.0\x18\x01R\x1bupstreamHttpProtocolOptions\x12w\n" +
	"\x1ccommon_http_protocol_options\x18\x1d \x01(\v2).envoy.config.core.v3.HttpProtocolOptionsB\v\x92ǆ\xd8\x04\x033.0\x18\x01R\x19commonHttpProtocolOptions\x12k\n" +
	"\x15http_protocol_options\x18\r \x01(\v2*.envoy.config.core.v3.Http1ProtocolOptionsB\v\x92ǆ\xd8\x04\x033.0\x18\x01R\x13httpProtocolOptions\x12t\n" +
	"\x16http2_protocol_options\x18\x0e \x01(\v2*.envoy.config.core.v3.Http2ProtocolOptionsB\x12\x8a\x93\xb7*\x02\x10\x01\x92ǆ\xd8\x04\x033.0\x18\x01R\x14http2ProtocolOptions\x12\x8c\x01\n" +
	" typed_extension_protocol_options\x18$ \x03(\v2C.envoy.config.cluster.v3.Cluster.TypedExtensionProtocolOptionsEntryR\x1dtypedExtensionProtocolOptions\x12\\\n" +
	"\x10dns_refresh_rate\x18\x10 \x01(\v2\x19.google.protobuf.DurationB\x17\xfaB\t\xaa\x01\x06*\x04\x10\xc0\x84=\x92ǆ\xd8\x04\x033.0\x18\x01R\x0ednsRefreshRate\x12M\n" +
	"\n" +
	"dns_jitter\x18: \x01(\v2\x19.google.protobuf.DurationB\x13\xfaB\x05\xaa\x01\x022\x00\x92ǆ\xd8\x04\x033.0\x18\x01R\tdnsJitter\x12r\n" +
	"\x18dns_failure_refresh_rate\x18, \x01(\v2,.envoy.config.cluster.v3.Cluster.RefreshRateB\v\x92ǆ\xd8\x04\x033.0\x18\x01R\x15dnsFailureRefreshRate\x123\n" +
	"\x0frespect_dns_ttl\x18' \x01(\bB\v\x92ǆ\xd8\x04\x033.0\x18\x01R\rrespectDnsTtl\x12f\n" +
	"\x11dns_lookup_family\x18\x11 \x01(\x0e20.envoy.config.cluster.v3.Cluster.DnsLookupFamilyB\b\xfaB\x05\x82\x01\x02\x10\x01R\x0fdnsLookupFamily\x12O\n" +
	"\rdns_resolvers\x18\x12 \x03(\v2\x1d.envoy.config.core.v3.AddressB\v\x92ǆ\xd8\x04\x033.0\x18\x01R\fdnsResolvers\x12A\n" +
	"\x17use_tcp_for_dns_lookups\x18- \x01(\bB\v\x92ǆ\xd8\x04\x033.0\x18\x01R\x13useTcpForDnsLookups\x12j\n" +
	"\x15dns_resolution_config\x185 \x01(\v2).envoy.config.core.v3.DnsResolutionConfigB\v\x92ǆ\xd8\x04\x033.0\x18\x01R\x13dnsResolutionConfig\x12e\n" +
	"\x19typed_dns_resolver_config\x187 \x01(\v2*.envoy.config.core.v3.TypedExtensionConfigR\x16typedDnsResolverConfig\x12L\n" +
	"\x15wait_for_warm_on_init\x186 \x01(\v2\x1a.google.protobuf.BoolValueR\x11waitForWarmOnInit\x12V\n" +
	"\x11outlier_detection\x18\x13 \x01(\v2).envoy.config.cluster.v3.OutlierDetectionR\x10outlierDetection\x12N\n" +
	"\x10cleanup_interval\x18\x14 \x01(\v2\x19.google.protobuf.DurationB\b\xfaB\x05\xaa\x01\x02*\x00R\x0fcleanupInterval\x12R\n" +
	"\x14upstream_bind_config\x18\x15 \x01(\v2 .envoy.config.core.v3.BindConfigR\x12upstreamBindConfig\x12Y\n" +
	"\x10lb_subset_config\x18\x16 \x01(\v2/.envoy.config.cluster.v3.Cluster.LbSubsetConfigR\x0elbSubsetConfig\x12b\n" +
	"\x13ring_hash_lb_config\x18\x17 \x01(\v21.envoy.config.cluster.v3.Cluster.RingHashLbConfigH\x01R\x10ringHashLbConfig\x12[\n" +
	"\x10maglev_lb_config\x184 \x01(\v2/.envoy.config.cluster.v3.Cluster.MaglevLbConfigH\x01R\x0emaglevLbConfig\x12k\n" +
	"\x16original_dst_lb_config\x18\" \x01(\v24.envoy.config.cluster.v3.Cluster.OriginalDstLbConfigH\x01R\x13originalDstLbConfig\x12n\n" +
	"\x17least_request_lb_config\x18% \x01(\v25.envoy.config.cluster.v3.Cluster.LeastRequestLbConfigH\x01R\x14leastRequestLbConfig\x12h\n" +
	"\x15round_robin_lb_config\x188 \x01(\v23.envoy.config.cluster.v3.Cluster.RoundRobinLbConfigH\x01R\x12roundRobinLbConfig\x12Y\n" +
	"\x10common_lb_config\x18\x1b \x01(\v2/.envoy.config.cluster.v3.Cluster.CommonLbConfigR\x0ecommonLbConfig\x12P\n" +
	"\x10transport_socket\x18\x18 \x01(\v2%.envoy.config.core.v3.TransportSocketR\x0ftransportSocket\x12:\n" +
	"\bmetadata\x18\x19 \x01(\v2\x1e.envoy.config.core.v3.MetadataR\bmetadata\x12u\n" +
	"\x12protocol_selection\x18\x1a \x01(\x0e29.envoy.config.cluster.v3.Cluster.ClusterProtocolSelectionB\v\x92ǆ\xd8\x04\x033.0\x18\x01R\x11protocolSelection\x12r\n" +
	"\x1bupstream_connection_options\x18\x1e \x01(\v22.envoy.config.cluster.v3.UpstreamConnectionOptionsR\x19upstreamConnectionOptions\x12U\n" +
	"(close_connections_on_host_health_failure\x18\x1f \x01(\bR#closeConnectionsOnHostHealthFailure\x12@\n" +
	"\x1dignore_health_on_host_removal\x18  \x01(\bR\x19ignoreHealthOnHostRemoval\x129\n" +
	"\afilters\x18( \x03(\v2\x1f.envoy.config.cluster.v3.FilterR\afilters\x12`\n" +
	"\x15load_balancing_policy\x18) \x01(\v2,.envoy.config.cluster.v3.LoadBalancingPolicyR\x13loadBalancingPolicy\x12A\n" +
	"\n" +
	"lrs_server\x18* \x01(\v2\".envoy.config.core.v3.ConfigSourceR\tlrsServer\x12=\n" +
	"\x1blrs_report_endpoint_metrics\x189 \x03(\tR\x18lrsReportEndpointMetrics\x12?\n" +
	"\x15track_timeout_budgets\x18/ \x01(\bB\v\x92ǆ\xd8\x04\x033.0\x18\x01R\x13trackTimeoutBudgets\x12S\n" +
	"\x0fupstream_config\x180 \x01(\v2*.envoy.config.core.v3.TypedExtensionConfigR\x0eupstreamConfig\x12Z\n" +
	"\x13track_cluster_stats\x181 \x01(\v2*.envoy.config.cluster.v3.TrackClusterStatsR\x11trackClusterStats\x12^\n" +
	"\x11preconnect_policy\x182 \x01(\v21.envoy.config.cluster.v3.Cluster.PreconnectPolicyR\x10preconnectPolicy\x12X\n" +
	")connection_pool_per_downstream_connection\x183 \x01(\bR%connectionPoolPerDownstreamConnection\x1a\xe6\x01\n" +
	"\x14TransportSocketMatch\x12\x1b\n" +
	"\x04name\x18\x01 \x01(\tB\a\xfaB\x04r\x02\x10\x01R\x04name\x12-\n" +
	"\x05match\x18\x02 \x01(\v2\x17.google.protobuf.StructR\x05match\x12P\n" +
	"\x10transport_socket\x18\x03 \x01(\v2%.envoy.config.core.v3.TransportSocketR\x0ftransportSocket:0\x9aň\x1e+\n" +
	")envoy.api.v2.Cluster.TransportSocketMatch\x1a\x98\x01\n" +
	"\x11CustomClusterType\x12\x1b\n" +
	"\x04name\x18\x01 \x01(\tB\a\xfaB\x04r\x02\x10\x01R\x04name\x127\n" +
	"\ftyped_config\x18\x02 \x01(\v2\x14.google.protobuf.AnyR\vtypedConfig:-\x9aň\x1e(\n" +
	"&envoy.api.v2.Cluster.CustomClusterType\x1a\xa6\x01\n" +
	"\x10EdsClusterConfig\x12A\n" +
	"\n" +
	"eds_config\x18\x01 \x01(\v2\".envoy.config.core.v3.ConfigSourceR\tedsConfig\x12!\n" +
	"\fservice_name\x18\x02 \x01(\tR\vserviceName:,\x9aň\x1e'\n" +
	"%envoy.api.v2.Cluster.EdsClusterConfig\x1a\xa4\n" +
	"\n" +
	"\x0eLbSubsetConfig\x12y\n" +
	"\x0ffallback_policy\x18\x01 \x01(\x0e2F.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicyB\b\xfaB\x05\x82\x01\x02\x10\x01R\x0efallbackPolicy\x12>\n" +
	"\x0edefault_subset\x18\x02 \x01(\v2\x17.google.protobuf.StructR\rdefaultSubset\x12k\n" +
	"\x10subset_selectors\x18\x03 \x03(\v2@.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelectorR\x0fsubsetSelectors\x122\n" +
	"\x15locality_weight_aware\x18\x04 \x01(\bR\x13localityWeightAware\x122\n" +
	"\x15scale_locality_weight\x18\x05 \x01(\bR\x13scaleLocalityWeight\x12$\n" +
	"\x0epanic_mode_any\x18\x06 \x01(\bR\fpanicModeAny\x12\x1e\n" +
	"\vlist_as_any\x18\a \x01(\bR\tlistAsAny\x12\x92\x01\n" +
	"\x18metadata_fallback_policy\x18\b \x01(\x0e2N.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetMetadataFallbackPolicyB\b\xfaB\x05\x82\x01\x02\x10\x01R\x16metadataFallbackPolicy\x1a\xda\x03\n" +
	"\x10LbSubsetSelector\x12\x12\n" +
	"\x04keys\x18\x01 \x03(\tR\x04keys\x123\n" +
	"\x16single_host_per_subset\x18\x04 \x01(\bR\x13singleHostPerSubset\x12\x92\x01\n" +
	"\x0ffallback_policy\x18\x02 \x01(\x0e2_.envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicyB\b\xfaB\x05\x82\x01\x02\x10\x01R\x0efallbackPolicy\x120\n" +
	"\x14fallback_keys_subset\x18\x03 \x03(\tR\x12fallbackKeysSubset\"y\n" +
	"\x1eLbSubsetSelectorFallbackPolicy\x12\x0f\n" +
	"\vNOT_DEFINED\x10\x00\x12\x0f\n" +
	"\vNO_FALLBACK\x10\x01\x12\x10\n" +
	"\fANY_ENDPOINT\x10\x02\x12\x12\n" +
	"\x0eDEFAULT_SUBSET\x10\x03\x12\x0f\n" +
	"\vKEYS_SUBSET\x10\x04:;\x9aň\x1e6\n" +
	"4envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector\"O\n" +
	"\x16LbSubsetFallbackPolicy\x12\x0f\n" +
	"\vNO_FALLBACK\x10\x00\x12\x10\n" +
	"\fANY_ENDPOINT\x10\x01\x12\x12\n" +
	"\x0eDEFAULT_SUBSET\x10\x02\"M\n" +
	"\x1eLbSubsetMetadataFallbackPolicy\x12\x18\n" +
	"\x14METADATA_NO_FALLBACK\x10\x00\x12\x11\n" +
	"\rFALLBACK_LIST\x10\x01:*\x9aň\x1e%\n" +
	"#envoy.api.v2.Cluster.LbSubsetConfig\x1a\xe3\x01\n" +
	"\x0fSlowStartConfig\x12E\n" +
	"\x11slow_start_window\x18\x01 \x01(\v2\x19.google.protobuf.DurationR\x0fslowStartWindow\x12C\n" +
	"\n" +
	"aggression\x18\x02 \x01(\v2#.envoy.config.core.v3.RuntimeDoubleR\n" +
	"aggression\x12D\n" +
	"\x12min_weight_percent\x18\x03 \x01(\v2\x16.envoy.type.v3.PercentR\x10minWeightPercent\x1ar\n" +
	"\x12RoundRobinLbConfig\x12\\\n" +
	"\x11slow_start_config\x18\x01 \x01(\v20.envoy.config.cluster.v3.Cluster.SlowStartConfigR\x0fslowStartConfig\x1a\xc5\x02\n" +
	"\x14LeastRequestLbConfig\x12H\n" +
	"\fchoice_count\x18\x01 \x01(\v2\x1c.google.protobuf.UInt32ValueB\a\xfaB\x04*\x02(\x02R\vchoiceCount\x12S\n" +
	"\x13active_request_bias\x18\x02 \x01(\v2#.envoy.config.core.v3.RuntimeDoubleR\x11activeRequestBias\x12\\\n" +
	"\x11slow_start_config\x18\x03 \x01(\v20.envoy.config.cluster.v3.Cluster.SlowStartConfigR\x0fslowStartConfig:0\x9aň\x1e+\n" +
	")envoy.api.v2.Cluster.LeastRequestLbConfig\x1a\x91\x03\n" +
	"\x10RingHashLbConfig\x12T\n" +
	"\x11minimum_ring_size\x18\x01 \x01(\v2\x1c.google.protobuf.UInt64ValueB\n" +
	"\xfaB\a2\x05\x18\x80\x80\x80\x04R\x0fminimumRingSize\x12m\n" +
	"\rhash_function\x18\x03 \x01(\x0e2>.envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunctionB\b\xfaB\x05\x82\x01\x02\x10\x01R\fhashFunction\x12T\n" +
	"\x11maximum_ring_size\x18\x04 \x01(\v2\x1c.google.protobuf.UInt64ValueB\n" +
	"\xfaB\a2\x05\x18\x80\x80\x80\x04R\x0fmaximumRingSize\".\n" +
	"\fHashFunction\x12\v\n" +
	"\aXX_HASH\x10\x00\x12\x11\n" +
	"\rMURMUR_HASH_2\x10\x01:,\x9aň\x1e'\n" +
	"%envoy.api.v2.Cluster.RingHashLbConfigJ\x04\b\x02\x10\x03\x1aY\n" +
	"\x0eMaglevLbConfig\x12G\n" +
	"\n" +
	"table_size\x18\x01 \x01(\v2\x1c.google.protobuf.UInt64ValueB\n" +
	"\xfaB\a2\x05\x18˖\xb1\x02R\ttableSize\x1a\xbf\x02\n" +
	"\x13OriginalDstLbConfig\x12&\n" +
	"\x0fuse_http_header\x18\x01 \x01(\bR\ruseHttpHeader\x12(\n" +
	"\x10http_header_name\x18\x02 \x01(\tR\x0ehttpHeaderName\x12]\n" +
	"\x16upstream_port_override\x18\x03 \x01(\v2\x1c.google.protobuf.UInt32ValueB\t\xfaB\x06*\x04\x18\xff\xff\x03R\x14upstreamPortOverride\x12F\n" +
	"\fmetadata_key\x18\x04 \x01(\v2#.envoy.type.metadata.v3.MetadataKeyR\vmetadataKey:/\x9aň\x1e*\n" +
	"(envoy.api.v2.Cluster.OriginalDstLbConfig\x1a\xd5\v\n" +
	"\x0eCommonLbConfig\x12N\n" +
	"\x17healthy_panic_threshold\x18\x01 \x01(\v2\x16.envoy.type.v3.PercentR\x15healthyPanicThreshold\x12t\n" +
	"\x14zone_aware_lb_config\x18\x02 \x01(\v2A.envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfigH\x00R\x11zoneAwareLbConfig\x12\x89\x01\n" +
	"\x1blocality_weighted_lb_config\x18\x03 \x01(\v2H.envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfigH\x00R\x18localityWeightedLbConfig\x12I\n" +
	"\x13update_merge_window\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\x11updateMergeWindow\x12C\n" +
	"\x1fignore_new_hosts_until_first_hc\x18\x05 \x01(\bR\x1aignoreNewHostsUntilFirstHc\x12M\n" +
	"$close_connections_on_host_set_change\x18\x06 \x01(\bR\x1fcloseConnectionsOnHostSetChange\x12\x8a\x01\n" +
	"\x1cconsistent_hashing_lb_config\x18\a \x01(\v2I.envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfigR\x19consistentHashingLbConfig\x12W\n" +
	"\x14override_host_status\x18\b \x01(\v2%.envoy.config.core.v3.HealthStatusSetR\x12overrideHostStatus\x1a\x8d\x02\n" +
	"\x11ZoneAwareLbConfig\x12?\n" +
	"\x0frouting_enabled\x18\x01 \x01(\v2\x16.envoy.type.v3.PercentR\x0eroutingEnabled\x12F\n" +
	"\x10min_cluster_size\x18\x02 \x01(\v2\x1c.google.protobuf.UInt64ValueR\x0eminClusterSize\x121\n" +
	"\x15fail_traffic_on_panic\x18\x03 \x01(\bR\x12failTrafficOnPanic:<\x9aň\x1e7\n" +
	"5envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig\x1a_\n" +
	"\x18LocalityWeightedLbConfig:C\x9aň\x1e>\n" +
	"<envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig\x1a\xf1\x01\n" +
	"\x19ConsistentHashingLbConfig\x127\n" +
	"\x18use_hostname_for_hashing\x18\x01 \x01(\bR\x15useHostnameForHashing\x12U\n" +
	"\x13hash_balance_factor\x18\x02 \x01(\v2\x1c.google.protobuf.UInt32ValueB\a\xfaB\x04*\x02(dR\x11hashBalanceFactor:D\x9aň\x1e?\n" +
	"=envoy.api.v2.Cluster.CommonLbConfig.ConsistentHashingLbConfig:*\x9aň\x1e%\n" +
	"#envoy.api.v2.Cluster.CommonLbConfigB\x1b\n" +
	"\x19locality_config_specifier\x1a\xd2\x01\n" +
	"\vRefreshRate\x12N\n" +
	"\rbase_interval\x18\x01 \x01(\v2\x19.google.protobuf.DurationB\x0e\xfaB\v\xaa\x01\b\b\x01*\x04\x10\xc0\x84=R\fbaseInterval\x12J\n" +
	"\fmax_interval\x18\x02 \x01(\v2\x19.google.protobuf.DurationB\f\xfaB\t\xaa\x01\x06*\x04\x10\xc0\x84=R\vmaxInterval:'\x9aň\x1e\"\n" +
	" envoy.api.v2.Cluster.RefreshRate\x1a\x83\x02\n" +
	"\x10PreconnectPolicy\x12x\n" +
	"\x1dper_upstream_preconnect_ratio\x18\x01 \x01(\v2\x1c.google.protobuf.DoubleValueB\x17\xfaB\x14\x12\x12\x19\x00\x00\x00\x00\x00\x00\b@)\x00\x00\x00\x00\x00\x00\xf0?R\x1aperUpstreamPreconnectRatio\x12u\n" +
	"\x1bpredictive_preconnect_ratio\x18\x02 \x01(\v2\x1c.google.protobuf.DoubleValueB\x17\xfaB\x14\x12\x12\x19\x00\x00\x00\x00\x00\x00\b@)\x00\x00\x00\x00\x00\x00\xf0?R\x19predictivePreconnectRatio\x1af\n" +
	"\"TypedExtensionProtocolOptionsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12*\n" +
	"\x05value\x18\x02 \x01(\v2\x14.google.protobuf.AnyR\x05value:\x028\x01\"W\n" +
	"\rDiscoveryType\x12\n" +
	"\n" +
	"\x06STATIC\x10\x00\x12\x0e\n" +
	"\n" +
	"STRICT_DNS\x10\x01\x12\x0f\n" +
	"\vLOGICAL_DNS\x10\x02\x12\a\n" +
	"\x03EDS\x10\x03\x12\x10\n" +
	"\fORIGINAL_DST\x10\x04\"\xa4\x01\n" +
	"\bLbPolicy\x12\x0f\n" +
	"\vROUND_ROBIN\x10\x00\x12\x11\n" +
	"\rLEAST_REQUEST\x10\x01\x12\r\n" +
	"\tRING_HASH\x10\x02\x12\n" +
	"\n" +
	"\x06RANDOM\x10\x03\x12\n" +
	"\n" +
	"\x06MAGLEV\x10\x05\x12\x14\n" +
	"\x10CLUSTER_PROVIDED\x10\x06\x12 \n" +
	"\x1cLOAD_BALANCING_POLICY_CONFIG\x10\a\"\x04\b\x04\x10\x04*\x0fORIGINAL_DST_LB\"P\n" +
	"\x0fDnsLookupFamily\x12\b\n" +
	"\x04AUTO\x10\x00\x12\v\n" +
	"\aV4_ONLY\x10\x01\x12\v\n" +
	"\aV6_ONLY\x10\x02\x12\x10\n" +
	"\fV4_PREFERRED\x10\x03\x12\a\n" +
	"\x03ALL\x10\x04\"T\n" +
	"\x18ClusterProtocolSelection\x12\x1b\n" +
	"\x17USE_CONFIGURED_PROTOCOL\x10\x00\x12\x1b\n" +
	"\x17USE_DOWNSTREAM_PROTOCOL\x10\x01:\x1b\x9aň\x1e\x16\n" +
	"\x14envoy.api.v2.ClusterB\x18\n" +
	"\x16cluster_discovery_typeB\v\n" +
	"\tlb_configJ\x04\b\f\x10\rJ\x04\b\x0f\x10\x10J\x04\b\a\x10\bJ\x04\b\v\x10\fJ\x04\b#\x10$R\x05hostsR\vtls_contextR\x1aextension_protocol_options\"\xda\x02\n" +
	"\x13LoadBalancingPolicy\x12O\n" +
	"\bpolicies\x18\x01 \x03(\v23.envoy.config.cluster.v3.LoadBalancingPolicy.PolicyR\bpolicies\x1a\xc8\x01\n" +
	"\x06Policy\x12`\n" +
	"\x16typed_extension_config\x18\x04 \x01(\v2*.envoy.config.core.v3.TypedExtensionConfigR\x14typedExtensionConfig:.\x9aň\x1e)\n" +
	"'envoy.api.v2.LoadBalancingPolicy.PolicyJ\x04\b\x02\x10\x03J\x04\b\x01\x10\x02J\x04\b\x03\x10\x04R\x06configR\x04nameR\ftyped_config:'\x9aň\x1e\"\n" +
	" envoy.api.v2.LoadBalancingPolicy\"\xbb\x05\n" +
	"\x19UpstreamConnectionOptions\x12G\n" +
	"\rtcp_keepalive\x18\x01 \x01(\v2\".envoy.config.core.v3.TcpKeepaliveR\ftcpKeepalive\x12d\n" +
	"0set_local_interface_name_on_upstream_connections\x18\x02 \x01(\bR*setLocalInterfaceNameOnUpstreamConnections\x12z\n" +
	"\x15happy_eyeballs_config\x18\x03 \x01(\v2F.envoy.config.cluster.v3.UpstreamConnectionOptions.HappyEyeballsConfigR\x13happyEyeballsConfig\x1a\x89\x02\n" +
	"\x13HappyEyeballsConfig\x12\x8d\x01\n" +
	"\x1cfirst_address_family_version\x18\x01 \x01(\x0e2L.envoy.config.cluster.v3.UpstreamConnectionOptions.FirstAddressFamilyVersionR\x19firstAddressFamilyVersion\x12b\n" +
	"\x1afirst_address_family_count\x18\x02 \x01(\v2\x1c.google.protobuf.UInt32ValueB\a\xfaB\x04*\x02(\x01R\x17firstAddressFamilyCount\"8\n" +
	"\x19FirstAddressFamilyVersion\x12\v\n" +
	"\aDEFAULT\x10\x00\x12\x06\n" +
	"\x02V4\x10\x01\x12\x06\n" +
	"\x02V6\x10\x02:-\x9aň\x1e(\n" +
	"&envoy.api.v2.UpstreamConnectionOptions\"\xa0\x01\n" +
	"\x11TrackClusterStats\x12'\n" +
	"\x0ftimeout_budgets\x18\x01 \x01(\bR\x0etimeoutBudgets\x124\n" +
	"\x16request_response_sizes\x18\x02 \x01(\bR\x14requestResponseSizes\x12,\n" +
	"\x12per_endpoint_stats\x18\x03 \x01(\bR\x10perEndpointStatsB\x89\x01\xba\x80\xc8\xd1\x06\x02\x10\x02\n" +
	"%io.envoyproxy.envoy.config.cluster.v3B\fClusterProtoP\x01ZHgithub.com/envoyproxy/go-control-plane/envoy/config/cluster/v3;clusterv3b\x06proto3"

var (
	file_envoy_config_cluster_v3_cluster_proto_rawDescOnce sync.Once
	file_envoy_config_cluster_v3_cluster_proto_rawDescData []byte
)

func file_envoy_config_cluster_v3_cluster_proto_rawDescGZIP() []byte {
	file_envoy_config_cluster_v3_cluster_proto_rawDescOnce.Do(func() {
		file_envoy_config_cluster_v3_cluster_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_envoy_config_cluster_v3_cluster_proto_rawDesc), len(file_envoy_config_cluster_v3_cluster_proto_rawDesc)))
	})
	return file_envoy_config_cluster_v3_cluster_proto_rawDescData
}

var file_envoy_config_cluster_v3_cluster_proto_enumTypes = make([]protoimpl.EnumInfo, 9)
var file_envoy_config_cluster_v3_cluster_proto_msgTypes = make([]protoimpl.MessageInfo, 25)
var file_envoy_config_cluster_v3_cluster_proto_goTypes = []any{
	(Cluster_DiscoveryType)(0),                                                  // 0: envoy.config.cluster.v3.Cluster.DiscoveryType
	(Cluster_LbPolicy)(0),                                                       // 1: envoy.config.cluster.v3.Cluster.LbPolicy
	(Cluster_DnsLookupFamily)(0),                                                // 2: envoy.config.cluster.v3.Cluster.DnsLookupFamily
	(Cluster_ClusterProtocolSelection)(0),                                       // 3: envoy.config.cluster.v3.Cluster.ClusterProtocolSelection
	(Cluster_LbSubsetConfig_LbSubsetFallbackPolicy)(0),                          // 4: envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy
	(Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy)(0),                  // 5: envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetMetadataFallbackPolicy
	(Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy)(0), // 6: envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy
	(Cluster_RingHashLbConfig_HashFunction)(0),                                  // 7: envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction
	(UpstreamConnectionOptions_FirstAddressFamilyVersion)(0),                    // 8: envoy.config.cluster.v3.UpstreamConnectionOptions.FirstAddressFamilyVersion
	(*ClusterCollection)(nil),                                                   // 9: envoy.config.cluster.v3.ClusterCollection
	(*Cluster)(nil),                                                             // 10: envoy.config.cluster.v3.Cluster
	(*LoadBalancingPolicy)(nil),                                                 // 11: envoy.config.cluster.v3.LoadBalancingPolicy
	(*UpstreamConnectionOptions)(nil),                                           // 12: envoy.config.cluster.v3.UpstreamConnectionOptions
	(*TrackClusterStats)(nil),                                                   // 13: envoy.config.cluster.v3.TrackClusterStats
	(*Cluster_TransportSocketMatch)(nil),                                        // 14: envoy.config.cluster.v3.Cluster.TransportSocketMatch
	(*Cluster_CustomClusterType)(nil),                                           // 15: envoy.config.cluster.v3.Cluster.CustomClusterType
	(*Cluster_EdsClusterConfig)(nil),                                            // 16: envoy.config.cluster.v3.Cluster.EdsClusterConfig
	(*Cluster_LbSubsetConfig)(nil),                                              // 17: envoy.config.cluster.v3.Cluster.LbSubsetConfig
	(*Cluster_SlowStartConfig)(nil),                                             // 18: envoy.config.cluster.v3.Cluster.SlowStartConfig
	(*Cluster_RoundRobinLbConfig)(nil),                                          // 19: envoy.config.cluster.v3.Cluster.RoundRobinLbConfig
	(*Cluster_LeastRequestLbConfig)(nil),                                        // 20: envoy.config.cluster.v3.Cluster.LeastRequestLbConfig
	(*Cluster_RingHashLbConfig)(nil),                                            // 21: envoy.config.cluster.v3.Cluster.RingHashLbConfig
	(*Cluster_MaglevLbConfig)(nil),                                              // 22: envoy.config.cluster.v3.Cluster.MaglevLbConfig
	(*Cluster_OriginalDstLbConfig)(nil),                                         // 23: envoy.config.cluster.v3.Cluster.OriginalDstLbConfig
	(*Cluster_CommonLbConfig)(nil),                                              // 24: envoy.config.cluster.v3.Cluster.CommonLbConfig
	(*Cluster_RefreshRate)(nil),                                                 // 25: envoy.config.cluster.v3.Cluster.RefreshRate
	(*Cluster_PreconnectPolicy)(nil),                                            // 26: envoy.config.cluster.v3.Cluster.PreconnectPolicy
	nil,                                                                         // 27: envoy.config.cluster.v3.Cluster.TypedExtensionProtocolOptionsEntry
	(*Cluster_LbSubsetConfig_LbSubsetSelector)(nil),                             // 28: envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector
	(*Cluster_CommonLbConfig_ZoneAwareLbConfig)(nil),                            // 29: envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig
	(*Cluster_CommonLbConfig_LocalityWeightedLbConfig)(nil),                     // 30: envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig
	(*Cluster_CommonLbConfig_ConsistentHashingLbConfig)(nil),                    // 31: envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig
	(*LoadBalancingPolicy_Policy)(nil),                                          // 32: envoy.config.cluster.v3.LoadBalancingPolicy.Policy
	(*UpstreamConnectionOptions_HappyEyeballsConfig)(nil),                       // 33: envoy.config.cluster.v3.UpstreamConnectionOptions.HappyEyeballsConfig
	(*v3.CollectionEntry)(nil),                                                  // 34: xds.core.v3.CollectionEntry
	(*v31.Matcher)(nil),                                                         // 35: xds.type.matcher.v3.Matcher
	(*durationpb.Duration)(nil),                                                 // 36: google.protobuf.Duration
	(*wrapperspb.UInt32Value)(nil),                                              // 37: google.protobuf.UInt32Value
	(*v32.ClusterLoadAssignment)(nil),                                           // 38: envoy.config.endpoint.v3.ClusterLoadAssignment
	(*v33.HealthCheck)(nil),                                                     // 39: envoy.config.core.v3.HealthCheck
	(*CircuitBreakers)(nil),                                                     // 40: envoy.config.cluster.v3.CircuitBreakers
	(*v33.UpstreamHttpProtocolOptions)(nil),                                     // 41: envoy.config.core.v3.UpstreamHttpProtocolOptions
	(*v33.HttpProtocolOptions)(nil),                                             // 42: envoy.config.core.v3.HttpProtocolOptions
	(*v33.Http1ProtocolOptions)(nil),                                            // 43: envoy.config.core.v3.Http1ProtocolOptions
	(*v33.Http2ProtocolOptions)(nil),                                            // 44: envoy.config.core.v3.Http2ProtocolOptions
	(*v33.Address)(nil),                                                         // 45: envoy.config.core.v3.Address
	(*v33.DnsResolutionConfig)(nil),                                             // 46: envoy.config.core.v3.DnsResolutionConfig
	(*v33.TypedExtensionConfig)(nil),                                            // 47: envoy.config.core.v3.TypedExtensionConfig
	(*wrapperspb.BoolValue)(nil),                                                // 48: google.protobuf.BoolValue
	(*OutlierDetection)(nil),                                                    // 49: envoy.config.cluster.v3.OutlierDetection
	(*v33.BindConfig)(nil),                                                      // 50: envoy.config.core.v3.BindConfig
	(*v33.TransportSocket)(nil),                                                 // 51: envoy.config.core.v3.TransportSocket
	(*v33.Metadata)(nil),                                                        // 52: envoy.config.core.v3.Metadata
	(*Filter)(nil),                                                              // 53: envoy.config.cluster.v3.Filter
	(*v33.ConfigSource)(nil),                                                    // 54: envoy.config.core.v3.ConfigSource
	(*v33.TcpKeepalive)(nil),                                                    // 55: envoy.config.core.v3.TcpKeepalive
	(*structpb.Struct)(nil),                                                     // 56: google.protobuf.Struct
	(*anypb.Any)(nil),                                                           // 57: google.protobuf.Any
	(*v33.RuntimeDouble)(nil),                                                   // 58: envoy.config.core.v3.RuntimeDouble
	(*v34.Percent)(nil),                                                         // 59: envoy.type.v3.Percent
	(*wrapperspb.UInt64Value)(nil),                                              // 60: google.protobuf.UInt64Value
	(*v35.MetadataKey)(nil),                                                     // 61: envoy.type.metadata.v3.MetadataKey
	(*v33.HealthStatusSet)(nil),                                                 // 62: envoy.config.core.v3.HealthStatusSet
	(*wrapperspb.DoubleValue)(nil),                                              // 63: google.protobuf.DoubleValue
}
var file_envoy_config_cluster_v3_cluster_proto_depIdxs = []int32{
	34, // 0: envoy.config.cluster.v3.ClusterCollection.entries:type_name -> xds.core.v3.CollectionEntry
	14, // 1: envoy.config.cluster.v3.Cluster.transport_socket_matches:type_name -> envoy.config.cluster.v3.Cluster.TransportSocketMatch
	35, // 2: envoy.config.cluster.v3.Cluster.transport_socket_matcher:type_name -> xds.type.matcher.v3.Matcher
	0,  // 3: envoy.config.cluster.v3.Cluster.type:type_name -> envoy.config.cluster.v3.Cluster.DiscoveryType
	15, // 4: envoy.config.cluster.v3.Cluster.cluster_type:type_name -> envoy.config.cluster.v3.Cluster.CustomClusterType
	16, // 5: envoy.config.cluster.v3.Cluster.eds_cluster_config:type_name -> envoy.config.cluster.v3.Cluster.EdsClusterConfig
	36, // 6: envoy.config.cluster.v3.Cluster.connect_timeout:type_name -> google.protobuf.Duration
	37, // 7: envoy.config.cluster.v3.Cluster.per_connection_buffer_limit_bytes:type_name -> google.protobuf.UInt32Value
	1,  // 8: envoy.config.cluster.v3.Cluster.lb_policy:type_name -> envoy.config.cluster.v3.Cluster.LbPolicy
	38, // 9: envoy.config.cluster.v3.Cluster.load_assignment:type_name -> envoy.config.endpoint.v3.ClusterLoadAssignment
	39, // 10: envoy.config.cluster.v3.Cluster.health_checks:type_name -> envoy.config.core.v3.HealthCheck
	37, // 11: envoy.config.cluster.v3.Cluster.max_requests_per_connection:type_name -> google.protobuf.UInt32Value
	40, // 12: envoy.config.cluster.v3.Cluster.circuit_breakers:type_name -> envoy.config.cluster.v3.CircuitBreakers
	41, // 13: envoy.config.cluster.v3.Cluster.upstream_http_protocol_options:type_name -> envoy.config.core.v3.UpstreamHttpProtocolOptions
	42, // 14: envoy.config.cluster.v3.Cluster.common_http_protocol_options:type_name -> envoy.config.core.v3.HttpProtocolOptions
	43, // 15: envoy.config.cluster.v3.Cluster.http_protocol_options:type_name -> envoy.config.core.v3.Http1ProtocolOptions
	44, // 16: envoy.config.cluster.v3.Cluster.http2_protocol_options:type_name -> envoy.config.core.v3.Http2ProtocolOptions
	27, // 17: envoy.config.cluster.v3.Cluster.typed_extension_protocol_options:type_name -> envoy.config.cluster.v3.Cluster.TypedExtensionProtocolOptionsEntry
	36, // 18: envoy.config.cluster.v3.Cluster.dns_refresh_rate:type_name -> google.protobuf.Duration
	36, // 19: envoy.config.cluster.v3.Cluster.dns_jitter:type_name -> google.protobuf.Duration
	25, // 20: envoy.config.cluster.v3.Cluster.dns_failure_refresh_rate:type_name -> envoy.config.cluster.v3.Cluster.RefreshRate
	2,  // 21: envoy.config.cluster.v3.Cluster.dns_lookup_family:type_name -> envoy.config.cluster.v3.Cluster.DnsLookupFamily
	45, // 22: envoy.config.cluster.v3.Cluster.dns_resolvers:type_name -> envoy.config.core.v3.Address
	46, // 23: envoy.config.cluster.v3.Cluster.dns_resolution_config:type_name -> envoy.config.core.v3.DnsResolutionConfig
	47, // 24: envoy.config.cluster.v3.Cluster.typed_dns_resolver_config:type_name -> envoy.config.core.v3.TypedExtensionConfig
	48, // 25: envoy.config.cluster.v3.Cluster.wait_for_warm_on_init:type_name -> google.protobuf.BoolValue
	49, // 26: envoy.config.cluster.v3.Cluster.outlier_detection:type_name -> envoy.config.cluster.v3.OutlierDetection
	36, // 27: envoy.config.cluster.v3.Cluster.cleanup_interval:type_name -> google.protobuf.Duration
	50, // 28: envoy.config.cluster.v3.Cluster.upstream_bind_config:type_name -> envoy.config.core.v3.BindConfig
	17, // 29: envoy.config.cluster.v3.Cluster.lb_subset_config:type_name -> envoy.config.cluster.v3.Cluster.LbSubsetConfig
	21, // 30: envoy.config.cluster.v3.Cluster.ring_hash_lb_config:type_name -> envoy.config.cluster.v3.Cluster.RingHashLbConfig
	22, // 31: envoy.config.cluster.v3.Cluster.maglev_lb_config:type_name -> envoy.config.cluster.v3.Cluster.MaglevLbConfig
	23, // 32: envoy.config.cluster.v3.Cluster.original_dst_lb_config:type_name -> envoy.config.cluster.v3.Cluster.OriginalDstLbConfig
	20, // 33: envoy.config.cluster.v3.Cluster.least_request_lb_config:type_name -> envoy.config.cluster.v3.Cluster.LeastRequestLbConfig
	19, // 34: envoy.config.cluster.v3.Cluster.round_robin_lb_config:type_name -> envoy.config.cluster.v3.Cluster.RoundRobinLbConfig
	24, // 35: envoy.config.cluster.v3.Cluster.common_lb_config:type_name -> envoy.config.cluster.v3.Cluster.CommonLbConfig
	51, // 36: envoy.config.cluster.v3.Cluster.transport_socket:type_name -> envoy.config.core.v3.TransportSocket
	52, // 37: envoy.config.cluster.v3.Cluster.metadata:type_name -> envoy.config.core.v3.Metadata
	3,  // 38: envoy.config.cluster.v3.Cluster.protocol_selection:type_name -> envoy.config.cluster.v3.Cluster.ClusterProtocolSelection
	12, // 39: envoy.config.cluster.v3.Cluster.upstream_connection_options:type_name -> envoy.config.cluster.v3.UpstreamConnectionOptions
	53, // 40: envoy.config.cluster.v3.Cluster.filters:type_name -> envoy.config.cluster.v3.Filter
	11, // 41: envoy.config.cluster.v3.Cluster.load_balancing_policy:type_name -> envoy.config.cluster.v3.LoadBalancingPolicy
	54, // 42: envoy.config.cluster.v3.Cluster.lrs_server:type_name -> envoy.config.core.v3.ConfigSource
	47, // 43: envoy.config.cluster.v3.Cluster.upstream_config:type_name -> envoy.config.core.v3.TypedExtensionConfig
	13, // 44: envoy.config.cluster.v3.Cluster.track_cluster_stats:type_name -> envoy.config.cluster.v3.TrackClusterStats
	26, // 45: envoy.config.cluster.v3.Cluster.preconnect_policy:type_name -> envoy.config.cluster.v3.Cluster.PreconnectPolicy
	32, // 46: envoy.config.cluster.v3.LoadBalancingPolicy.policies:type_name -> envoy.config.cluster.v3.LoadBalancingPolicy.Policy
	55, // 47: envoy.config.cluster.v3.UpstreamConnectionOptions.tcp_keepalive:type_name -> envoy.config.core.v3.TcpKeepalive
	33, // 48: envoy.config.cluster.v3.UpstreamConnectionOptions.happy_eyeballs_config:type_name -> envoy.config.cluster.v3.UpstreamConnectionOptions.HappyEyeballsConfig
	56, // 49: envoy.config.cluster.v3.Cluster.TransportSocketMatch.match:type_name -> google.protobuf.Struct
	51, // 50: envoy.config.cluster.v3.Cluster.TransportSocketMatch.transport_socket:type_name -> envoy.config.core.v3.TransportSocket
	57, // 51: envoy.config.cluster.v3.Cluster.CustomClusterType.typed_config:type_name -> google.protobuf.Any
	54, // 52: envoy.config.cluster.v3.Cluster.EdsClusterConfig.eds_config:type_name -> envoy.config.core.v3.ConfigSource
	4,  // 53: envoy.config.cluster.v3.Cluster.LbSubsetConfig.fallback_policy:type_name -> envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy
	56, // 54: envoy.config.cluster.v3.Cluster.LbSubsetConfig.default_subset:type_name -> google.protobuf.Struct
	28, // 55: envoy.config.cluster.v3.Cluster.LbSubsetConfig.subset_selectors:type_name -> envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector
	5,  // 56: envoy.config.cluster.v3.Cluster.LbSubsetConfig.metadata_fallback_policy:type_name -> envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetMetadataFallbackPolicy
	36, // 57: envoy.config.cluster.v3.Cluster.SlowStartConfig.slow_start_window:type_name -> google.protobuf.Duration
	58, // 58: envoy.config.cluster.v3.Cluster.SlowStartConfig.aggression:type_name -> envoy.config.core.v3.RuntimeDouble
	59, // 59: envoy.config.cluster.v3.Cluster.SlowStartConfig.min_weight_percent:type_name -> envoy.type.v3.Percent
	18, // 60: envoy.config.cluster.v3.Cluster.RoundRobinLbConfig.slow_start_config:type_name -> envoy.config.cluster.v3.Cluster.SlowStartConfig
	37, // 61: envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.choice_count:type_name -> google.protobuf.UInt32Value
	58, // 62: envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.active_request_bias:type_name -> envoy.config.core.v3.RuntimeDouble
	18, // 63: envoy.config.cluster.v3.Cluster.LeastRequestLbConfig.slow_start_config:type_name -> envoy.config.cluster.v3.Cluster.SlowStartConfig
	60, // 64: envoy.config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size:type_name -> google.protobuf.UInt64Value
	7,  // 65: envoy.config.cluster.v3.Cluster.RingHashLbConfig.hash_function:type_name -> envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction
	60, // 66: envoy.config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size:type_name -> google.protobuf.UInt64Value
	60, // 67: envoy.config.cluster.v3.Cluster.MaglevLbConfig.table_size:type_name -> google.protobuf.UInt64Value
	37, // 68: envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.upstream_port_override:type_name -> google.protobuf.UInt32Value
	61, // 69: envoy.config.cluster.v3.Cluster.OriginalDstLbConfig.metadata_key:type_name -> envoy.type.metadata.v3.MetadataKey
	59, // 70: envoy.config.cluster.v3.Cluster.CommonLbConfig.healthy_panic_threshold:type_name -> envoy.type.v3.Percent
	29, // 71: envoy.config.cluster.v3.Cluster.CommonLbConfig.zone_aware_lb_config:type_name -> envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig
	30, // 72: envoy.config.cluster.v3.Cluster.CommonLbConfig.locality_weighted_lb_config:type_name -> envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig
	36, // 73: envoy.config.cluster.v3.Cluster.CommonLbConfig.update_merge_window:type_name -> google.protobuf.Duration
	31, // 74: envoy.config.cluster.v3.Cluster.CommonLbConfig.consistent_hashing_lb_config:type_name -> envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig
	62, // 75: envoy.config.cluster.v3.Cluster.CommonLbConfig.override_host_status:type_name -> envoy.config.core.v3.HealthStatusSet
	36, // 76: envoy.config.cluster.v3.Cluster.RefreshRate.base_interval:type_name -> google.protobuf.Duration
	36, // 77: envoy.config.cluster.v3.Cluster.RefreshRate.max_interval:type_name -> google.protobuf.Duration
	63, // 78: envoy.config.cluster.v3.Cluster.PreconnectPolicy.per_upstream_preconnect_ratio:type_name -> google.protobuf.DoubleValue
	63, // 79: envoy.config.cluster.v3.Cluster.PreconnectPolicy.predictive_preconnect_ratio:type_name -> google.protobuf.DoubleValue
	57, // 80: envoy.config.cluster.v3.Cluster.TypedExtensionProtocolOptionsEntry.value:type_name -> google.protobuf.Any
	6,  // 81: envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.fallback_policy:type_name -> envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy
	59, // 82: envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.routing_enabled:type_name -> envoy.type.v3.Percent
	60, // 83: envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig.min_cluster_size:type_name -> google.protobuf.UInt64Value
	37, // 84: envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig.hash_balance_factor:type_name -> google.protobuf.UInt32Value
	47, // 85: envoy.config.cluster.v3.LoadBalancingPolicy.Policy.typed_extension_config:type_name -> envoy.config.core.v3.TypedExtensionConfig
	8,  // 86: envoy.config.cluster.v3.UpstreamConnectionOptions.HappyEyeballsConfig.first_address_family_version:type_name -> envoy.config.cluster.v3.UpstreamConnectionOptions.FirstAddressFamilyVersion
	37, // 87: envoy.config.cluster.v3.UpstreamConnectionOptions.HappyEyeballsConfig.first_address_family_count:type_name -> google.protobuf.UInt32Value
	88, // [88:88] is the sub-list for method output_type
	88, // [88:88] is the sub-list for method input_type
	88, // [88:88] is the sub-list for extension type_name
	88, // [88:88] is the sub-list for extension extendee
	0,  // [0:88] is the sub-list for field type_name
}

func init() { file_envoy_config_cluster_v3_cluster_proto_init() }
func file_envoy_config_cluster_v3_cluster_proto_init() {
	if File_envoy_config_cluster_v3_cluster_proto != nil {
		return
	}
	file_envoy_config_cluster_v3_circuit_breaker_proto_init()
	file_envoy_config_cluster_v3_filter_proto_init()
	file_envoy_config_cluster_v3_outlier_detection_proto_init()
	file_envoy_config_cluster_v3_cluster_proto_msgTypes[1].OneofWrappers = []any{
		(*Cluster_Type)(nil),
		(*Cluster_ClusterType)(nil),
		(*Cluster_RingHashLbConfig_)(nil),
		(*Cluster_MaglevLbConfig_)(nil),
		(*Cluster_OriginalDstLbConfig_)(nil),
		(*Cluster_LeastRequestLbConfig_)(nil),
		(*Cluster_RoundRobinLbConfig_)(nil),
	}
	file_envoy_config_cluster_v3_cluster_proto_msgTypes[15].OneofWrappers = []any{
		(*Cluster_CommonLbConfig_ZoneAwareLbConfig_)(nil),
		(*Cluster_CommonLbConfig_LocalityWeightedLbConfig_)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_envoy_config_cluster_v3_cluster_proto_rawDesc), len(file_envoy_config_cluster_v3_cluster_proto_rawDesc)),
			NumEnums:      9,
			NumMessages:   25,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_envoy_config_cluster_v3_cluster_proto_goTypes,
		DependencyIndexes: file_envoy_config_cluster_v3_cluster_proto_depIdxs,
		EnumInfos:         file_envoy_config_cluster_v3_cluster_proto_enumTypes,
		MessageInfos:      file_envoy_config_cluster_v3_cluster_proto_msgTypes,
	}.Build()
	File_envoy_config_cluster_v3_cluster_proto = out.File
	file_envoy_config_cluster_v3_cluster_proto_goTypes = nil
	file_envoy_config_cluster_v3_cluster_proto_depIdxs = nil
}
