// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v6.33.2
// source: envoy/extensions/network/dns_resolver/cares/v3/cares_dns_resolver.proto

package caresv3

import (
	_ "github.com/cncf/xds/go/udpa/annotations"
	v3 "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Configuration for c-ares DNS resolver.
// [#next-free-field: 12]
type CaresDnsResolverConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A list of DNS resolver addresses.
	// :ref:`use_resolvers_as_fallback <envoy_v3_api_field_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig.use_resolvers_as_fallback>`
	// below dictates if the DNS client should override system defaults or only use the provided
	// resolvers if the system defaults are not available, i.e., as a fallback.
	Resolvers []*v3.Address `protobuf:"bytes,1,rep,name=resolvers,proto3" json:"resolvers,omitempty"`
	// If true use the resolvers listed in the
	// :ref:`resolvers <envoy_v3_api_field_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig.resolvers>`
	// field only if c-ares is unable to obtain a
	// nameserver from the system (e.g., “/etc/resolv.conf“).
	// Otherwise, the resolvers listed in the resolvers list will override the default system
	// resolvers. Defaults to false.
	UseResolversAsFallback bool `protobuf:"varint,3,opt,name=use_resolvers_as_fallback,json=useResolversAsFallback,proto3" json:"use_resolvers_as_fallback,omitempty"`
	// The resolver will query available network interfaces and determine if there are no available
	// interfaces for a given IP family. It will then filter these addresses from the results it
	// presents. e.g., if there are no available IPv4 network interfaces, the resolver will not
	// provide IPv4 addresses.
	FilterUnroutableFamilies bool `protobuf:"varint,4,opt,name=filter_unroutable_families,json=filterUnroutableFamilies,proto3" json:"filter_unroutable_families,omitempty"`
	// Configuration of DNS resolver option flags which control the behavior of the DNS resolver.
	DnsResolverOptions *v3.DnsResolverOptions `protobuf:"bytes,2,opt,name=dns_resolver_options,json=dnsResolverOptions,proto3" json:"dns_resolver_options,omitempty"`
	// This option allows the number of UDP based DNS queries to be capped.
	//
	// .. note::
	//
	//	This is only applicable to c-ares DNS resolver currently.
	UdpMaxQueries *wrapperspb.UInt32Value `protobuf:"bytes,5,opt,name=udp_max_queries,json=udpMaxQueries,proto3" json:"udp_max_queries,omitempty"`
	// The number of seconds each name server is given to respond to a query on the first try of any given server.
	//
	// .. note::
	//
	//	While the c-ares library defaults to 2 seconds, Envoy's default (if this field is unset) is 5 seconds.
	//	This adjustment was made to maintain the previous behavior after users reported an increase in DNS resolution times.
	QueryTimeoutSeconds *wrapperspb.UInt64Value `protobuf:"bytes,6,opt,name=query_timeout_seconds,json=queryTimeoutSeconds,proto3" json:"query_timeout_seconds,omitempty"`
	// The maximum number of query attempts the resolver will make before giving up.
	// Each attempt may use a different name server.
	//
	// .. note::
	//
	//	While the c-ares library defaults to 3 attempts, Envoy's default (if this field is unset) is 4 attempts.
	//	This adjustment was made to maintain the previous behavior after users reported an increase in DNS resolution times.
	QueryTries *wrapperspb.UInt32Value `protobuf:"bytes,7,opt,name=query_tries,json=queryTries,proto3" json:"query_tries,omitempty"`
	// Enable round-robin selection of name servers for DNS resolution. When enabled, the resolver will cycle through the
	// list of name servers for each resolution request. This can help distribute the query load across multiple name
	// servers. If disabled (default), the resolver will try name servers in the order they are configured.
	//
	// .. note::
	//
	//	This setting overrides any system configuration for name server rotation.
	RotateNameservers bool `protobuf:"varint,8,opt,name=rotate_nameservers,json=rotateNameservers,proto3" json:"rotate_nameservers,omitempty"`
	// Maximum EDNS0 UDP payload size in bytes.
	// If set, c-ares will include EDNS0 in DNS queries and use this value as the maximum UDP response size.
	//
	// Recommended values:
	//
	// * **1232**: Safe default (avoids fragmentation).
	// * **4096**: Maximum allowed.
	//
	// If unset, c-ares uses its internal default (usually 1232).
	Edns0MaxPayloadSize *wrapperspb.UInt32Value `protobuf:"bytes,9,opt,name=edns0_max_payload_size,json=edns0MaxPayloadSize,proto3" json:"edns0_max_payload_size,omitempty"`
	// The maximum duration for which a UDP channel will be kept alive before being refreshed.
	//
	// If set, the DNS resolver will periodically reinitialize its c-ares channel after the
	// specified duration. This can help with avoiding stale socket states, and providing
	// better load distribution across UDP ports.
	//
	// If not specified, no periodic refresh will be performed.
	MaxUdpChannelDuration *durationpb.Duration `protobuf:"bytes,10,opt,name=max_udp_channel_duration,json=maxUdpChannelDuration,proto3" json:"max_udp_channel_duration,omitempty"`
	// If true, reinitialize the c-ares channel when a DNS query fails with “ARES_ETIMEOUT“.
	//
	// This can help recover from rare cases where the UDP sockets held by the c-ares
	// channel become unusable after timeouts, causing subsequent queries to fail or
	// Envoy to keep serving stale DNS results. When enabled, a timeout-triggered
	// reinitialization attempts to restore healthy state quickly. In environments
	// where timeouts are caused by intermittent network issues, enabling this may
	// increase channel churn; consider using
	// :ref:`max_udp_channel_duration <envoy_v3_api_field_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig.max_udp_channel_duration>`
	// for periodic refresh instead.
	//
	// Default is false.
	ReinitChannelOnTimeout bool `protobuf:"varint,11,opt,name=reinit_channel_on_timeout,json=reinitChannelOnTimeout,proto3" json:"reinit_channel_on_timeout,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *CaresDnsResolverConfig) Reset() {
	*x = CaresDnsResolverConfig{}
	mi := &file_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CaresDnsResolverConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CaresDnsResolverConfig) ProtoMessage() {}

func (x *CaresDnsResolverConfig) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CaresDnsResolverConfig.ProtoReflect.Descriptor instead.
func (*CaresDnsResolverConfig) Descriptor() ([]byte, []int) {
	return file_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto_rawDescGZIP(), []int{0}
}

func (x *CaresDnsResolverConfig) GetResolvers() []*v3.Address {
	if x != nil {
		return x.Resolvers
	}
	return nil
}

func (x *CaresDnsResolverConfig) GetUseResolversAsFallback() bool {
	if x != nil {
		return x.UseResolversAsFallback
	}
	return false
}

func (x *CaresDnsResolverConfig) GetFilterUnroutableFamilies() bool {
	if x != nil {
		return x.FilterUnroutableFamilies
	}
	return false
}

func (x *CaresDnsResolverConfig) GetDnsResolverOptions() *v3.DnsResolverOptions {
	if x != nil {
		return x.DnsResolverOptions
	}
	return nil
}

func (x *CaresDnsResolverConfig) GetUdpMaxQueries() *wrapperspb.UInt32Value {
	if x != nil {
		return x.UdpMaxQueries
	}
	return nil
}

func (x *CaresDnsResolverConfig) GetQueryTimeoutSeconds() *wrapperspb.UInt64Value {
	if x != nil {
		return x.QueryTimeoutSeconds
	}
	return nil
}

func (x *CaresDnsResolverConfig) GetQueryTries() *wrapperspb.UInt32Value {
	if x != nil {
		return x.QueryTries
	}
	return nil
}

func (x *CaresDnsResolverConfig) GetRotateNameservers() bool {
	if x != nil {
		return x.RotateNameservers
	}
	return false
}

func (x *CaresDnsResolverConfig) GetEdns0MaxPayloadSize() *wrapperspb.UInt32Value {
	if x != nil {
		return x.Edns0MaxPayloadSize
	}
	return nil
}

func (x *CaresDnsResolverConfig) GetMaxUdpChannelDuration() *durationpb.Duration {
	if x != nil {
		return x.MaxUdpChannelDuration
	}
	return nil
}

func (x *CaresDnsResolverConfig) GetReinitChannelOnTimeout() bool {
	if x != nil {
		return x.ReinitChannelOnTimeout
	}
	return false
}

var File_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto protoreflect.FileDescriptor

const file_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto_rawDesc = "" +
	"\n" +
	"Genvoy/extensions/network/dns_resolver/cares/v3/cares_dns_resolver.proto\x12.envoy.extensions.network.dns_resolver.cares.v3\x1a\"envoy/config/core/v3/address.proto\x1a#envoy/config/core/v3/resolver.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1egoogle/protobuf/wrappers.proto\x1a\x1dudpa/annotations/status.proto\x1a\x17validate/validate.proto\"\xbb\x06\n" +
	"\x16CaresDnsResolverConfig\x12;\n" +
	"\tresolvers\x18\x01 \x03(\v2\x1d.envoy.config.core.v3.AddressR\tresolvers\x129\n" +
	"\x19use_resolvers_as_fallback\x18\x03 \x01(\bR\x16useResolversAsFallback\x12<\n" +
	"\x1afilter_unroutable_families\x18\x04 \x01(\bR\x18filterUnroutableFamilies\x12Z\n" +
	"\x14dns_resolver_options\x18\x02 \x01(\v2(.envoy.config.core.v3.DnsResolverOptionsR\x12dnsResolverOptions\x12D\n" +
	"\x0fudp_max_queries\x18\x05 \x01(\v2\x1c.google.protobuf.UInt32ValueR\rudpMaxQueries\x12Y\n" +
	"\x15query_timeout_seconds\x18\x06 \x01(\v2\x1c.google.protobuf.UInt64ValueB\a\xfaB\x042\x02(\x01R\x13queryTimeoutSeconds\x12F\n" +
	"\vquery_tries\x18\a \x01(\v2\x1c.google.protobuf.UInt32ValueB\a\xfaB\x04*\x02(\x01R\n" +
	"queryTries\x12-\n" +
	"\x12rotate_nameservers\x18\b \x01(\bR\x11rotateNameservers\x12^\n" +
	"\x16edns0_max_payload_size\x18\t \x01(\v2\x1c.google.protobuf.UInt32ValueB\v\xfaB\b*\x06\x18\x80 (\x80\x04R\x13edns0MaxPayloadSize\x12\\\n" +
	"\x18max_udp_channel_duration\x18\n" +
	" \x01(\v2\x19.google.protobuf.DurationB\b\xfaB\x05\xaa\x01\x022\x00R\x15maxUdpChannelDuration\x129\n" +
	"\x19reinit_channel_on_timeout\x18\v \x01(\bR\x16reinitChannelOnTimeoutB\xbe\x01\xba\x80\xc8\xd1\x06\x02\x10\x02\n" +
	"<io.envoyproxy.envoy.extensions.network.dns_resolver.cares.v3B\x15CaresDnsResolverProtoP\x01Z]github.com/envoyproxy/go-control-plane/envoy/extensions/network/dns_resolver/cares/v3;caresv3b\x06proto3"

var (
	file_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto_rawDescOnce sync.Once
	file_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto_rawDescData []byte
)

func file_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto_rawDescGZIP() []byte {
	file_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto_rawDescOnce.Do(func() {
		file_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto_rawDesc), len(file_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto_rawDesc)))
	})
	return file_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto_rawDescData
}

var file_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto_goTypes = []any{
	(*CaresDnsResolverConfig)(nil), // 0: envoy.extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig
	(*v3.Address)(nil),             // 1: envoy.config.core.v3.Address
	(*v3.DnsResolverOptions)(nil),  // 2: envoy.config.core.v3.DnsResolverOptions
	(*wrapperspb.UInt32Value)(nil), // 3: google.protobuf.UInt32Value
	(*wrapperspb.UInt64Value)(nil), // 4: google.protobuf.UInt64Value
	(*durationpb.Duration)(nil),    // 5: google.protobuf.Duration
}
var file_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto_depIdxs = []int32{
	1, // 0: envoy.extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig.resolvers:type_name -> envoy.config.core.v3.Address
	2, // 1: envoy.extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig.dns_resolver_options:type_name -> envoy.config.core.v3.DnsResolverOptions
	3, // 2: envoy.extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig.udp_max_queries:type_name -> google.protobuf.UInt32Value
	4, // 3: envoy.extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig.query_timeout_seconds:type_name -> google.protobuf.UInt64Value
	3, // 4: envoy.extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig.query_tries:type_name -> google.protobuf.UInt32Value
	3, // 5: envoy.extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig.edns0_max_payload_size:type_name -> google.protobuf.UInt32Value
	5, // 6: envoy.extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig.max_udp_channel_duration:type_name -> google.protobuf.Duration
	7, // [7:7] is the sub-list for method output_type
	7, // [7:7] is the sub-list for method input_type
	7, // [7:7] is the sub-list for extension type_name
	7, // [7:7] is the sub-list for extension extendee
	0, // [0:7] is the sub-list for field type_name
}

func init() { file_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto_init() }
func file_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto_init() {
	if File_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto_rawDesc), len(file_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   1,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto_goTypes,
		DependencyIndexes: file_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto_depIdxs,
		MessageInfos:      file_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto_msgTypes,
	}.Build()
	File_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto = out.File
	file_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto_goTypes = nil
	file_envoy_extensions_network_dns_resolver_cares_v3_cares_dns_resolver_proto_depIdxs = nil
}
