// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v6.33.2
// source: envoy/extensions/filters/http/dynamic_forward_proxy/v3/dynamic_forward_proxy.proto

package dynamic_forward_proxyv3

import (
	_ "github.com/cncf/xds/go/udpa/annotations"
	v3 "github.com/envoyproxy/go-control-plane/envoy/extensions/common/dynamic_forward_proxy/v3"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Configuration for the dynamic forward proxy HTTP filter. See the :ref:`architecture overview
// <arch_overview_http_dynamic_forward_proxy>` for more information.
// [#extension: envoy.filters.http.dynamic_forward_proxy]
type FilterConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to ImplementationSpecifier:
	//
	//	*FilterConfig_DnsCacheConfig
	//	*FilterConfig_SubClusterConfig
	ImplementationSpecifier isFilterConfig_ImplementationSpecifier `protobuf_oneof:"implementation_specifier"`
	// When this flag is set, the filter will add the resolved upstream address in the filter
	// state. The state should be saved with key
	// “envoy.stream.upstream_address“ (See
	// :repo:`upstream_address.h<source/common/stream_info/upstream_address.h>`).
	SaveUpstreamAddress bool `protobuf:"varint,2,opt,name=save_upstream_address,json=saveUpstreamAddress,proto3" json:"save_upstream_address,omitempty"`
	// When this flag is set, the filter will check for the “envoy.upstream.dynamic_host“
	// and/or “envoy.upstream.dynamic_port“ filter state values before using the HTTP
	// Host header for DNS resolution. This provides consistency with the
	// :ref:`SNI dynamic forward proxy <envoy_v3_api_msg_extensions.filters.network.sni_dynamic_forward_proxy.v3.FilterConfig>` and
	// :ref:`UDP dynamic forward proxy <envoy_v3_api_msg_extensions.filters.udp.udp_proxy.session.dynamic_forward_proxy.v3.FilterConfig>`
	// filters behavior when enabled.
	//
	// If the flag is not set (default), the filter will use the HTTP Host header
	// for DNS resolution, maintaining backward compatibility.
	AllowDynamicHostFromFilterState bool `protobuf:"varint,4,opt,name=allow_dynamic_host_from_filter_state,json=allowDynamicHostFromFilterState,proto3" json:"allow_dynamic_host_from_filter_state,omitempty"`
	unknownFields                   protoimpl.UnknownFields
	sizeCache                       protoimpl.SizeCache
}

func (x *FilterConfig) Reset() {
	*x = FilterConfig{}
	mi := &file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FilterConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FilterConfig) ProtoMessage() {}

func (x *FilterConfig) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FilterConfig.ProtoReflect.Descriptor instead.
func (*FilterConfig) Descriptor() ([]byte, []int) {
	return file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_rawDescGZIP(), []int{0}
}

func (x *FilterConfig) GetImplementationSpecifier() isFilterConfig_ImplementationSpecifier {
	if x != nil {
		return x.ImplementationSpecifier
	}
	return nil
}

func (x *FilterConfig) GetDnsCacheConfig() *v3.DnsCacheConfig {
	if x != nil {
		if x, ok := x.ImplementationSpecifier.(*FilterConfig_DnsCacheConfig); ok {
			return x.DnsCacheConfig
		}
	}
	return nil
}

func (x *FilterConfig) GetSubClusterConfig() *SubClusterConfig {
	if x != nil {
		if x, ok := x.ImplementationSpecifier.(*FilterConfig_SubClusterConfig); ok {
			return x.SubClusterConfig
		}
	}
	return nil
}

func (x *FilterConfig) GetSaveUpstreamAddress() bool {
	if x != nil {
		return x.SaveUpstreamAddress
	}
	return false
}

func (x *FilterConfig) GetAllowDynamicHostFromFilterState() bool {
	if x != nil {
		return x.AllowDynamicHostFromFilterState
	}
	return false
}

type isFilterConfig_ImplementationSpecifier interface {
	isFilterConfig_ImplementationSpecifier()
}

type FilterConfig_DnsCacheConfig struct {
	// The DNS cache configuration that the filter will attach to. Note this configuration must
	// match that of associated :ref:`dynamic forward proxy cluster configuration
	// <envoy_v3_api_field_extensions.clusters.dynamic_forward_proxy.v3.ClusterConfig.dns_cache_config>`.
	DnsCacheConfig *v3.DnsCacheConfig `protobuf:"bytes,1,opt,name=dns_cache_config,json=dnsCacheConfig,proto3,oneof"`
}

type FilterConfig_SubClusterConfig struct {
	// The configuration that the filter will use, when the related dynamic forward proxy cluster enabled
	// sub clusters.
	SubClusterConfig *SubClusterConfig `protobuf:"bytes,3,opt,name=sub_cluster_config,json=subClusterConfig,proto3,oneof"`
}

func (*FilterConfig_DnsCacheConfig) isFilterConfig_ImplementationSpecifier() {}

func (*FilterConfig_SubClusterConfig) isFilterConfig_ImplementationSpecifier() {}

// Per route Configuration for the dynamic forward proxy HTTP filter.
type PerRouteConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to HostRewriteSpecifier:
	//
	//	*PerRouteConfig_HostRewriteLiteral
	//	*PerRouteConfig_HostRewriteHeader
	HostRewriteSpecifier isPerRouteConfig_HostRewriteSpecifier `protobuf_oneof:"host_rewrite_specifier"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *PerRouteConfig) Reset() {
	*x = PerRouteConfig{}
	mi := &file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PerRouteConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PerRouteConfig) ProtoMessage() {}

func (x *PerRouteConfig) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PerRouteConfig.ProtoReflect.Descriptor instead.
func (*PerRouteConfig) Descriptor() ([]byte, []int) {
	return file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_rawDescGZIP(), []int{1}
}

func (x *PerRouteConfig) GetHostRewriteSpecifier() isPerRouteConfig_HostRewriteSpecifier {
	if x != nil {
		return x.HostRewriteSpecifier
	}
	return nil
}

func (x *PerRouteConfig) GetHostRewriteLiteral() string {
	if x != nil {
		if x, ok := x.HostRewriteSpecifier.(*PerRouteConfig_HostRewriteLiteral); ok {
			return x.HostRewriteLiteral
		}
	}
	return ""
}

func (x *PerRouteConfig) GetHostRewriteHeader() string {
	if x != nil {
		if x, ok := x.HostRewriteSpecifier.(*PerRouteConfig_HostRewriteHeader); ok {
			return x.HostRewriteHeader
		}
	}
	return ""
}

type isPerRouteConfig_HostRewriteSpecifier interface {
	isPerRouteConfig_HostRewriteSpecifier()
}

type PerRouteConfig_HostRewriteLiteral struct {
	// Indicates that before DNS lookup, the host header will be swapped with
	// this value. If not set or empty, the original host header value
	// will be used and no rewrite will happen.
	//
	// .. note::
	//
	//	This rewrite affects both DNS lookup and host header forwarding. However, this option shouldn't be used with
	//	:ref:`HCM host rewrite header <envoy_v3_api_field_config.route.v3.RouteAction.auto_host_rewrite>` given that
	//	the value set here would be used for DNS lookups whereas the value set in the HCM would be used for host
	//	header forwarding which might not be the desired outcome.
	HostRewriteLiteral string `protobuf:"bytes,1,opt,name=host_rewrite_literal,json=hostRewriteLiteral,proto3,oneof"`
}

type PerRouteConfig_HostRewriteHeader struct {
	// Indicates that before DNS lookup, the host header will be swapped with
	// the value of this header. If not set or empty, the original host header
	// value will be used and no rewrite will happen.
	//
	// .. note::
	//
	//	This rewrite affects both DNS lookup and host header forwarding. However, this option shouldn't be used with
	//	:ref:`HCM host rewrite header <envoy_v3_api_field_config.route.v3.RouteAction.auto_host_rewrite>` given that
	//	the value set here would be used for DNS lookups whereas the value set in the HCM would be used for host
	//	header forwarding which might not be the desired outcome.
	//
	// .. note::
	//
	//	If the header appears multiple times only the first value is used.
	HostRewriteHeader string `protobuf:"bytes,2,opt,name=host_rewrite_header,json=hostRewriteHeader,proto3,oneof"`
}

func (*PerRouteConfig_HostRewriteLiteral) isPerRouteConfig_HostRewriteSpecifier() {}

func (*PerRouteConfig_HostRewriteHeader) isPerRouteConfig_HostRewriteSpecifier() {}

type SubClusterConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The timeout used for sub cluster initialization. Defaults to **5s** if not set.
	ClusterInitTimeout *durationpb.Duration `protobuf:"bytes,3,opt,name=cluster_init_timeout,json=clusterInitTimeout,proto3" json:"cluster_init_timeout,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *SubClusterConfig) Reset() {
	*x = SubClusterConfig{}
	mi := &file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubClusterConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubClusterConfig) ProtoMessage() {}

func (x *SubClusterConfig) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubClusterConfig.ProtoReflect.Descriptor instead.
func (*SubClusterConfig) Descriptor() ([]byte, []int) {
	return file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_rawDescGZIP(), []int{2}
}

func (x *SubClusterConfig) GetClusterInitTimeout() *durationpb.Duration {
	if x != nil {
		return x.ClusterInitTimeout
	}
	return nil
}

var File_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto protoreflect.FileDescriptor

const file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_rawDesc = "" +
	"\n" +
	"Renvoy/extensions/filters/http/dynamic_forward_proxy/v3/dynamic_forward_proxy.proto\x126envoy.extensions.filters.http.dynamic_forward_proxy.v3\x1a@envoy/extensions/common/dynamic_forward_proxy/v3/dns_cache.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1dudpa/annotations/status.proto\x1a!udpa/annotations/versioning.proto\x1a\x17validate/validate.proto\"\xe1\x03\n" +
	"\fFilterConfig\x12l\n" +
	"\x10dns_cache_config\x18\x01 \x01(\v2@.envoy.extensions.common.dynamic_forward_proxy.v3.DnsCacheConfigH\x00R\x0ednsCacheConfig\x12x\n" +
	"\x12sub_cluster_config\x18\x03 \x01(\v2H.envoy.extensions.filters.http.dynamic_forward_proxy.v3.SubClusterConfigH\x00R\x10subClusterConfig\x122\n" +
	"\x15save_upstream_address\x18\x02 \x01(\bR\x13saveUpstreamAddress\x12M\n" +
	"$allow_dynamic_host_from_filter_state\x18\x04 \x01(\bR\x1fallowDynamicHostFromFilterState:J\x9aň\x1eE\n" +
	"Cenvoy.config.filter.http.dynamic_forward_proxy.v2alpha.FilterConfigB\x1a\n" +
	"\x18implementation_specifier\"\xde\x01\n" +
	"\x0ePerRouteConfig\x122\n" +
	"\x14host_rewrite_literal\x18\x01 \x01(\tH\x00R\x12hostRewriteLiteral\x120\n" +
	"\x13host_rewrite_header\x18\x02 \x01(\tH\x00R\x11hostRewriteHeader:L\x9aň\x1eG\n" +
	"Eenvoy.config.filter.http.dynamic_forward_proxy.v2alpha.PerRouteConfigB\x18\n" +
	"\x16host_rewrite_specifier\"i\n" +
	"\x10SubClusterConfig\x12U\n" +
	"\x14cluster_init_timeout\x18\x03 \x01(\v2\x19.google.protobuf.DurationB\b\xfaB\x05\xaa\x01\x02*\x00R\x12clusterInitTimeoutB\xe1\x01\xba\x80\xc8\xd1\x06\x02\x10\x02\n" +
	"Dio.envoyproxy.envoy.extensions.filters.http.dynamic_forward_proxy.v3B\x18DynamicForwardProxyProtoP\x01Zugithub.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/dynamic_forward_proxy/v3;dynamic_forward_proxyv3b\x06proto3"

var (
	file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_rawDescOnce sync.Once
	file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_rawDescData []byte
)

func file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_rawDescGZIP() []byte {
	file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_rawDescOnce.Do(func() {
		file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_rawDesc), len(file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_rawDesc)))
	})
	return file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_rawDescData
}

var file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_goTypes = []any{
	(*FilterConfig)(nil),        // 0: envoy.extensions.filters.http.dynamic_forward_proxy.v3.FilterConfig
	(*PerRouteConfig)(nil),      // 1: envoy.extensions.filters.http.dynamic_forward_proxy.v3.PerRouteConfig
	(*SubClusterConfig)(nil),    // 2: envoy.extensions.filters.http.dynamic_forward_proxy.v3.SubClusterConfig
	(*v3.DnsCacheConfig)(nil),   // 3: envoy.extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig
	(*durationpb.Duration)(nil), // 4: google.protobuf.Duration
}
var file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_depIdxs = []int32{
	3, // 0: envoy.extensions.filters.http.dynamic_forward_proxy.v3.FilterConfig.dns_cache_config:type_name -> envoy.extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig
	2, // 1: envoy.extensions.filters.http.dynamic_forward_proxy.v3.FilterConfig.sub_cluster_config:type_name -> envoy.extensions.filters.http.dynamic_forward_proxy.v3.SubClusterConfig
	4, // 2: envoy.extensions.filters.http.dynamic_forward_proxy.v3.SubClusterConfig.cluster_init_timeout:type_name -> google.protobuf.Duration
	3, // [3:3] is the sub-list for method output_type
	3, // [3:3] is the sub-list for method input_type
	3, // [3:3] is the sub-list for extension type_name
	3, // [3:3] is the sub-list for extension extendee
	0, // [0:3] is the sub-list for field type_name
}

func init() {
	file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_init()
}
func file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_init() {
	if File_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto != nil {
		return
	}
	file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_msgTypes[0].OneofWrappers = []any{
		(*FilterConfig_DnsCacheConfig)(nil),
		(*FilterConfig_SubClusterConfig)(nil),
	}
	file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_msgTypes[1].OneofWrappers = []any{
		(*PerRouteConfig_HostRewriteLiteral)(nil),
		(*PerRouteConfig_HostRewriteHeader)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_rawDesc), len(file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   3,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_goTypes,
		DependencyIndexes: file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_depIdxs,
		MessageInfos:      file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_msgTypes,
	}.Build()
	File_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto = out.File
	file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_goTypes = nil
	file_envoy_extensions_filters_http_dynamic_forward_proxy_v3_dynamic_forward_proxy_proto_depIdxs = nil
}
