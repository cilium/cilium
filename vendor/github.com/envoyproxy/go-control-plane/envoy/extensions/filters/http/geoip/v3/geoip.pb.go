// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v6.33.2
// source: envoy/extensions/filters/http/geoip/v3/geoip.proto

package geoipv3

import (
	_ "github.com/cncf/xds/go/udpa/annotations"
	_ "github.com/cncf/xds/go/xds/annotations/v3"
	v3 "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Geoip struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Configuration for extracting the client IP address from the
	// “x-forwarded-for“ header. If set, the
	// :ref:`xff_num_trusted_hops <envoy_v3_api_field_extensions.filters.http.geoip.v3.Geoip.XffConfig.xff_num_trusted_hops>`
	// field will be used to determine the trusted client address from the “x-forwarded-for“ header.
	// If not set, the immediate downstream connection source address will be used.
	//
	// Only one of “xff_config“ or
	// :ref:`custom_header_config <envoy_v3_api_field_extensions.filters.http.geoip.v3.Geoip.custom_header_config>`
	// can be set.
	XffConfig *Geoip_XffConfig `protobuf:"bytes,1,opt,name=xff_config,json=xffConfig,proto3" json:"xff_config,omitempty"`
	// Configuration for extracting the client IP address from a custom request header.
	//
	// If set, the
	// :ref:`header_name <envoy_v3_api_field_extensions.filters.http.geoip.v3.Geoip.CustomHeaderConfig.header_name>`
	// field will be used to extract the client IP address from the specified request header.
	//
	// Only one of “custom_header_config“ or
	// :ref:`xff_config <envoy_v3_api_field_extensions.filters.http.geoip.v3.Geoip.xff_config>`
	// can be set.
	CustomHeaderConfig *Geoip_CustomHeaderConfig `protobuf:"bytes,4,opt,name=custom_header_config,json=customHeaderConfig,proto3" json:"custom_header_config,omitempty"`
	// Geoip driver specific configuration which depends on the driver being instantiated.
	// See the geoip drivers for examples:
	//
	// - :ref:`MaxMindConfig <envoy_v3_api_msg_extensions.geoip_providers.maxmind.v3.MaxMindConfig>`
	// [#extension-category: envoy.geoip_providers]
	Provider      *v3.TypedExtensionConfig `protobuf:"bytes,3,opt,name=provider,proto3" json:"provider,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Geoip) Reset() {
	*x = Geoip{}
	mi := &file_envoy_extensions_filters_http_geoip_v3_geoip_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Geoip) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Geoip) ProtoMessage() {}

func (x *Geoip) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_extensions_filters_http_geoip_v3_geoip_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Geoip.ProtoReflect.Descriptor instead.
func (*Geoip) Descriptor() ([]byte, []int) {
	return file_envoy_extensions_filters_http_geoip_v3_geoip_proto_rawDescGZIP(), []int{0}
}

func (x *Geoip) GetXffConfig() *Geoip_XffConfig {
	if x != nil {
		return x.XffConfig
	}
	return nil
}

func (x *Geoip) GetCustomHeaderConfig() *Geoip_CustomHeaderConfig {
	if x != nil {
		return x.CustomHeaderConfig
	}
	return nil
}

func (x *Geoip) GetProvider() *v3.TypedExtensionConfig {
	if x != nil {
		return x.Provider
	}
	return nil
}

type Geoip_XffConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The number of additional ingress proxy hops from the right side of the
	// :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header to trust when
	// determining the origin client's IP address. See the documentation for
	// :ref:`config_http_conn_man_headers_x-forwarded-for` for more information.
	//
	// Defaults to “0“.
	XffNumTrustedHops uint32 `protobuf:"varint,1,opt,name=xff_num_trusted_hops,json=xffNumTrustedHops,proto3" json:"xff_num_trusted_hops,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *Geoip_XffConfig) Reset() {
	*x = Geoip_XffConfig{}
	mi := &file_envoy_extensions_filters_http_geoip_v3_geoip_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Geoip_XffConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Geoip_XffConfig) ProtoMessage() {}

func (x *Geoip_XffConfig) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_extensions_filters_http_geoip_v3_geoip_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Geoip_XffConfig.ProtoReflect.Descriptor instead.
func (*Geoip_XffConfig) Descriptor() ([]byte, []int) {
	return file_envoy_extensions_filters_http_geoip_v3_geoip_proto_rawDescGZIP(), []int{0, 0}
}

func (x *Geoip_XffConfig) GetXffNumTrustedHops() uint32 {
	if x != nil {
		return x.XffNumTrustedHops
	}
	return 0
}

type Geoip_CustomHeaderConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the request header to extract the client IP address from.
	// The header value must contain a valid IP address (IPv4 or IPv6).
	//
	// If the header is missing or contains an invalid IP address, the filter will fall back
	// to using the immediate downstream connection source address.
	HeaderName    string `protobuf:"bytes,1,opt,name=header_name,json=headerName,proto3" json:"header_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Geoip_CustomHeaderConfig) Reset() {
	*x = Geoip_CustomHeaderConfig{}
	mi := &file_envoy_extensions_filters_http_geoip_v3_geoip_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Geoip_CustomHeaderConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Geoip_CustomHeaderConfig) ProtoMessage() {}

func (x *Geoip_CustomHeaderConfig) ProtoReflect() protoreflect.Message {
	mi := &file_envoy_extensions_filters_http_geoip_v3_geoip_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Geoip_CustomHeaderConfig.ProtoReflect.Descriptor instead.
func (*Geoip_CustomHeaderConfig) Descriptor() ([]byte, []int) {
	return file_envoy_extensions_filters_http_geoip_v3_geoip_proto_rawDescGZIP(), []int{0, 1}
}

func (x *Geoip_CustomHeaderConfig) GetHeaderName() string {
	if x != nil {
		return x.HeaderName
	}
	return ""
}

var File_envoy_extensions_filters_http_geoip_v3_geoip_proto protoreflect.FileDescriptor

const file_envoy_extensions_filters_http_geoip_v3_geoip_proto_rawDesc = "" +
	"\n" +
	"2envoy/extensions/filters/http/geoip/v3/geoip.proto\x12&envoy.extensions.filters.http.geoip.v3\x1a$envoy/config/core/v3/extension.proto\x1a\x1fxds/annotations/v3/status.proto\x1a\x1dudpa/annotations/status.proto\x1a\x17validate/validate.proto\"\xa3\x03\n" +
	"\x05Geoip\x12V\n" +
	"\n" +
	"xff_config\x18\x01 \x01(\v27.envoy.extensions.filters.http.geoip.v3.Geoip.XffConfigR\txffConfig\x12r\n" +
	"\x14custom_header_config\x18\x04 \x01(\v2@.envoy.extensions.filters.http.geoip.v3.Geoip.CustomHeaderConfigR\x12customHeaderConfig\x12P\n" +
	"\bprovider\x18\x03 \x01(\v2*.envoy.config.core.v3.TypedExtensionConfigB\b\xfaB\x05\x8a\x01\x02\x10\x01R\bprovider\x1a<\n" +
	"\tXffConfig\x12/\n" +
	"\x14xff_num_trusted_hops\x18\x01 \x01(\rR\x11xffNumTrustedHops\x1a>\n" +
	"\x12CustomHeaderConfig\x12(\n" +
	"\vheader_name\x18\x01 \x01(\tB\a\xfaB\x04r\x02\x10\x01R\n" +
	"headerNameB\xab\x01\xba\x80\xc8\xd1\x06\x02\x10\x02\xd2Ƥ\xe1\x06\x02\b\x01\n" +
	"4io.envoyproxy.envoy.extensions.filters.http.geoip.v3B\n" +
	"GeoipProtoP\x01ZUgithub.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/geoip/v3;geoipv3b\x06proto3"

var (
	file_envoy_extensions_filters_http_geoip_v3_geoip_proto_rawDescOnce sync.Once
	file_envoy_extensions_filters_http_geoip_v3_geoip_proto_rawDescData []byte
)

func file_envoy_extensions_filters_http_geoip_v3_geoip_proto_rawDescGZIP() []byte {
	file_envoy_extensions_filters_http_geoip_v3_geoip_proto_rawDescOnce.Do(func() {
		file_envoy_extensions_filters_http_geoip_v3_geoip_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_envoy_extensions_filters_http_geoip_v3_geoip_proto_rawDesc), len(file_envoy_extensions_filters_http_geoip_v3_geoip_proto_rawDesc)))
	})
	return file_envoy_extensions_filters_http_geoip_v3_geoip_proto_rawDescData
}

var file_envoy_extensions_filters_http_geoip_v3_geoip_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_envoy_extensions_filters_http_geoip_v3_geoip_proto_goTypes = []any{
	(*Geoip)(nil),                    // 0: envoy.extensions.filters.http.geoip.v3.Geoip
	(*Geoip_XffConfig)(nil),          // 1: envoy.extensions.filters.http.geoip.v3.Geoip.XffConfig
	(*Geoip_CustomHeaderConfig)(nil), // 2: envoy.extensions.filters.http.geoip.v3.Geoip.CustomHeaderConfig
	(*v3.TypedExtensionConfig)(nil),  // 3: envoy.config.core.v3.TypedExtensionConfig
}
var file_envoy_extensions_filters_http_geoip_v3_geoip_proto_depIdxs = []int32{
	1, // 0: envoy.extensions.filters.http.geoip.v3.Geoip.xff_config:type_name -> envoy.extensions.filters.http.geoip.v3.Geoip.XffConfig
	2, // 1: envoy.extensions.filters.http.geoip.v3.Geoip.custom_header_config:type_name -> envoy.extensions.filters.http.geoip.v3.Geoip.CustomHeaderConfig
	3, // 2: envoy.extensions.filters.http.geoip.v3.Geoip.provider:type_name -> envoy.config.core.v3.TypedExtensionConfig
	3, // [3:3] is the sub-list for method output_type
	3, // [3:3] is the sub-list for method input_type
	3, // [3:3] is the sub-list for extension type_name
	3, // [3:3] is the sub-list for extension extendee
	0, // [0:3] is the sub-list for field type_name
}

func init() { file_envoy_extensions_filters_http_geoip_v3_geoip_proto_init() }
func file_envoy_extensions_filters_http_geoip_v3_geoip_proto_init() {
	if File_envoy_extensions_filters_http_geoip_v3_geoip_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_envoy_extensions_filters_http_geoip_v3_geoip_proto_rawDesc), len(file_envoy_extensions_filters_http_geoip_v3_geoip_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   3,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_envoy_extensions_filters_http_geoip_v3_geoip_proto_goTypes,
		DependencyIndexes: file_envoy_extensions_filters_http_geoip_v3_geoip_proto_depIdxs,
		MessageInfos:      file_envoy_extensions_filters_http_geoip_v3_geoip_proto_msgTypes,
	}.Build()
	File_envoy_extensions_filters_http_geoip_v3_geoip_proto = out.File
	file_envoy_extensions_filters_http_geoip_v3_geoip_proto_goTypes = nil
	file_envoy_extensions_filters_http_geoip_v3_geoip_proto_depIdxs = nil
}
