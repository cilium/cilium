# Italian translation.
# Copyright (C) 2017
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR evolution85@gmail.com, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: kubernetes\n"
"Report-Msgid-Bugs-To: EMAIL\n"
"POT-Creation-Date: 2017-03-14 21:32-0700\n"
"PO-Revision-Date: 2017-08-04 17:54+0200\n"
"Language: it_IT\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Last-Translator: Luca Berton <mr.evolution85@gmail.com>\n"
"Language-Team: Luca Berton <mr.evolution85@gmail.com>\n"
"X-Generator: Poedit 1.8.7.1\n"
"X-Poedit-SourceCharset: UTF-8\n"

#: pkg/kubectl/cmd/create_clusterrolebinding.go:35
msgid ""
"\n"
"\t\t  # Create a ClusterRoleBinding for user1, user2, and group1 using the "
"cluster-admin ClusterRole\n"
"\t\t  kubectl create clusterrolebinding cluster-admin --clusterrole=cluster-"
"admin --user=user1 --user=user2 --group=group1"
msgstr ""
"\n"
"\t\t # Creare un ClusterRoleBinding per user1, user2 e group1 utilizzando il "
"cluster-admin ClusterRole\n"
"\t\t  kubectl create clusterrolebinding cluster-admin --clusterrole=cluster-"
"admin --user=user1 --user=user2 --group=group1"

#: pkg/kubectl/cmd/create_rolebinding.go:35
msgid ""
"\n"
"\t\t  # Create a RoleBinding for user1, user2, and group1 using the admin "
"ClusterRole\n"
"\t\t  kubectl create rolebinding admin --clusterrole=admin --user=user1 --"
"user=user2 --group=group1"
msgstr ""
"\n"
"\t\t  # Crea un RoleBinding per user1, user2, and group1 utilizzando l'admin "
"ClusterRole\n"
"\t\t  kubectl create rolebinding admin --clusterrole=admin --user=user1 --"
"user=user2 --group=group1"

#: pkg/kubectl/cmd/create_configmap.go:44
msgid ""
"\n"
"\t\t  # Create a new configmap named my-config based on folder bar\n"
"\t\t  kubectl create configmap my-config --from-file=path/to/bar\n"
"\n"
"\t\t  # Create a new configmap named my-config with specified keys instead of "
"file basenames on disk\n"
"\t\t  kubectl create configmap my-config --from-file=key1=/path/to/bar/file1."
"txt --from-file=key2=/path/to/bar/file2.txt\n"
"\n"
"\t\t  # Create a new configmap named my-config with key1=config1 and "
"key2=config2\n"
"\t\t  kubectl create configmap my-config --from-literal=key1=config1 --from-"
"literal=key2=config2"
msgstr ""
"\n"
"\t\t  # Crea un nuovo configmap denominato my-config in base alla cartella "
"bar\n"
"\t\t  kubectl create configmap my-config --from-file=path/to/bar\n"
"\n"
"\t\t  # Crea un nuovo configmap denominato my-config con le chiavi "
"specificate anziché i nomi dei file su disco\n"
"\t\t  kubectl create configmap my-config --from-file=key1=/path/to/bar/file1."
"txt --from-file=key2=/path/to/bar/file2.txt\n"
"\n"
"\t\t  # Crea un nuovo configmap denominato my-config con key1 = config1 e "
"key2 = config2\n"
"\t\t  kubectl create configmap my-config --from-literal=key1=config1 --from-"
"literal=key2=config2"

#: pkg/kubectl/cmd/create_secret.go:135
msgid ""
"\n"
"\t\t  # If you don't already have a .dockercfg file, you can create a "
"dockercfg secret directly by using:\n"
"\t\t  kubectl create secret docker-registry my-secret --docker-"
"server=DOCKER_REGISTRY_SERVER --docker-username=DOCKER_USER --docker-"
"password=DOCKER_PASSWORD --docker-email=DOCKER_EMAIL"
msgstr ""
"\n"
"\t\t  # Se non si dispone ancora di un file .dockercfg, è possibile creare un "
"secret dockercfg direttamente utilizzando:\n"
"\t\t  kubectl create secret docker-registry my-secret --docker-"
"server=DOCKER_REGISTRY_SERVER --docker-username=DOCKER_USER --docker-"
"password=DOCKER_PASSWORD --docker-email=DOCKER_EMAIL"

#: pkg/kubectl/cmd/top_node.go:65
msgid ""
"\n"
"\t\t  # Show metrics for all nodes\n"
"\t\t  kubectl top node\n"
"\n"
"\t\t  # Show metrics for a given node\n"
"\t\t  kubectl top node NODE_NAME"
msgstr ""
"\n"
"\t\t  # Mostra metriche per tutti i nodi\n"
"\t\t kubectl top node\n"
"\n"
"\t\t # Mostra metriche per un determinato nodo\n"
"\t\t kubectl top node NODE_NAME"

#: pkg/kubectl/cmd/apply.go:84
msgid ""
"\n"
"\t\t# Apply the configuration in pod.json to a pod.\n"
"\t\tkubectl apply -f ./pod.json\n"
"\n"
"\t\t# Apply the JSON passed into stdin to a pod.\n"
"\t\tcat pod.json | kubectl apply -f -\n"
"\n"
"\t\t# Note: --prune is still in Alpha\n"
"\t\t# Apply the configuration in manifest.yaml that matches label app=nginx "
"and delete all the other resources that are not in the file and match label "
"app=nginx.\n"
"\t\tkubectl apply --prune -f manifest.yaml -l app=nginx\n"
"\n"
"\t\t# Apply the configuration in manifest.yaml and delete all the other "
"configmaps that are not in the file.\n"
"\t\tkubectl apply --prune -f manifest.yaml --all --prune-whitelist=core/v1/"
"ConfigMap"
msgstr ""
"\n"
"\t\t# Applica la configurazione pod.json a un pod.\n"
"\t\tkubectl apply -f ./pod.json\n"
"\n"
"\t\t# Applicare il JSON passato in stdin a un pod.\n"
"\t\tcat pod.json | kubectl apply -f -\n"
"\n"
"\t\t# Nota: --prune è ancora in in Alpha\n"
"\t\t# Applica la configurazione manifest.yaml che corrisponde alla label app "
"= nginx ed elimina tutte le altre risorse che non sono nel file e nella label "
"corrispondente app = nginx.\n"
"\t\tkubectl apply --prune -f manifest.yaml -l app=nginx\n"
"\n"
"\t\t# Applica la configurazione manifest.yaml ed elimina tutti gli altri "
"configmaps non presenti nel file.\n"
"\t\tkubectl apply --prune -f manifest.yaml --all --prune-whitelist=core/v1/"
"ConfigMap"

#: pkg/kubectl/cmd/autoscale.go:40
#, c-format
msgid ""
"\n"
"\t\t# Auto scale a deployment \"foo\", with the number of pods between 2 and "
"10, target CPU utilization specified so a default autoscaling policy will be "
"used:\n"
"\t\tkubectl autoscale deployment foo --min=2 --max=10\n"
"\n"
"\t\t# Auto scale a replication controller \"foo\", with the number of pods "
"between 1 and 5, target CPU utilization at 80%:\n"
"\t\tkubectl autoscale rc foo --max=5 --cpu-percent=80"
msgstr ""
"\n"
"\t\t#  Auto scale un deployment \"foo\", con il numero di pod compresi tra 2 "
"e 10, utilizzo della CPU target specificato in modo da utilizzare una "
"politica di autoscaling predefinita:\n"
"\t\tkubectl autoscale deployment foo --min=2 --max=10\n"
"\n"
"\t\t# Auto scale un controller di replica \"foo\", con il numero di pod "
"compresi tra 1 e 5, utilizzo dell'utilizzo della CPU a 80%:\n"
"\t\tkubectl autoscale rc foo --max=5 --cpu-percent=80"

#: pkg/kubectl/cmd/convert.go:49
msgid ""
"\n"
"\t\t# Convert 'pod.yaml' to latest version and print to stdout.\n"
"\t\tkubectl convert -f pod.yaml\n"
"\n"
"\t\t# Convert the live state of the resource specified by 'pod.yaml' to the "
"latest version\n"
"\t\t# and print to stdout in json format.\n"
"\t\tkubectl convert -f pod.yaml --local -o json\n"
"\n"
"\t\t# Convert all files under current directory to latest version and create "
"them all.\n"
"\t\tkubectl convert -f . | kubectl create -f -"
msgstr ""
"\n"
"\t\t# Converte 'pod.yaml' alla versione più recente e stampa in stdout.\n"
"\t\tkubectl convert -f pod.yaml\n"
"\n"
"\t\t# Converte lo stato live della risorsa specificata da 'pod.yaml' nella "
"versione più recente.\n"
"\t\t# e stampa in stdout nel formato json.\n"
"\t\tkubectl convert -f pod.yaml --local -o json\n"
"\n"
"\t\t# Converte tutti i file nella directory corrente alla versione più "
"recente e li crea tutti.\n"
"\t\tkubectl convert -f . | kubectl create -f -"

#: pkg/kubectl/cmd/create_clusterrole.go:34
msgid ""
"\n"
"\t\t# Create a ClusterRole named \"pod-reader\" that allows user to perform "
"\"get\", \"watch\" and \"list\" on pods\n"
"\t\tkubectl create clusterrole pod-reader --verb=get,list,watch --"
"resource=pods\n"
"\n"
"\t\t# Create a ClusterRole named \"pod-reader\" with ResourceName specified\n"
"\t\tkubectl create clusterrole pod-reader --verb=get,list,watch --"
"resource=pods --resource-name=readablepod"
msgstr ""
"\n"
"\t\t# Crea un ClusterRole denominato \"pod-reader\" che consente all'utente "
"di eseguire \"get\", \"watch\" e \"list\" sui pod\n"
"\t\tkubectl create clusterrole pod-reader --verb=get,list,watch --"
"resource=pods\n"
"\n"
"\t\t# Crea un ClusterRole denominato \"pod-reader\" con ResourceName "
"specificato\n"
"\t\tkubectl create clusterrole pod-reader --verb=get,list,watch --"
"resource=pods --resource-name=readablepod"

#: pkg/kubectl/cmd/create_role.go:41
msgid ""
"\n"
"\t\t# Create a Role named \"pod-reader\" that allows user to perform \"get\", "
"\"watch\" and \"list\" on pods\n"
"\t\tkubectl create role pod-reader --verb=get --verb=list --verb=watch --"
"resource=pods\n"
"\n"
"\t\t# Create a Role named \"pod-reader\" with ResourceName specified\n"
"\t\tkubectl create role pod-reader --verb=get --verg=list --verb=watch --"
"resource=pods --resource-name=readablepod"
msgstr ""
"\n"
"\t\t# Crea un ruolo denominato \"pod-reader\" che consente all'utente di "
"eseguire \"get\", \"watch\" e \"list\" sui pod\n"
"\t\tkubectl create role pod-reader --verb=get --verb=list --verb=watch --"
"resource=pods\n"
"\n"
"\t\t# Crea un ruolo denominato \"pod-reader\" con ResourceName specificato\n"
"\t\tkubectl create role pod-reader --verb=get --verg=list --verb=watch --"
"resource=pods --resource-name=readablepod"

#: pkg/kubectl/cmd/create_quota.go:35
msgid ""
"\n"
"\t\t# Create a new resourcequota named my-quota\n"
"\t\tkubectl create quota my-quota --hard=cpu=1,memory=1G,pods=2,services=3,"
"replicationcontrollers=2,resourcequotas=1,secrets=5,"
"persistentvolumeclaims=10\n"
"\n"
"\t\t# Create a new resourcequota named best-effort\n"
"\t\tkubectl create quota best-effort --hard=pods=100 --scopes=BestEffort"
msgstr ""
"\n"
"\t\t# Crea una nuova resourcequota chiamata my-quota\n"
"\t\tkubectl create quota my-quota --hard=cpu=1,memory=1G,pods=2,services=3,"
"replicationcontrollers=2,resourcequotas=1,secrets=5,"
"persistentvolumeclaims=10\n"
"\n"
"\t\t# Creare una nuova resourcequota denominata best-effort\n"
"\t\tkubectl create quota best-effort --hard=pods=100 --scopes=BestEffort"

#: pkg/kubectl/cmd/create_pdb.go:35
#, c-format
msgid ""
"\n"
"\t\t# Create a pod disruption budget named my-pdb that will select all pods "
"with the app=rails label\n"
"\t\t# and require at least one of them being available at any point in time.\n"
"\t\tkubectl create poddisruptionbudget my-pdb --selector=app=rails --min-"
"available=1\n"
"\n"
"\t\t# Create a pod disruption budget named my-pdb that will select all pods "
"with the app=nginx label\n"
"\t\t# and require at least half of the pods selected to be available at any "
"point in time.\n"
"\t\tkubectl create pdb my-pdb --selector=app=nginx --min-available=50%"
msgstr ""
"\n"
"\t\t# Crea un pod disruption budget chiamato my-pdb che seleziona tutti i pod "
"con label app = rail\n"
"\t\t# e richiede che almeno uno di essi sia disponibile in qualsiasi "
"momento.\n"
"\t\tkubectl create poddisruptionbudget my-pdb --selector=app=rails --min-"
"available=1\n"
"\n"
"\t\t# Crea un pod disruption budget con nome my-pdb che seleziona tutti i pod "
"con label app = nginx \n"
"\t\t# e richiede che almeno la metà dei pod selezionati sia disponibile in "
"qualsiasi momento.\n"
"\t\tkubectl create pdb my-pdb --selector=app=nginx --min-available=50%"

#: pkg/kubectl/cmd/create.go:47
msgid ""
"\n"
"\t\t# Create a pod using the data in pod.json.\n"
"\t\tkubectl create -f ./pod.json\n"
"\n"
"\t\t# Create a pod based on the JSON passed into stdin.\n"
"\t\tcat pod.json | kubectl create -f -\n"
"\n"
"\t\t# Edit the data in docker-registry.yaml in JSON using the v1 API format "
"then create the resource using the edited data.\n"
"\t\tkubectl create -f docker-registry.yaml --edit --output-version=v1 -o json"
msgstr ""
"\n"
"\t\t# Crea un pod utilizzando i dati in pod.json.\n"
"\t\tkubectl create -f ./pod.json\n"
"\n"
"\t\t# Crea un pod basato sul JSON passato in stdin.\n"
"\t\tcat pod.json | kubectl create -f -\n"
"\n"
"\t\t# Modifica i dati in docker-registry.yaml in JSON utilizzando il formato "
"API v1 quindi creare la risorsa utilizzando i dati modificati.\n"
"\t\tkubectl create -f docker-registry.yaml --edit --output-version=v1 -o json"

#: pkg/kubectl/cmd/expose.go:53
msgid ""
"\n"
"\t\t# Create a service for a replicated nginx, which serves on port 80 and "
"connects to the containers on port 8000.\n"
"\t\tkubectl expose rc nginx --port=80 --target-port=8000\n"
"\n"
"\t\t# Create a service for a replication controller identified by type and "
"name specified in \"nginx-controller.yaml\", which serves on port 80 and "
"connects to the containers on port 8000.\n"
"\t\tkubectl expose -f nginx-controller.yaml --port=80 --target-port=8000\n"
"\n"
"\t\t# Create a service for a pod valid-pod, which serves on port 444 with the "
"name \"frontend\"\n"
"\t\tkubectl expose pod valid-pod --port=444 --name=frontend\n"
"\n"
"\t\t# Create a second service based on the above service, exposing the "
"container port 8443 as port 443 with the name \"nginx-https\"\n"
"\t\tkubectl expose service nginx --port=443 --target-port=8443 --name=nginx-"
"https\n"
"\n"
"\t\t# Create a service for a replicated streaming application on port 4100 "
"balancing UDP traffic and named 'video-stream'.\n"
"\t\tkubectl expose rc streamer --port=4100 --protocol=udp --name=video-"
"stream\n"
"\n"
"\t\t# Create a service for a replicated nginx using replica set, which serves "
"on port 80 and connects to the containers on port 8000.\n"
"\t\tkubectl expose rs nginx --port=80 --target-port=8000\n"
"\n"
"\t\t# Create a service for an nginx deployment, which serves on port 80 and "
"connects to the containers on port 8000.\n"
"\t\tkubectl expose deployment nginx --port=80 --target-port=8000"
msgstr ""
"\n"
"\t\t# Crea un servizio per un nginx replicato, che serve nella porta 80 e si "
"collega ai container sulla porta 8000.\n"
"\t\tkubectl expose rc nginx --port=80 --target-port=8000\n"
"\n"
"\t\t# Crea un servizio per un controller di replica identificato per tipo e "
"nome specificato in \"nginx-controller.yaml\", che serve nella porta 80 e si "
"collega ai container sulla porta 8000.\n"
"\t\tkubectl expose -f nginx-controller.yaml --port=80 --target-port=8000\n"
"\n"
"\t\t# Crea un servizio per un pod valid-pod, che serve nella porta 444 con il "
"nome \"frontend\"\n"
"\t\tkubectl expose pod valid-pod --port=444 --name=frontend\n"
"\n"
"\t\t# Crea un secondo servizio basato sul servizio sopra, esponendo la porta "
"container 8443 come porta 443 con il nome \"nginx-https\"\n"
"\t\tkubectl expose service nginx --port=443 --target-port=8443 --name=nginx-"
"https\n"
"\n"
"\t\t#  Crea un servizio per un'applicazione di replica in porta 4100 che "
"bilanci il traffico UDP e denominato \"video stream\".\n"
"\t\tkubectl expose rc streamer --port=4100 --protocol=udp --name=video-"
"stream\n"
"\n"
"\t\t# Crea un servizio per un nginx replicato utilizzando l'insieme di "
"replica, che serve nella porta 80 e si collega ai contenitori sulla porta "
"8000.\n"
"\t\tkubectl expose rs nginx --port=80 --target-port=8000\n"
"\n"
"\t\t# Crea un servizio per una distribuzione di nginx, che serve nella porta "
"80 e si collega ai contenitori della porta 8000.\n"
"\t\tkubectl expose deployment nginx --port=80 --target-port=8000"

#: pkg/kubectl/cmd/delete.go:68
msgid ""
"\n"
"\t\t# Delete a pod using the type and name specified in pod.json.\n"
"\t\tkubectl delete -f ./pod.json\n"
"\n"
"\t\t# Delete a pod based on the type and name in the JSON passed into stdin.\n"
"\t\tcat pod.json | kubectl delete -f -\n"
"\n"
"\t\t# Delete pods and services with same names \"baz\" and \"foo\"\n"
"\t\tkubectl delete pod,service baz foo\n"
"\n"
"\t\t# Delete pods and services with label name=myLabel.\n"
"\t\tkubectl delete pods,services -l name=myLabel\n"
"\n"
"\t\t# Delete a pod with minimal delay\n"
"\t\tkubectl delete pod foo --now\n"
"\n"
"\t\t# Force delete a pod on a dead node\n"
"\t\tkubectl delete pod foo --grace-period=0 --force\n"
"\n"
"\t\t# Delete all pods\n"
"\t\tkubectl delete pods --all"
msgstr ""
"\n"
"\t\t# Elimina un pod utilizzando il tipo e il nome specificati in pod.json.\n"
"\t\tkubectl delete -f ./pod.json\n"
"\n"
"\t\t# Elimina un pod in base al tipo e al nome del JSON passato in stdin.\n"
"\t\tcat pod.json | kubectl delete -f -\n"
"\n"
"\t\t# Elimina i baccelli ei servizi con gli stessi nomi \"baz\" e \"foo\"\n"
"\t\tkubectl delete pod,service baz foo\n"
"\n"
"\t\t# Elimina i baccelli ei servizi con il nome dell'etichetta = myLabel.\n"
"\t\tkubectl delete pods,services -l name=myLabel\n"
"\n"
"\t\t# Eliminare un pod con un ritardo minimo\n"
"\t\tkubectl delete pod foo --now\n"
"\n"
"\t\t# Forza elimina un pod in un nodo morto\n"
"\t\tkubectl delete pod foo --grace-period=0 --force\n"
"\n"
"\t\t# Elimina tutti i pod\n"
"\t\tkubectl delete pods --all"

#: pkg/kubectl/cmd/describe.go:54
msgid ""
"\n"
"\t\t# Describe a node\n"
"\t\tkubectl describe nodes kubernetes-node-emt8.c.myproject.internal\n"
"\n"
"\t\t# Describe a pod\n"
"\t\tkubectl describe pods/nginx\n"
"\n"
"\t\t# Describe a pod identified by type and name in \"pod.json\"\n"
"\t\tkubectl describe -f pod.json\n"
"\n"
"\t\t# Describe all pods\n"
"\t\tkubectl describe pods\n"
"\n"
"\t\t# Describe pods by label name=myLabel\n"
"\t\tkubectl describe po -l name=myLabel\n"
"\n"
"\t\t# Describe all pods managed by the 'frontend' replication controller (rc-"
"created pods\n"
"\t\t# get the name of the rc as a prefix in the pod the name).\n"
"\t\tkubectl describe pods frontend"
msgstr ""
"\n"
"\t\t# Descrive un nodo\n"
"\t\tkubectl describe nodes kubernetes-node-emt8.c.myproject.internal\n"
"\n"
"\t\t# Descrive un pod\n"
"\t\tkubectl describe pods/nginx\n"
"\n"
"\t\t# Descrive un pod identificato da tipo e nome in \"pod.json\"\n"
"\t\tkubectl describe -f pod.json\n"
"\n"
"\t\t# Descrive tutti i pod\n"
"\t\tkubectl describe pods\n"
"\n"
"\t\t# Descrive i pod con label name=myLabel\n"
"\t\tkubectl describe po -l name=myLabel\n"
"\n"
"\t\t# Descrivere tutti i pod gestiti dal controller di replica \"frontend"
"\"  (rc-created pods\n"
"\t\t# ottiene il nome del rc come un prefisso del nome pod).\n"
"\t\tkubectl describe pods frontend"

#: pkg/kubectl/cmd/drain.go:165
msgid ""
"\n"
"\t\t# Drain node \"foo\", even if there are pods not managed by a "
"ReplicationController, ReplicaSet, Job, DaemonSet or StatefulSet on it.\n"
"\t\t$ kubectl drain foo --force\n"
"\n"
"\t\t# As above, but abort if there are pods not managed by a "
"ReplicationController, ReplicaSet, Job, DaemonSet or StatefulSet, and use a "
"grace period of 15 minutes.\n"
"\t\t$ kubectl drain foo --grace-period=900"
msgstr ""
"\n"
"\t\t# Drain node \"foo\", anche se ci sono i baccelli non gestiti da "
"ReplicationController, ReplicaSet, Job, DaemonSet o StatefulSet su di esso.\n"
"\t\t$ kubectl drain foo --force\n"
"\n"
"\t\t# Come sopra, ma interrompere se ci sono i baccelli non gestiti da "
"ReplicationController, ReplicaSet, Job, DaemonSet or StatefulSet, e "
"utilizzare un periodo di grazia di 15 minuti.\n"
"\t\t$ kubectl drain foo --grace-period=900"

#: pkg/kubectl/cmd/edit.go:80
msgid ""
"\n"
"\t\t# Edit the service named 'docker-registry':\n"
"\t\tkubectl edit svc/docker-registry\n"
"\n"
"\t\t# Use an alternative editor\n"
"\t\tKUBE_EDITOR=\"nano\" kubectl edit svc/docker-registry\n"
"\n"
"\t\t# Edit the job 'myjob' in JSON using the v1 API format:\n"
"\t\tkubectl edit job.v1.batch/myjob -o json\n"
"\n"
"\t\t# Edit the deployment 'mydeployment' in YAML and save the modified config "
"in its annotation:\n"
"\t\tkubectl edit deployment/mydeployment -o yaml --save-config"
msgstr ""
"\n"
"\t\t# Modifica il servizio denominato 'docker-registry':\n"
"\t\tkubectl edit svc/docker-registry\n"
"\n"
"\t\t# Usa un editor alternativo\n"
"\t\tKUBE_EDITOR=\"nano\" kubectl edit svc/docker-registry\n"
"\n"
"\t\t# Modifica il lavoro 'myjob' in JSON utilizzando il formato API v1:\n"
"\t\tkubectl edit job.v1.batch/myjob -o json\n"
"\n"
"\t\t# Modifica la distribuzione 'mydeployment' in YAML e salvare la "
"configurazione modificata nella sua annotazione:\n"
"\t\tkubectl edit deployment/mydeployment -o yaml --save-config"

#: pkg/kubectl/cmd/exec.go:41
msgid ""
"\n"
"\t\t# Get output from running 'date' from pod 123456-7890, using the first "
"container by default\n"
"\t\tkubectl exec 123456-7890 date\n"
"\n"
"\t\t# Get output from running 'date' in ruby-container from pod 123456-7890\n"
"\t\tkubectl exec 123456-7890 -c ruby-container date\n"
"\n"
"\t\t# Switch to raw terminal mode, sends stdin to 'bash' in ruby-container "
"from pod 123456-7890\n"
"\t\t# and sends stdout/stderr from 'bash' back to the client\n"
"\t\tkubectl exec 123456-7890 -c ruby-container -i -t -- bash -il"
msgstr ""
"\n"
"\t\t# Ottieni l'output dalla 'data' di esecuzione del pod 123456-7890, "
"utilizzando il primo contenitore per impostazione predefinita\n"
"\t\tkubectl exec 123456-7890 date\n"
"\n"
"\t\t# Ottieni l'output dalla data di esecuzione in ruby-container del pod "
"123456-7890\n"
"\t\tkubectl exec 123456-7890 -c ruby-container date\n"
"\n"
"\t\t# Passare alla modalità raw terminal, invia stdin a 'bash' in ruby-"
"container del pod 123456-7890\n"
"\t\t# and sends stdout/stderr from 'bash' back to the client\n"
"\t\tkubectl exec 123456-7890 -c ruby-container -i -t -- bash -il"

#: pkg/kubectl/cmd/attach.go:42
msgid ""
"\n"
"\t\t# Get output from running pod 123456-7890, using the first container by "
"default\n"
"\t\tkubectl attach 123456-7890\n"
"\n"
"\t\t# Get output from ruby-container from pod 123456-7890\n"
"\t\tkubectl attach 123456-7890 -c ruby-container\n"
"\n"
"\t\t# Switch to raw terminal mode, sends stdin to 'bash' in ruby-container "
"from pod 123456-7890\n"
"\t\t# and sends stdout/stderr from 'bash' back to the client\n"
"\t\tkubectl attach 123456-7890 -c ruby-container -i -t\n"
"\n"
"\t\t# Get output from the first pod of a ReplicaSet named nginx\n"
"\t\tkubectl attach rs/nginx\n"
"\t\t"
msgstr ""
"\n"
"\t\t# Ottieni l'output dal pod 123456-7890 in esecuzione, utilizzando il "
"primo contenitore per impostazione predefinita\n"
"\t\tkubectl attach 123456-7890\n"
"\n"
"\t\t#  Ottieni l'output dal  ruby-container del pod 123456-7890\n"
"\t\tkubectl attach 123456-7890 -c ruby-container\n"
"\n"
"\t\t# Passa alla modalità raw terminal, invia stdin a 'bash' in ruby-"
"container del pod 123456-7890\n"
"\t\t# e invia stdout/stderr da 'bash' al client\n"
"\t\tkubectl attach 123456-7890 -c ruby-container -i -t\n"
"\n"
"\t\t# Ottieni l'output dal primo pod di una ReplicaSet denominata nginx\n"
"\t\tkubectl attach rs/nginx\n"
"\t\t"

#: pkg/kubectl/cmd/explain.go:39
msgid ""
"\n"
"\t\t# Get the documentation of the resource and its fields\n"
"\t\tkubectl explain pods\n"
"\n"
"\t\t# Get the documentation of a specific field of a resource\n"
"\t\tkubectl explain pods.spec.containers"
msgstr ""
"\n"
"\t\t# Ottieni la documentazione della risorsa e i relativi campi\n"
"\t\tkubectl explain pods\n"
"\n"
"\t\t# Ottieni la documentazione di un campo specifico di una risorsa\n"
"\t\tkubectl explain pods.spec.containers"

#: pkg/kubectl/cmd/completion.go:65
msgid ""
"\n"
"\t\t# Install bash completion on a Mac using homebrew\n"
"\t\tbrew install bash-completion\n"
"\t\tprintf \"\n"
"# Bash completion support\n"
"source $(brew --prefix)/etc/bash_completion\n"
"\" >> $HOME/.bash_profile\n"
"\t\tsource $HOME/.bash_profile\n"
"\n"
"\t\t# Load the kubectl completion code for bash into the current shell\n"
"\t\tsource <(kubectl completion bash)\n"
"\n"
"\t\t# Write bash completion code to a file and source if from .bash_profile\n"
"\t\tkubectl completion bash > ~/.kube/completion.bash.inc\n"
"\t\tprintf \"\n"
"# Kubectl shell completion\n"
"source '$HOME/.kube/completion.bash.inc'\n"
"\" >> $HOME/.bash_profile\n"
"\t\tsource $HOME/.bash_profile\n"
"\n"
"\t\t# Load the kubectl completion code for zsh[1] into the current shell\n"
"\t\tsource <(kubectl completion zsh)"
msgstr ""
"\n"
"\t\t# Installa il completamento di bash su un Mac utilizzando homebrew\n"
"\t\tbrew install bash-completion\n"
"\t\tprintf \"\n"
"# Bash completion support\n"
"source $(brew --prefix)/etc/bash_completion\n"
"\" >> $HOME/.bash_profile\n"
"\t\tsource $HOME/.bash_profile\n"
"\n"
"\t\t# Carica il codice di completamento kubectl per bash nella shell "
"corrente\n"
"\t\tsource <(kubectl completion bash)\n"
"\n"
"\t\t# Scrive il codice di completamento bash in un file e lo carica da ."
"bash_profile\n"
"\t\tkubectl completion bash > ~/.kube/completion.bash.inc\n"
"\t\tprintf \"\n"
"# Kubectl shell completion\n"
"source '$HOME/.kube/completion.bash.inc'\n"
"\" >> $HOME/.bash_profile\n"
"\t\tsource $HOME/.bash_profile\n"
"\n"
"\t\t# Carica il codice di completamento kubectl per zsh [1] nella shell "
"corrente\n"
"\t\tsource <(kubectl completion zsh)"

#: pkg/kubectl/cmd/get.go:64
msgid ""
"\n"
"\t\t# List all pods in ps output format.\n"
"\t\tkubectl get pods\n"
"\n"
"\t\t# List all pods in ps output format with more information (such as node "
"name).\n"
"\t\tkubectl get pods -o wide\n"
"\n"
"\t\t# List a single replication controller with specified NAME in ps output "
"format.\n"
"\t\tkubectl get replicationcontroller web\n"
"\n"
"\t\t# List a single pod in JSON output format.\n"
"\t\tkubectl get -o json pod web-pod-13je7\n"
"\n"
"\t\t# List a pod identified by type and name specified in \"pod.yaml\" in "
"JSON output format.\n"
"\t\tkubectl get -f pod.yaml -o json\n"
"\n"
"\t\t# Return only the phase value of the specified pod.\n"
"\t\tkubectl get -o template pod/web-pod-13je7 --template={{.status.phase}}\n"
"\n"
"\t\t# List all replication controllers and services together in ps output "
"format.\n"
"\t\tkubectl get rc,services\n"
"\n"
"\t\t# List one or more resources by their type and names.\n"
"\t\tkubectl get rc/web service/frontend pods/web-pod-13je7\n"
"\n"
"\t\t# List all resources with different types.\n"
"\t\tkubectl get all"
msgstr ""
"\n"
"\t\t# Elenca tutti i pod in formato output ps.\n"
"\t\tkubectl get pods\n"
"\n"
"\t\t# Elenca tutti i pod in formato output ps con maggiori informazioni (ad "
"esempio il nome del nodo).\n"
"\t\tkubectl get pods -o wide\n"
"\n"
"\t\t# Elenca un controller di replica singolo con NAME specificato nel "
"formato di output ps.\n"
"\t\tkubectl get replicationcontroller web\n"
"\n"
"\t\t# Elenca un singolo pod nel formato di uscita JSON.\n"
"\t\tkubectl get -o json pod web-pod-13je7\n"
"\n"
"\t\t# Elenca un pod identificato per tipo e nome specificato in \"pod.yaml\" "
"nel formato di uscita JSON.\n"
"\t\tkubectl get -f pod.yaml -o json\n"
"\n"
"\t\t# Restituisce solo il valore di fase del pod specificato.\n"
"\t\tkubectl get -o template pod/web-pod-13je7 --template={{.status.phase}}\n"
"\n"
"\t\t# Elenca tutti i controller e servizi di replica insieme in formato "
"output ps.\n"
"\t\tkubectl get rc,services\n"
"\n"
"\t\t# Elenca una o più risorse per il tipo e per i nomi.\n"
"\t\tkubectl get rc/web service/frontend pods/web-pod-13je7\n"
"\n"
"\t\t# Elenca tutte le risorse con tipi diversi.\n"
"\t\tkubectl get all"

#: pkg/kubectl/cmd/portforward.go:53
msgid ""
"\n"
"\t\t# Listen on ports 5000 and 6000 locally, forwarding data to/from ports "
"5000 and 6000 in the pod\n"
"\t\tkubectl port-forward mypod 5000 6000\n"
"\n"
"\t\t# Listen on port 8888 locally, forwarding to 5000 in the pod\n"
"\t\tkubectl port-forward mypod 8888:5000\n"
"\n"
"\t\t# Listen on a random port locally, forwarding to 5000 in the pod\n"
"\t\tkubectl port-forward mypod :5000\n"
"\n"
"\t\t# Listen on a random port locally, forwarding to 5000 in the pod\n"
"\t\tkubectl port-forward mypod 0:5000"
msgstr ""
"\n"
"\t\t# Ascolta localmente le porte 5000 e 6000, inoltrando i dati da/verso le "
"porte 5000 e 6000 nel pod\n"
"\t\tkubectl port-forward mypod 5000 6000\n"
"\n"
"\t\t# Ascolta localmente la porta 8888, inoltra a 5000 nel pod\n"
"\t\tkubectl port-forward mypod 8888:5000\n"
"\n"
"\t\t# Ascolta localmente una porta casuale, inoltra a 5000 nel pod\n"
"\t\tkubectl port-forward mypod :5000\n"
"\n"
"\t\t# Ascolta localmente una porta casuale, inoltra a 5000 nel pod\n"
"\t\tkubectl port-forward mypod 0:5000"

#: pkg/kubectl/cmd/drain.go:118
msgid ""
"\n"
"\t\t# Mark node \"foo\" as schedulable.\n"
"\t\t$ kubectl uncordon foo"
msgstr ""
"\n"
"\t\t# Segna il nodo \"foo\" come programmabile.\n"
"\t\t$ Kubectl uncordon foo"

#: pkg/kubectl/cmd/drain.go:93
msgid ""
"\n"
"\t\t# Mark node \"foo\" as unschedulable.\n"
"\t\tkubectl cordon foo"
msgstr ""
"\n"
"\t\t#  Segna il nodo \"foo\" come non programmabile.\n"
"\t\tkubectl cordon foo"

#: pkg/kubectl/cmd/patch.go:66
msgid ""
"\n"
"\t\t# Partially update a node using strategic merge patch\n"
"\t\tkubectl patch node k8s-node-1 -p '{\"spec\":{\"unschedulable\":true}}'\n"
"\n"
"\t\t# Partially update a node identified by the type and name specified in "
"\"node.json\" using strategic merge patch\n"
"\t\tkubectl patch -f node.json -p '{\"spec\":{\"unschedulable\":true}}'\n"
"\n"
"\t\t# Update a container's image; spec.containers[*].name is required because "
"it's a merge key\n"
"\t\tkubectl patch pod valid-pod -p '{\"spec\":{\"containers\":[{\"name\":"
"\"kubernetes-serve-hostname\",\"image\":\"new image\"}]}}'\n"
"\n"
"\t\t# Update a container's image using a json patch with positional arrays\n"
"\t\tkubectl patch pod valid-pod --type='json' -p='[{\"op\": \"replace\", "
"\"path\": \"/spec/containers/0/image\", \"value\":\"new image\"}]'"
msgstr ""
"\n"
"\t\t# Aggiorna parzialmente un nodo utilizzando merge patch strategica\n"
"\t\tkubectl patch node k8s-node-1 -p '{\"spec\":{\"unschedulable\":true}}'\n"
"\n"
"\t\t# Aggiorna parzialmente un nodo identificato dal tipo e dal nome "
"specificato in \"node.json\" utilizzando  merge patch strategica\n"
"\t\tkubectl patch -f node.json -p '{\"spec\":{\"unschedulable\":true}}'\n"
"\n"
"\t\t# Aggiorna l'immagine di un contenitore; spec.containers [*]. name è "
"richiesto perché è una chiave di fusione\n"
"\t\tkubectl patch pod valid-pod -p '{\"spec\":{\"containers\":[{\"name\":"
"\"kubernetes-serve-hostname\",\"image\":\"new image\"}]}}'\n"
"\n"
"\t\t# Aggiorna l'immagine di un contenitore utilizzando una patch json con "
"array posizionali\n"
"\t\tkubectl patch pod valid-pod --type='json' -p='[{\"op\": \"replace\", "
"\"path\": \"/spec/containers/0/image\", \"value\":\"new image\"}]'"

#: pkg/kubectl/cmd/options.go:29
msgid ""
"\n"
"\t\t# Print flags inherited by all commands\n"
"\t\tkubectl options"
msgstr ""
"\n"
"\t\t# Stampa i flag ereditati da tutti i comandi\n"
"\t\tkubectl options"

#: pkg/kubectl/cmd/clusterinfo.go:41
msgid ""
"\n"
"\t\t# Print the address of the master and cluster services\n"
"\t\tkubectl cluster-info"
msgstr ""
"\n"
"\t\t# Stampa l'indirizzo dei servizi master e cluster\n"
"\t\tkubectl cluster-info"

#: pkg/kubectl/cmd/version.go:32
msgid ""
"\n"
"\t\t# Print the client and server versions for the current context\n"
"\t\tkubectl version"
msgstr ""
"\n"
"\t\t# Stampa le versioni client e server per il current context\n"
"\t\tkubectl version"

#: pkg/kubectl/cmd/apiversions.go:34
msgid ""
"\n"
"\t\t# Print the supported API versions\n"
"\t\tkubectl api-versions"
msgstr ""
"\n"
"\t\t# Stampa le versioni API supportate\n"
"\t\tkubectl api-versions"

#: pkg/kubectl/cmd/replace.go:50
msgid ""
"\n"
"\t\t# Replace a pod using the data in pod.json.\n"
"\t\tkubectl replace -f ./pod.json\n"
"\n"
"\t\t# Replace a pod based on the JSON passed into stdin.\n"
"\t\tcat pod.json | kubectl replace -f -\n"
"\n"
"\t\t# Update a single-container pod's image version (tag) to v4\n"
"\t\tkubectl get pod mypod -o yaml | sed 's/\\(image: myimage\\):.*$/:v4/' | "
"kubectl replace -f -\n"
"\n"
"\t\t# Force replace, delete and then re-create the resource\n"
"\t\tkubectl replace --force -f ./pod.json"
msgstr ""

#: pkg/kubectl/cmd/logs.go:40
msgid ""
"\n"
"\t\t# Return snapshot logs from pod nginx with only one container\n"
"\t\tkubectl logs nginx\n"
"\n"
"\t\t# Return snapshot logs for the pods defined by label app=nginx\n"
"\t\tkubectl logs -lapp=nginx\n"
"\n"
"\t\t# Return snapshot of previous terminated ruby container logs from pod "
"web-1\n"
"\t\tkubectl logs -p -c ruby web-1\n"
"\n"
"\t\t# Begin streaming the logs of the ruby container in pod web-1\n"
"\t\tkubectl logs -f -c ruby web-1\n"
"\n"
"\t\t# Display only the most recent 20 lines of output in pod nginx\n"
"\t\tkubectl logs --tail=20 nginx\n"
"\n"
"\t\t# Show all logs from pod nginx written in the last hour\n"
"\t\tkubectl logs --since=1h nginx\n"
"\n"
"\t\t# Return snapshot logs from first container of a job named hello\n"
"\t\tkubectl logs job/hello\n"
"\n"
"\t\t# Return snapshot logs from container nginx-1 of a deployment named "
"nginx\n"
"\t\tkubectl logs deployment/nginx -c nginx-1"
msgstr ""

#: pkg/kubectl/cmd/proxy.go:53
msgid ""
"\n"
"\t\t# Run a proxy to kubernetes apiserver on port 8011, serving static "
"content from ./local/www/\n"
"\t\tkubectl proxy --port=8011 --www=./local/www/\n"
"\n"
"\t\t# Run a proxy to kubernetes apiserver on an arbitrary local port.\n"
"\t\t# The chosen port for the server will be output to stdout.\n"
"\t\tkubectl proxy --port=0\n"
"\n"
"\t\t# Run a proxy to kubernetes apiserver, changing the api prefix to k8s-"
"api\n"
"\t\t# This makes e.g. the pods api available at localhost:8001/k8s-api/v1/"
"pods/\n"
"\t\tkubectl proxy --api-prefix=/k8s-api"
msgstr ""

#: pkg/kubectl/cmd/scale.go:43
msgid ""
"\n"
"\t\t# Scale a replicaset named 'foo' to 3.\n"
"\t\tkubectl scale --replicas=3 rs/foo\n"
"\n"
"\t\t# Scale a resource identified by type and name specified in \"foo.yaml\" "
"to 3.\n"
"\t\tkubectl scale --replicas=3 -f foo.yaml\n"
"\n"
"\t\t# If the deployment named mysql's current size is 2, scale mysql to 3.\n"
"\t\tkubectl scale --current-replicas=2 --replicas=3 deployment/mysql\n"
"\n"
"\t\t# Scale multiple replication controllers.\n"
"\t\tkubectl scale --replicas=5 rc/foo rc/bar rc/baz\n"
"\n"
"\t\t# Scale job named 'cron' to 3.\n"
"\t\tkubectl scale --replicas=3 job/cron"
msgstr ""
"\n"
"\t\t# Scala un replicaset denominato 'foo' a 3.\n"
"\t\tkubectl scale --replicas=3 rs/foo\n"
"\n"
"\t\t# Scala una risorsa identificata per tipo e nome specificato in \"foo.yaml"
"\" a 3.\n"
"\t\tkubectl scale --replicas=3 -f foo.yaml\n"
"\n"
"\t\t#  Se la distribuzione corrente di mysql è 2, scala mysql a 3.\n"
"\t\tkubectl scale --current-replicas=2 --replicas=3 deployment/mysql\n"
"\n"
"\t\t# Scalare più controllori di replica.\n"
"\t\tkubectl scale --replicas=5 rc/foo rc/bar rc/baz\n"
"\n"
"\t\t# Scala il lavoro denominato 'cron' a 3.\n"
"\t\tkubectl scale --replicas=3 job/cron"

#: pkg/kubectl/cmd/apply_set_last_applied.go:67
msgid ""
"\n"
"\t\t# Set the last-applied-configuration of a resource to match the contents "
"of a file.\n"
"\t\tkubectl apply set-last-applied -f deploy.yaml\n"
"\n"
"\t\t# Execute set-last-applied against each configuration file in a "
"directory.\n"
"\t\tkubectl apply set-last-applied -f path/\n"
"\n"
"\t\t# Set the last-applied-configuration of a resource to match the contents "
"of a file, will create the annotation if it does not already exist.\n"
"\t\tkubectl apply set-last-applied -f deploy.yaml --create-annotation=true\n"
"\t\t"
msgstr ""
"\n"
"\t\t# Imposta l'ultima-configurazione-applicata di una risorsa che "
"corrisponda al contenuto di un file.\n"
"\t\tkubectl apply set-last-applied -f deploy.yaml\n"
"\n"
"\t\t# Esegue set-last-applied per ogni file di configurazione in una "
"directory.\n"
"\t\tkubectl apply set-last-applied -f path/\n"
"\n"
"\t\t# Imposta la configurazione dell'ultima applicazione di una risorsa che "
"corrisponda al contenuto di un file, creerà l'annotazione se non esiste già.\n"
"\t\tkubectl apply set-last-applied -f deploy.yaml --create-annotation=true\n"
"\t\t"

#: pkg/kubectl/cmd/top_pod.go:61
msgid ""
"\n"
"\t\t# Show metrics for all pods in the default namespace\n"
"\t\tkubectl top pod\n"
"\n"
"\t\t# Show metrics for all pods in the given namespace\n"
"\t\tkubectl top pod --namespace=NAMESPACE\n"
"\n"
"\t\t# Show metrics for a given pod and its containers\n"
"\t\tkubectl top pod POD_NAME --containers\n"
"\n"
"\t\t# Show metrics for the pods defined by label name=myLabel\n"
"\t\tkubectl top pod -l name=myLabel"
msgstr ""

#: pkg/kubectl/cmd/stop.go:40
msgid ""
"\n"
"\t\t# Shut down foo.\n"
"\t\tkubectl stop replicationcontroller foo\n"
"\n"
"\t\t# Stop pods and services with label name=myLabel.\n"
"\t\tkubectl stop pods,services -l name=myLabel\n"
"\n"
"\t\t# Shut down the service defined in service.json\n"
"\t\tkubectl stop -f service.json\n"
"\n"
"\t\t# Shut down all resources in the path/to/resources directory\n"
"\t\tkubectl stop -f path/to/resources"
msgstr ""
"\n"
"\t\t# Spegni foo.\n"
"\t\tkubectl stop replicationcontroller foo\n"
"\n"
"\t\t# Stop di tutti i pod e servizi con label name=myLabel.\n"
"\t\tkubectl stop pods,services -l name=myLabel\n"
"\n"
"\t\t# Spegnere il servizio definito in service.json\n"
"\t\tkubectl stop -f service.json\n"
"\n"
"\t\t# Spegnere tutte le resources in path/to/resources directory\n"
"\t\tkubectl stop -f path/to/resources"

#: pkg/kubectl/cmd/run.go:57
msgid ""
"\n"
"\t\t# Start a single instance of nginx.\n"
"\t\tkubectl run nginx --image=nginx\n"
"\n"
"\t\t# Start a single instance of hazelcast and let the container expose port "
"5701 .\n"
"\t\tkubectl run hazelcast --image=hazelcast --port=5701\n"
"\n"
"\t\t# Start a single instance of hazelcast and set environment variables "
"\"DNS_DOMAIN=cluster\" and \"POD_NAMESPACE=default\" in the container.\n"
"\t\tkubectl run hazelcast --image=hazelcast --env=\"DNS_DOMAIN=cluster\" --"
"env=\"POD_NAMESPACE=default\"\n"
"\n"
"\t\t# Start a replicated instance of nginx.\n"
"\t\tkubectl run nginx --image=nginx --replicas=5\n"
"\n"
"\t\t# Dry run. Print the corresponding API objects without creating them.\n"
"\t\tkubectl run nginx --image=nginx --dry-run\n"
"\n"
"\t\t# Start a single instance of nginx, but overload the spec of the "
"deployment with a partial set of values parsed from JSON.\n"
"\t\tkubectl run nginx --image=nginx --overrides='{ \"apiVersion\": \"v1\", "
"\"spec\": { ... } }'\n"
"\n"
"\t\t# Start a pod of busybox and keep it in the foreground, don't restart it "
"if it exits.\n"
"\t\tkubectl run -i -t busybox --image=busybox --restart=Never\n"
"\n"
"\t\t# Start the nginx container using the default command, but use custom "
"arguments (arg1 .. argN) for that command.\n"
"\t\tkubectl run nginx --image=nginx -- <arg1> <arg2> ... <argN>\n"
"\n"
"\t\t# Start the nginx container using a different command and custom "
"arguments.\n"
"\t\tkubectl run nginx --image=nginx --command -- <cmd> <arg1> ... <argN>\n"
"\n"
"\t\t# Start the perl container to compute π to 2000 places and print it out.\n"
"\t\tkubectl run pi --image=perl --restart=OnFailure -- perl -Mbignum=bpi -wle "
"'print bpi(2000)'\n"
"\n"
"\t\t# Start the cron job to compute π to 2000 places and print it out every 5 "
"minutes.\n"
"\t\tkubectl run pi --schedule=\"0/5 * * * ?\" --image=perl --"
"restart=OnFailure -- perl -Mbignum=bpi -wle 'print bpi(2000)'"
msgstr ""

#: pkg/kubectl/cmd/taint.go:67
msgid ""
"\n"
"\t\t# Update node 'foo' with a taint with key 'dedicated' and value 'special-"
"user' and effect 'NoSchedule'.\n"
"\t\t# If a taint with that key and effect already exists, its value is "
"replaced as specified.\n"
"\t\tkubectl taint nodes foo dedicated=special-user:NoSchedule\n"
"\n"
"\t\t# Remove from node 'foo' the taint with key 'dedicated' and effect "
"'NoSchedule' if one exists.\n"
"\t\tkubectl taint nodes foo dedicated:NoSchedule-\n"
"\n"
"\t\t# Remove from node 'foo' all the taints with key 'dedicated'\n"
"\t\tkubectl taint nodes foo dedicated-"
msgstr ""

#: pkg/kubectl/cmd/label.go:77
msgid ""
"\n"
"\t\t# Update pod 'foo' with the label 'unhealthy' and the value 'true'.\n"
"\t\tkubectl label pods foo unhealthy=true\n"
"\n"
"\t\t# Update pod 'foo' with the label 'status' and the value 'unhealthy', "
"overwriting any existing value.\n"
"\t\tkubectl label --overwrite pods foo status=unhealthy\n"
"\n"
"\t\t# Update all pods in the namespace\n"
"\t\tkubectl label pods --all status=unhealthy\n"
"\n"
"\t\t# Update a pod identified by the type and name in \"pod.json\"\n"
"\t\tkubectl label -f pod.json status=unhealthy\n"
"\n"
"\t\t# Update pod 'foo' only if the resource is unchanged from version 1.\n"
"\t\tkubectl label pods foo status=unhealthy --resource-version=1\n"
"\n"
"\t\t# Update pod 'foo' by removing a label named 'bar' if it exists.\n"
"\t\t# Does not require the --overwrite flag.\n"
"\t\tkubectl label pods foo bar-"
msgstr ""

#: pkg/kubectl/cmd/rollingupdate.go:54
msgid ""
"\n"
"\t\t# Update pods of frontend-v1 using new replication controller data in "
"frontend-v2.json.\n"
"\t\tkubectl rolling-update frontend-v1 -f frontend-v2.json\n"
"\n"
"\t\t# Update pods of frontend-v1 using JSON data passed into stdin.\n"
"\t\tcat frontend-v2.json | kubectl rolling-update frontend-v1 -f -\n"
"\n"
"\t\t# Update the pods of frontend-v1 to frontend-v2 by just changing the "
"image, and switching the\n"
"\t\t# name of the replication controller.\n"
"\t\tkubectl rolling-update frontend-v1 frontend-v2 --image=image:v2\n"
"\n"
"\t\t# Update the pods of frontend by just changing the image, and keeping the "
"old name.\n"
"\t\tkubectl rolling-update frontend --image=image:v2\n"
"\n"
"\t\t# Abort and reverse an existing rollout in progress (from frontend-v1 to "
"frontend-v2).\n"
"\t\tkubectl rolling-update frontend-v1 frontend-v2 --rollback"
msgstr ""

#: pkg/kubectl/cmd/apply_view_last_applied.go:52
msgid ""
"\n"
"\t\t# View the last-applied-configuration annotations by type/name in YAML.\n"
"\t\tkubectl apply view-last-applied deployment/nginx\n"
"\n"
"\t\t# View the last-applied-configuration annotations by file in JSON\n"
"\t\tkubectl apply view-last-applied -f deploy.yaml -o json"
msgstr ""
"\n"
"\t\t# Visualizza le annotazioni dell'ultima-configurazione-applicata per tipo/"
"nome in YAML.\n"
"\t\tkubectl apply view-last-applied deployment/nginx\n"
"\n"
"\t\t# # Visualizza le annotazioni dell'ultima-configurazione-applicata per "
"file in JSON.\n"
"\t\tkubectl apply view-last-applied -f deploy.yaml -o json"

#: pkg/kubectl/cmd/apply.go:75
msgid ""
"\n"
"\t\tApply a configuration to a resource by filename or stdin.\n"
"\t\tThis resource will be created if it doesn't exist yet.\n"
"\t\tTo use 'apply', always create the resource initially with either 'apply' "
"or 'create --save-config'.\n"
"\n"
"\t\tJSON and YAML formats are accepted.\n"
"\n"
"\t\tAlpha Disclaimer: the --prune functionality is not yet complete. Do not "
"use unless you are aware of what the current state is. See https://issues.k8s."
"io/34274."
msgstr ""
"\n"
"\t\tApplicare una configurazione a una risorsa per nomefile o stdin.\n"
"\t\tQuesta risorsa verrà creata se non esiste ancora.\n"
"\t\tPer utilizzare 'apply', creare sempre la risorsa inizialmente con 'apply' "
"o 'create --save-config'.\n"
"\n"
"\t\tSono accettati i formati JSON e YAML.\n"
"\n"
"\t\tDisclaimer Alpha: la funzionalità --prune non è ancora completa. Non "
"utilizzare a meno che non si sia a conoscenza di quale sia lo stato attuale. "
"Vedi https://issues.k8s.io/34274."

#: pkg/kubectl/cmd/convert.go:38
msgid ""
"\n"
"\t\tConvert config files between different API versions. Both YAML\n"
"\t\tand JSON formats are accepted.\n"
"\n"
"\t\tThe command takes filename, directory, or URL as input, and convert it "
"into format\n"
"\t\tof version specified by --output-version flag. If target version is not "
"specified or\n"
"\t\tnot supported, convert to latest version.\n"
"\n"
"\t\tThe default output will be printed to stdout in YAML format. One can use -"
"o option\n"
"\t\tto change to output destination."
msgstr ""

#: pkg/kubectl/cmd/create_clusterrole.go:31
msgid ""
"\n"
"\t\tCreate a ClusterRole."
msgstr ""
"\n"
"\t\n"
"Crea un ClusterRole."

#: pkg/kubectl/cmd/create_clusterrolebinding.go:32
msgid ""
"\n"
"\t\tCreate a ClusterRoleBinding for a particular ClusterRole."
msgstr ""
"\n"
"\t\tCrea un ClusterRoleBinding per un ClusterRole particolare."

#: pkg/kubectl/cmd/create_rolebinding.go:32
msgid ""
"\n"
"\t\tCreate a RoleBinding for a particular Role or ClusterRole."
msgstr ""
"\n"
"\t\tCrea un RoleBinding per un particolare Ruolo o ClusterRole."

#: pkg/kubectl/cmd/create_secret.go:200
msgid ""
"\n"
"\t\tCreate a TLS secret from the given public/private key pair.\n"
"\n"
"\t\tThe public/private key pair must exist before hand. The public key "
"certificate must be .PEM encoded and match the given private key."
msgstr ""
"\n"
"\t\tCrea un TLS secret dalla coppia di chiavi pubblica/privata.\n"
"\n"
"\t\tLa coppia di chiavi pubblica/privata deve esistere prima. Il certificato "
"chiave pubblica deve essere .PEM codificato e corrispondere alla chiave "
"privata data."

#: pkg/kubectl/cmd/create_configmap.go:32
msgid ""
"\n"
"\t\tCreate a configmap based on a file, directory, or specified literal "
"value.\n"
"\n"
"\t\tA single configmap may package one or more key/value pairs.\n"
"\n"
"\t\tWhen creating a configmap based on a file, the key will default to the "
"basename of the file, and the value will\n"
"\t\tdefault to the file content.  If the basename is an invalid key, you may "
"specify an alternate key.\n"
"\n"
"\t\tWhen creating a configmap based on a directory, each file whose basename "
"is a valid key in the directory will be\n"
"\t\tpackaged into the configmap.  Any directory entries except regular files "
"are ignored (e.g. subdirectories,\n"
"\t\tsymlinks, devices, pipes, etc)."
msgstr ""

#: pkg/kubectl/cmd/create_namespace.go:32
msgid ""
"\n"
"\t\tCreate a namespace with the specified name."
msgstr ""
"\n"
"\t\tCreare un namespace con il nome specificato."

#: pkg/kubectl/cmd/create_secret.go:119
msgid ""
"\n"
"\t\tCreate a new secret for use with Docker registries.\n"
"\n"
"\t\tDockercfg secrets are used to authenticate against Docker registries.\n"
"\n"
"\t\tWhen using the Docker command line to push images, you can authenticate "
"to a given registry by running\n"
"\n"
"\t\t    $ docker login DOCKER_REGISTRY_SERVER --username=DOCKER_USER --"
"password=DOCKER_PASSWORD --email=DOCKER_EMAIL'.\n"
"\n"
"    That produces a ~/.dockercfg file that is used by subsequent 'docker "
"push' and 'docker pull' commands to\n"
"\t\tauthenticate to the registry. The email address is optional.\n"
"\n"
"\t\tWhen creating applications, you may have a Docker registry that requires "
"authentication.  In order for the\n"
"\t\tnodes to pull images on your behalf, they have to have the credentials.  "
"You can provide this information\n"
"\t\tby creating a dockercfg secret and attaching it to your service account."
msgstr ""

#: pkg/kubectl/cmd/create_pdb.go:32
msgid ""
"\n"
"\t\tCreate a pod disruption budget with the specified name, selector, and "
"desired minimum available pods"
msgstr ""
"\n"
"\t\tCrea un pod disruption budget con il nome specificato, selector e il "
"numero minimo di pod disponibili"

#: pkg/kubectl/cmd/create.go:42
msgid ""
"\n"
"\t\tCreate a resource by filename or stdin.\n"
"\n"
"\t\tJSON and YAML formats are accepted."
msgstr ""
"\n"
"\t\tCrea una risorsa per nome file o stdin.\n"
"\n"
"\t\tSono accettati i formati JSON e YAML."

#: pkg/kubectl/cmd/create_quota.go:32
msgid ""
"\n"
"\t\tCreate a resourcequota with the specified name, hard limits and optional "
"scopes"
msgstr ""
"\n"
"\t\tCrea una resourcequota con il nome specificato, hard limits e gli scope "
"opzionali"

#: pkg/kubectl/cmd/create_role.go:38
msgid ""
"\n"
"\t\tCreate a role with single rule."
msgstr ""
"\n"
"\t\tCrea un ruolo con una singola regola."

#: pkg/kubectl/cmd/create_secret.go:47
msgid ""
"\n"
"\t\tCreate a secret based on a file, directory, or specified literal value.\n"
"\n"
"\t\tA single secret may package one or more key/value pairs.\n"
"\n"
"\t\tWhen creating a secret based on a file, the key will default to the "
"basename of the file, and the value will\n"
"\t\tdefault to the file content.  If the basename is an invalid key, you may "
"specify an alternate key.\n"
"\n"
"\t\tWhen creating a secret based on a directory, each file whose basename is "
"a valid key in the directory will be\n"
"\t\tpackaged into the secret.  Any directory entries except regular files are "
"ignored (e.g. subdirectories,\n"
"\t\tsymlinks, devices, pipes, etc)."
msgstr ""

#: pkg/kubectl/cmd/create_serviceaccount.go:32
msgid ""
"\n"
"\t\tCreate a service account with the specified name."
msgstr ""
"\n"
"\t\tCreare un service account con il nome specificato."

#: pkg/kubectl/cmd/run.go:52
msgid ""
"\n"
"\t\tCreate and run a particular image, possibly replicated.\n"
"\n"
"\t\tCreates a deployment or job to manage the created container(s)."
msgstr ""
"\n"
"\t\tCrea ed esegue un'immagine particolare, eventualmente replicata.\n"
"\n"
"\t\tCrea un deployment o un job per gestire i container creati."

#: pkg/kubectl/cmd/autoscale.go:34
msgid ""
"\n"
"\t\tCreates an autoscaler that automatically chooses and sets the number of "
"pods that run in a kubernetes cluster.\n"
"\n"
"\t\tLooks up a Deployment, ReplicaSet, or ReplicationController by name and "
"creates an autoscaler that uses the given resource as a reference.\n"
"\t\tAn autoscaler can automatically increase or decrease number of pods "
"deployed within the system as needed."
msgstr ""
"\n"
"\t\tCrea un autoscaler che automaticamente sceglie e imposta il numero di pod "
"che vengono eseguiti in un cluster di kubernets.\n"
"\n"
"\t\tEsegue una ricerca di un Deployment, ReplicaSet o ReplicationController "
"per nome e crea un autoscaler che utilizza la risorsa indicata come "
"riferimento.\n"
"\t\tUn autoscaler può aumentare o diminuire automaticamente il numero di pod "
"distribuiti all'interno del sistema se necessario."

#: pkg/kubectl/cmd/delete.go:40
msgid ""
"\n"
"\t\tDelete resources by filenames, stdin, resources and names, or by "
"resources and label selector.\n"
"\n"
"\t\tJSON and YAML formats are accepted. Only one type of the arguments may be "
"specified: filenames,\n"
"\t\tresources and names, or resources and label selector.\n"
"\n"
"\t\tSome resources, such as pods, support graceful deletion. These resources "
"define a default period\n"
"\t\tbefore they are forcibly terminated (the grace period) but you may "
"override that value with\n"
"\t\tthe --grace-period flag, or pass --now to set a grace-period of 1. "
"Because these resources often\n"
"\t\trepresent entities in the cluster, deletion may not be acknowledged "
"immediately. If the node\n"
"\t\thosting a pod is down or cannot reach the API server, termination may "
"take significantly longer\n"
"\t\tthan the grace period. To force delete a resource,\tyou must pass a grace"
"\tperiod of 0 and specify\n"
"\t\tthe --force flag.\n"
"\n"
"\t\tIMPORTANT: Force deleting pods does not wait for confirmation that the "
"pod's processes have been\n"
"\t\tterminated, which can leave those processes running until the node "
"detects the deletion and\n"
"\t\tcompletes graceful deletion. If your processes use shared storage or talk "
"to a remote API and\n"
"\t\tdepend on the name of the pod to identify themselves, force deleting "
"those pods may result in\n"
"\t\tmultiple processes running on different machines using the same "
"identification which may lead\n"
"\t\tto data corruption or inconsistency. Only force delete pods when you are "
"sure the pod is\n"
"\t\tterminated, or if your application can tolerate multiple copies of the "
"same pod running at once.\n"
"\t\tAlso, if you force delete pods the scheduler may place new pods on those "
"nodes before the node\n"
"\t\thas released those resources and causing those pods to be evicted "
"immediately.\n"
"\n"
"\t\tNote that the delete command does NOT do resource version checks, so if "
"someone\n"
"\t\tsubmits an update to a resource right when you submit a delete, their "
"update\n"
"\t\twill be lost along with the rest of the resource."
msgstr ""

#: pkg/kubectl/cmd/stop.go:31
msgid ""
"\n"
"\t\tDeprecated: Gracefully shut down a resource by name or filename.\n"
"\n"
"\t\tThe stop command is deprecated, all its functionalities are covered by "
"delete command.\n"
"\t\tSee 'kubectl delete --help' for more details.\n"
"\n"
"\t\tAttempts to shut down and delete a resource that supports graceful "
"termination.\n"
"\t\tIf the resource is scalable it will be scaled to 0 before deletion."
msgstr ""

#: pkg/kubectl/cmd/top_node.go:60
msgid ""
"\n"
"\t\tDisplay Resource (CPU/Memory/Storage) usage of nodes.\n"
"\n"
"\t\tThe top-node command allows you to see the resource consumption of nodes."
msgstr ""
"\n"
"\t\tVisualizza l'utilizzo di risorse (CPU/Memoria/Storage) dei nodi.\n"
"\n"
"\t\tIl comando top-node consente di visualizzare il consumo di risorse dei "
"nodi."

#: pkg/kubectl/cmd/top_pod.go:53
msgid ""
"\n"
"\t\tDisplay Resource (CPU/Memory/Storage) usage of pods.\n"
"\n"
"\t\tThe 'top pod' command allows you to see the resource consumption of "
"pods.\n"
"\n"
"\t\tDue to the metrics pipeline delay, they may be unavailable for a few "
"minutes\n"
"\t\tsince pod creation."
msgstr ""
"\n"
"\t\tVisualizza l'utilizzo di risorse (CPU/Memoria/Storage) dei pod.\n"
"\n"
"\t\tIl comando \"top pod\" consente di visualizzare il consumo delle risorse "
"dei pod.\n"
"\n"
"\t\tA causa del ritardo della pipeline metrica, potrebbero non essere "
"disponibili per alcuni minuti\n"
"\t\teal momento della creazione dei pod."

#: pkg/kubectl/cmd/top.go:33
msgid ""
"\n"
"\t\tDisplay Resource (CPU/Memory/Storage) usage.\n"
"\n"
"\t\tThe top command allows you to see the resource consumption for nodes or "
"pods.\n"
"\n"
"\t\tThis command requires Heapster to be correctly configured and working on "
"the server. "
msgstr ""
"\n"
"\t\tVisualizza l'utilizzo di risorse (CPU/Memoria/Storage).\n"
"\n"
"\t\tIl comando top consente di visualizzare il consumo di risorse per nodi o "
"pod.\n"
"\n"
"\t\tQuesto comando richiede che Heapster sia configurato correttamente e che "
"funzioni sul server."

#: pkg/kubectl/cmd/drain.go:140
msgid ""
"\n"
"\t\tDrain node in preparation for maintenance.\n"
"\n"
"\t\tThe given node will be marked unschedulable to prevent new pods from "
"arriving.\n"
"\t\t'drain' evicts the pods if the APIServer supports eviction\n"
"\t\t(http://kubernetes.io/docs/admin/disruptions/). Otherwise, it will use "
"normal DELETE\n"
"\t\tto delete the pods.\n"
"\t\tThe 'drain' evicts or deletes all pods except mirror pods (which cannot "
"be deleted through\n"
"\t\tthe API server).  If there are DaemonSet-managed pods, drain will not "
"proceed\n"
"\t\twithout --ignore-daemonsets, and regardless it will not delete any\n"
"\t\tDaemonSet-managed pods, because those pods would be immediately replaced "
"by the\n"
"\t\tDaemonSet controller, which ignores unschedulable markings.  If there are "
"any\n"
"\t\tpods that are neither mirror pods nor managed by ReplicationController,\n"
"\t\tReplicaSet, DaemonSet, StatefulSet or Job, then drain will not delete any "
"pods unless you\n"
"\t\tuse --force.  --force will also allow deletion to proceed if the managing "
"resource of one\n"
"\t\tor more pods is missing.\n"
"\n"
"\t\t'drain' waits for graceful termination. You should not operate on the "
"machine until\n"
"\t\tthe command completes.\n"
"\n"
"\t\tWhen you are ready to put the node back into service, use kubectl "
"uncordon, which\n"
"\t\twill make the node schedulable again.\n"
"\n"
"\t\t![Workflow](http://kubernetes.io/images/docs/kubectl_drain.svg)"
msgstr ""

#: pkg/kubectl/cmd/edit.go:56
msgid ""
"\n"
"\t\tEdit a resource from the default editor.\n"
"\n"
"\t\tThe edit command allows you to directly edit any API resource you can "
"retrieve via the\n"
"\t\tcommand line tools. It will open the editor defined by your KUBE_EDITOR, "
"or EDITOR\n"
"\t\tenvironment variables, or fall back to 'vi' for Linux or 'notepad' for "
"Windows.\n"
"\t\tYou can edit multiple objects, although changes are applied one at a "
"time. The command\n"
"\t\taccepts filenames as well as command line arguments, although the files "
"you point to must\n"
"\t\tbe previously saved versions of resources.\n"
"\n"
"\t\tEditing is done with the API version used to fetch the resource.\n"
"\t\tTo edit using a specific API version, fully-qualify the resource, "
"version, and group.\n"
"\n"
"\t\tThe default format is YAML. To edit in JSON, specify \"-o json\".\n"
"\n"
"\t\tThe flag --windows-line-endings can be used to force Windows line "
"endings,\n"
"\t\totherwise the default for your operating system will be used.\n"
"\n"
"\t\tIn the event an error occurs while updating, a temporary file will be "
"created on disk\n"
"\t\tthat contains your unapplied changes. The most common error when updating "
"a resource\n"
"\t\tis another editor changing the resource on the server. When this occurs, "
"you will have\n"
"\t\tto apply your changes to the newer version of the resource, or update "
"your temporary\n"
"\t\tsaved copy to include the latest resource version."
msgstr ""

#: pkg/kubectl/cmd/drain.go:115
msgid ""
"\n"
"\t\tMark node as schedulable."
msgstr ""
"\n"
"\t\tContrassegna il nodo come programmabile."

#: pkg/kubectl/cmd/drain.go:90
msgid ""
"\n"
"\t\tMark node as unschedulable."
msgstr ""
"\n"
"\t\tContrassegnare il nodo come non programmabile."

#: pkg/kubectl/cmd/completion.go:47
msgid ""
"\n"
"\t\tOutput shell completion code for the specified shell (bash or zsh).\n"
"\t\tThe shell code must be evalutated to provide interactive\n"
"\t\tcompletion of kubectl commands.  This can be done by sourcing it from\n"
"\t\tthe .bash_profile.\n"
"\n"
"\t\tNote: this requires the bash-completion framework, which is not "
"installed\n"
"\t\tby default on Mac.  This can be installed by using homebrew:\n"
"\n"
"\t\t    $ brew install bash-completion\n"
"\n"
"\t\tOnce installed, bash_completion must be evaluated.  This can be done by "
"adding the\n"
"\t\tfollowing line to the .bash_profile\n"
"\n"
"\t\t    $ source $(brew --prefix)/etc/bash_completion\n"
"\n"
"\t\tNote for zsh users: [1] zsh completions are only supported in versions of "
"zsh >= 5.2"
msgstr ""

#: pkg/kubectl/cmd/rollingupdate.go:45
msgid ""
"\n"
"\t\tPerform a rolling update of the given ReplicationController.\n"
"\n"
"\t\tReplaces the specified replication controller with a new replication "
"controller by updating one pod at a time to use the\n"
"\t\tnew PodTemplate. The new-controller.json must specify the same namespace "
"as the\n"
"\t\texisting replication controller and overwrite at least one (common) label "
"in its replicaSelector.\n"
"\n"
"\t\t![Workflow](http://kubernetes.io/images/docs/kubectl_rollingupdate.svg)"
msgstr ""

#: pkg/kubectl/cmd/replace.go:40
msgid ""
"\n"
"\t\tReplace a resource by filename or stdin.\n"
"\n"
"\t\tJSON and YAML formats are accepted. If replacing an existing resource, "
"the\n"
"\t\tcomplete resource spec must be provided. This can be obtained by\n"
"\n"
"\t\t    $ kubectl get TYPE NAME -o yaml\n"
"\n"
"\t\tPlease refer to the models in https://htmlpreview.github.io/?https://"
"github.com/kubernetes/kubernetes/blob/HEAD/docs/api-reference/v1/definitions."
"html to find if a field is mutable."
msgstr ""

#: pkg/kubectl/cmd/scale.go:34
msgid ""
"\n"
"\t\tSet a new size for a Deployment, ReplicaSet, Replication Controller, or "
"Job.\n"
"\n"
"\t\tScale also allows users to specify one or more preconditions for the "
"scale action.\n"
"\n"
"\t\tIf --current-replicas or --resource-version is specified, it is validated "
"before the\n"
"\t\tscale is attempted, and it is guaranteed that the precondition holds true "
"when the\n"
"\t\tscale is sent to the server."
msgstr ""
"\n"
"\t\tImposta una nuova dimensione per Deployment, ReplicaSet, Replication "
"Controller, o Job.\n"
"\n"
"\t\tScala consente anche agli utenti di specificare una o più condizioni "
"preliminari per l'azione della scala.\n"
"\n"
"\t\tSe --current-replicas o --resource-version sono specificate, viene "
"convalidata prima di\n"
"\t\ttentare scale, ed è garantito che la precondizione vale quando\n"
"\t\tscale viene inviata al server.."

#: pkg/kubectl/cmd/apply_set_last_applied.go:62
msgid ""
"\n"
"\t\tSet the latest last-applied-configuration annotations by setting it to "
"match the contents of a file.\n"
"\t\tThis results in the last-applied-configuration being updated as though "
"'kubectl apply -f <file>' was run,\n"
"\t\twithout updating any other parts of the object."
msgstr ""
"\n"
"\t\tImposta le annotazioni dell'ultima-configurazione-applicata impostandola "
"in modo che corrisponda al contenuto di un file.\n"
"\t\tCiò determina l'aggiornamento dell'ultima-configurazione-applicata come "
"se 'kubectl apply -f <file>' fosse stato eseguito,\n"
"\t\tsenza aggiornare altre parti dell'oggetto."

#: pkg/kubectl/cmd/proxy.go:36
msgid ""
"\n"
"\t\tTo proxy all of the kubernetes api and nothing else, use:\n"
"\n"
"\t\t    $ kubectl proxy --api-prefix=/\n"
"\n"
"\t\tTo proxy only part of the kubernetes api and also some static files:\n"
"\n"
"\t\t    $ kubectl proxy --www=/my/files --www-prefix=/static/ --api-prefix=/"
"api/\n"
"\n"
"\t\tThe above lets you 'curl localhost:8001/api/v1/pods'.\n"
"\n"
"\t\tTo proxy the entire kubernetes api at a different root, use:\n"
"\n"
"\t\t    $ kubectl proxy --api-prefix=/custom/\n"
"\n"
"\t\tThe above lets you 'curl localhost:8001/custom/api/v1/pods'"
msgstr ""
"\n"
"\t\tPer proxy tutti i kubernetes api e nient'altro, utilizzare:\n"
"\n"
"\t\t    $ kubectl proxy --api-prefix=/\n"
"\n"
"\t\tPer proxy solo una parte dei kubernetes api e anche alcuni file static\n"
"\n"
"\t\t    $ kubectl proxy --www=/my/files --www-prefix=/static/ --api-prefix=/"
"api/\n"
"\n"
"\t\tQuanto sopra consente 'curl localhost:8001/api/v1/pods'.\n"
"\n"
"\t\tPer eseguire il proxy tutti i kubernetes api in una radice diversa, "
"utilizzare:\n"
"\n"
"\t\t    $ kubectl proxy --api-prefix=/custom/\n"
"\n"
"\t\tQuanto sopra ti permette 'curl localhost:8001/custom/api/v1/pods'"

#: pkg/kubectl/cmd/patch.go:59
msgid ""
"\n"
"\t\tUpdate field(s) of a resource using strategic merge patch\n"
"\n"
"\t\tJSON and YAML formats are accepted.\n"
"\n"
"\t\tPlease refer to the models in https://htmlpreview.github.io/?https://"
"github.com/kubernetes/kubernetes/blob/HEAD/docs/api-reference/v1/definitions."
"html to find if a field is mutable."
msgstr ""
"\n"
"\t\tAggiorna i campi di una risorsa utilizzando la merge patch strategica\n"
"\n"
"\t\tSono accettati i formati JSON e YAML.\n"
"\n"
"\t\tSi prega di fare riferimento ai modelli in https://htmlpreview.github.io/?"
"https://github.com/kubernetes/kubernetes/blob/HEAD/docs/api-reference/v1/"
"definitions.html per trovare se un campo è mutevole."

#: pkg/kubectl/cmd/label.go:70
#, c-format
msgid ""
"\n"
"\t\tUpdate the labels on a resource.\n"
"\n"
"\t\t* A label must begin with a letter or number, and may contain letters, "
"numbers, hyphens, dots, and underscores, up to %[1]d characters.\n"
"\t\t* If --overwrite is true, then existing labels can be overwritten, "
"otherwise attempting to overwrite a label will result in an error.\n"
"\t\t* If --resource-version is specified, then updates will use this resource "
"version, otherwise the existing resource-version will be used."
msgstr ""
"\n"
"\t\tAggiorna le label di una risorsa.\n"
"\n"
"\t\t* A label must begin with a letter or number, and may contain letters, "
"numbers, hyphens, dots, and underscores, up to %[1]d characters.\n"
"\t\t* If --overwrite is true, then existing labels can be overwritten, "
"otherwise attempting to overwrite a label will result in an error.\n"
"\t\t* If --resource-version is specified, then updates will use this resource "
"version, otherwise the existing resource-version will be used."

#: pkg/kubectl/cmd/taint.go:58
#, c-format
msgid ""
"\n"
"\t\tUpdate the taints on one or more nodes.\n"
"\n"
"\t\t* A taint consists of a key, value, and effect. As an argument here, it "
"is expressed as key=value:effect.\n"
"\t\t* The key must begin with a letter or number, and may contain letters, "
"numbers, hyphens, dots, and underscores, up to %[1]d characters.\n"
"\t\t* The value must begin with a letter or number, and may contain letters, "
"numbers, hyphens, dots, and underscores, up to %[2]d characters.\n"
"\t\t* The effect must be NoSchedule, PreferNoSchedule or NoExecute.\n"
"\t\t* Currently taint can only apply to node."
msgstr ""

#: pkg/kubectl/cmd/apply_view_last_applied.go:46
msgid ""
"\n"
"\t\tView the latest last-applied-configuration annotations by type/name or "
"file.\n"
"\n"
"\t\tThe default output will be printed to stdout in YAML format. One can use -"
"o option\n"
"\t\tto change output format."
msgstr ""
"\n"
"\t\tVisualizza le annotazioni dell'ultima-configurazione-applicata per tipo/"
"nome o file.\n"
"\n"
"\t\tL'output predefinito verrà stampato su stdout nel formato YAML. Si può "
"usare l'opzione -o\n"
"\t\tPer cambiare il formato di output."

#: pkg/kubectl/cmd/cp.go:37
msgid ""
"\n"
"\t    # !!!Important Note!!!\n"
"\t    # Requires that the 'tar' binary is present in your container\n"
"\t    # image.  If 'tar' is not present, 'kubectl cp' will fail.\n"
"\n"
"\t    # Copy /tmp/foo_dir local directory to /tmp/bar_dir in a remote pod in "
"the default namespace\n"
"\t\tkubectl cp /tmp/foo_dir <some-pod>:/tmp/bar_dir\n"
"\n"
"        # Copy /tmp/foo local file to /tmp/bar in a remote pod in a specific "
"container\n"
"\t\tkubectl cp /tmp/foo <some-pod>:/tmp/bar -c <specific-container>\n"
"\n"
"\t\t# Copy /tmp/foo local file to /tmp/bar in a remote pod in namespace <some-"
"namespace>\n"
"\t\tkubectl cp /tmp/foo <some-namespace>/<some-pod>:/tmp/bar\n"
"\n"
"\t\t# Copy /tmp/foo from a remote pod to /tmp/bar locally\n"
"\t\tkubectl cp <some-namespace>/<some-pod>:/tmp/foo /tmp/bar"
msgstr ""

#: pkg/kubectl/cmd/create_secret.go:205
msgid ""
"\n"
"\t  # Create a new TLS secret named tls-secret with the given key pair:\n"
"\t  kubectl create secret tls tls-secret --cert=path/to/tls.cert --key=path/"
"to/tls.key"
msgstr ""
"\n"
"\t  # Crea un nuovo secret TLS denominato tls-secret con la coppia di dati "
"fornita:\n"
"\t  kubectl create secret tls tls-secret --cert=path/to/tls.cert --key=path/"
"to/tls.key"

#: pkg/kubectl/cmd/create_namespace.go:35
msgid ""
"\n"
"\t  # Create a new namespace named my-namespace\n"
"\t  kubectl create namespace my-namespace"
msgstr ""
"\n"
"\t  # Crea un nuovo namespace denominato my-namespace\n"
"\t  kubectl create namespace my-namespace"

#: pkg/kubectl/cmd/create_secret.go:59
msgid ""
"\n"
"\t  # Create a new secret named my-secret with keys for each file in folder "
"bar\n"
"\t  kubectl create secret generic my-secret --from-file=path/to/bar\n"
"\n"
"\t  # Create a new secret named my-secret with specified keys instead of "
"names on disk\n"
"\t  kubectl create secret generic my-secret --from-file=ssh-privatekey=~/.ssh/"
"id_rsa --from-file=ssh-publickey=~/.ssh/id_rsa.pub\n"
"\n"
"\t  # Create a new secret named my-secret with key1=supersecret and "
"key2=topsecret\n"
"\t  kubectl create secret generic my-secret --from-literal=key1=supersecret --"
"from-literal=key2=topsecret"
msgstr ""
"\n"
"\t  # Crea un nuovo secret denominato my-secret con i tasti per ogni file "
"nella barra delle cartelle\n"
"\t  kubectl create secret generic my-secret --from-file=path/to/bar\n"
"\n"
"\t  # Crea un nuovo secret denominato my-secret con le chiavi specificate "
"anziché i nomi sul disco\n"
"\t  kubectl create secret generic my-secret --from-file=ssh-privatekey=~/.ssh/"
"id_rsa --from-file=ssh-publickey=~/.ssh/id_rsa.pub\n"
"\n"
"\t  # Crea un nuovo secret denominato my-secret con key1 = supersecret e key2 "
"= topsecret\n"
"\t  kubectl create secret generic my-secret --from-literal=key1=supersecret --"
"from-literal=key2=topsecret"

#: pkg/kubectl/cmd/create_serviceaccount.go:35
msgid ""
"\n"
"\t  # Create a new service account named my-service-account\n"
"\t  kubectl create serviceaccount my-service-account"
msgstr ""
"\n"
"\t  # Crea un nuovo service account denominato my-service-account\n"
"\t  kubectl create serviceaccount my-service-account"

#: pkg/kubectl/cmd/create_service.go:232
msgid ""
"\n"
"\t# Create a new ExternalName service named my-ns \n"
"\tkubectl create service externalname my-ns --external-name bar.com"
msgstr ""
"\n"
"\t#  Crea un nuovo servizio ExternalName denominato my-ns \n"
"\tkubectl create service externalname my-ns --external-name bar.com"

#: pkg/kubectl/cmd/create_service.go:225
msgid ""
"\n"
"\tCreate an ExternalName service with the specified name.\n"
"\n"
"\tExternalName service references to an external DNS address instead of\n"
"\tonly pods, which will allow application authors to reference services\n"
"\tthat exist off platform, on other clusters, or locally."
msgstr ""
"\n"
"\tCrea un servizio ExternalName con il nome specificato.\n"
"\n"
"\tIl servizio ExternalName fa riferimento a un indirizzo DNS esterno \n"
"\tsolo pod, che permetteranno agli autori delle applicazioni di utilizzare i "
"servizi di riferimento\n"
"\tche esistono fuori dalla piattaforma, su altri cluster, o localmente.."

#: pkg/kubectl/cmd/help.go:30
msgid ""
"\n"
"\tHelp provides help for any command in the application.\n"
"\tSimply type kubectl help [path to command] for full details."
msgstr ""
"\n"
"\tHelp fornisce assistenza per qualsiasi comando nell'applicazione.\n"
"\tBasta digitare kubectl help [path to command] per i dettagli completi."

#: pkg/kubectl/cmd/create_service.go:173
msgid ""
"\n"
"    # Create a new LoadBalancer service named my-lbs\n"
"    kubectl create service loadbalancer my-lbs --tcp=5678:8080"
msgstr ""
"\n"
"    # Creare un nuovo servizio LoadBalancer denominato my-lbs\n"
"    kubectl create service loadbalancer my-lbs --tcp=5678:8080"

#: pkg/kubectl/cmd/create_service.go:53
msgid ""
"\n"
"    # Create a new clusterIP service named my-cs\n"
"    kubectl create service clusterip my-cs --tcp=5678:8080\n"
"\n"
"    # Create a new clusterIP service named my-cs (in headless mode)\n"
"    kubectl create service clusterip my-cs --clusterip=\"None\""
msgstr ""
"\n"
"    # Creare un nuovo servizio clusterIP denominato my-cs\n"
"    kubectl create service clusterip my-cs --tcp=5678:8080\n"
"\n"
"    # Creare un nuovo servizio clusterIP denominato my-cs (in modalità "
"headless)\n"
"    kubectl create service clusterip my-cs --clusterip=\"None\""

#: pkg/kubectl/cmd/create_deployment.go:36
msgid ""
"\n"
"    # Create a new deployment named my-dep that runs the busybox image.\n"
"    kubectl create deployment my-dep --image=busybox"
msgstr ""
"\n"
"    # Crea una nuovo deployment chiamato my-dep che esegue l'immagine "
"busybox.\n"
"    kubectl create deployment my-dep --image=busybox"

#: pkg/kubectl/cmd/create_service.go:116
msgid ""
"\n"
"    # Create a new nodeport service named my-ns\n"
"    kubectl create service nodeport my-ns --tcp=5678:8080"
msgstr ""
"\n"
"    # Creare un nuovo servizio nodeport denominato my-ns\n"
"    kubectl create service nodeport my-ns --tcp=5678:8080"

#: pkg/kubectl/cmd/clusterinfo_dump.go:62
msgid ""
"\n"
"    # Dump current cluster state to stdout\n"
"    kubectl cluster-info dump\n"
"\n"
"    # Dump current cluster state to /path/to/cluster-state\n"
"    kubectl cluster-info dump --output-directory=/path/to/cluster-state\n"
"\n"
"    # Dump all namespaces to stdout\n"
"    kubectl cluster-info dump --all-namespaces\n"
"\n"
"    # Dump a set of namespaces to /path/to/cluster-state\n"
"    kubectl cluster-info dump --namespaces default,kube-system --output-"
"directory=/path/to/cluster-state"
msgstr ""
"\n"
"    # Dump dello stato corrente del cluster verso stdout\n"
"    kubectl cluster-info dump\n"
"\n"
"    # Dump dello stato corrente del cluster verso /path/to/cluster-state\n"
"    kubectl cluster-info dump --output-directory=/path/to/cluster-state\n"
"\n"
"    # Dump di tutti i namespaces verso stdout\n"
"    kubectl cluster-info dump --all-namespaces\n"
"\n"
"    # Dump di un set di namespace verso /path/to/cluster-state\n"
"    kubectl cluster-info dump --namespaces default,kube-system --output-"
"directory=/path/to/cluster-state"

#: pkg/kubectl/cmd/annotate.go:78
msgid ""
"\n"
"    # Update pod 'foo' with the annotation 'description' and the value 'my "
"frontend'.\n"
"    # If the same annotation is set multiple times, only the last value will "
"be applied\n"
"    kubectl annotate pods foo description='my frontend'\n"
"\n"
"    # Update a pod identified by type and name in \"pod.json\"\n"
"    kubectl annotate -f pod.json description='my frontend'\n"
"\n"
"    # Update pod 'foo' with the annotation 'description' and the value 'my "
"frontend running nginx', overwriting any existing value.\n"
"    kubectl annotate --overwrite pods foo description='my frontend running "
"nginx'\n"
"\n"
"    # Update all pods in the namespace\n"
"    kubectl annotate pods --all description='my frontend running nginx'\n"
"\n"
"    # Update pod 'foo' only if the resource is unchanged from version 1.\n"
"    kubectl annotate pods foo description='my frontend running nginx' --"
"resource-version=1\n"
"\n"
"    # Update pod 'foo' by removing an annotation named 'description' if it "
"exists.\n"
"    # Does not require the --overwrite flag.\n"
"    kubectl annotate pods foo description-"
msgstr ""
"\n"
"    # Aggiorna il pod 'foo' con annotazione 'description'e il valore 'my "
"frontend'.\n"
"    # Se la stessa annotazione è impostata più volte, verrà applicato solo "
"l'ultimo valore\n"
"    kubectl annotate pods foo description='my frontend'\n"
"\n"
"    # Aggiorna un pod identificato per tipo e nome in \"pod.json\"\n"
"    kubectl annotate -f pod.json description='my frontend'\n"
"\n"
"    # Aggiorna pod 'foo' con la annotazione 'description' e il valore 'my "
"frontend running nginx', sovrascrivendo qualsiasi valore esistente.\n"
"    kubectl annotate --overwrite pods foo description='my frontend running "
"nginx'\n"
"\n"
"    # Aggiorna tutti i baccelli nel namespace\n"
"    kubectl annotate pods --all description='my frontend running nginx'\n"
"\n"
"    # Aggiorna il pod 'foo' solo se la risorsa è invariata dalla versione 1.\n"
"    kubectl annotate pods foo description='my frontend running nginx' --"
"resource-version=1\n"
"\n"
"    # Aggiorna il pod 'foo' rimuovendo un'annotazione denominata "
"'descrizione' se esiste.\n"
"    # Non richiede flag -overwrite.\n"
"    kubectl annotate pods foo description-"

#: pkg/kubectl/cmd/create_service.go:170
msgid ""
"\n"
"    Create a LoadBalancer service with the specified name."
msgstr ""
"\n"
"    Crea un servizio LoadBalancer con il nome specificato."

#: pkg/kubectl/cmd/create_service.go:50
msgid ""
"\n"
"    Create a clusterIP service with the specified name."
msgstr ""
"\n"
"    Crea un servizio clusterIP con il nome specificato."

#: pkg/kubectl/cmd/create_deployment.go:33
msgid ""
"\n"
"    Create a deployment with the specified name."
msgstr ""
"\n"
"    Creare un deployment con il nome specificato."

#: pkg/kubectl/cmd/create_service.go:113
msgid ""
"\n"
"    Create a nodeport service with the specified name."
msgstr ""
"\n"
"    Creare un servizio nodeport con il nome specificato."

#: pkg/kubectl/cmd/clusterinfo_dump.go:53
msgid ""
"\n"
"    Dumps cluster info out suitable for debugging and diagnosing cluster "
"problems.  By default, dumps everything to\n"
"    stdout. You can optionally specify a directory with --output-directory.  "
"If you specify a directory, kubernetes will\n"
"    build a set of files in that directory.  By default only dumps things in "
"the 'kube-system' namespace, but you can\n"
"    switch to a different namespace with the --namespaces flag, or specify --"
"all-namespaces to dump all namespaces.\n"
"\n"
"    The command also dumps the logs of all of the pods in the cluster, these "
"logs are dumped into different directories\n"
"    based on namespace and pod name."
msgstr ""
"\n"
"    Dump delle informazioni di cluster idonee per il debug e la diagnostica "
"di problemi di cluster. Per impostazione predefinita, tutto\n"
"    verso stdout. È possibile specificare opzionalmente una directory con --"
"output-directory. Se si specifica una directory, kubernetes \n"
"    creearà un insieme di file in quella directory. Per impostazione "
"predefinita, dumps solo i dati del namespace \"kube-system\", ma è\n"
"    possibile passare ad namespace diverso con il flag --namespaces o "
"specificare --all-namespaces per il dump di tutti i namespace.\n"
"\n"
"     Il comando esegue dump anche dei log di tutti i pod del cluster, questi "
"log vengono scaricati in directory differenti\n"
"     basati sul namespace e sul nome del pod."

#: pkg/kubectl/cmd/clusterinfo.go:37
msgid ""
"\n"
"  Display addresses of the master and services with label kubernetes.io/"
"cluster-service=true\n"
"  To further debug and diagnose cluster problems, use 'kubectl cluster-info "
"dump'."
msgstr ""
"\n"
"  Visualizza gli indirizzi del master e dei servizi con label kubernetes.io/"
"cluster-service=true\n"
"  Per ulteriore debug e diagnosticare i problemi di cluster, utilizzare "
"'kubectl cluster-info dump'."

#: pkg/kubectl/cmd/create_quota.go:62
msgid ""
"A comma-delimited set of quota scopes that must all match each object tracked "
"by the quota."
msgstr ""
"Un insieme delimitato-da-virgole di quota scopes che devono corrispondere a "
"ciascun oggetto gestito dalla quota."

#: pkg/kubectl/cmd/create_quota.go:61
msgid ""
"A comma-delimited set of resource=quantity pairs that define a hard limit."
msgstr ""
"Un insieme delimitato-da-virgola di coppie risorsa = quantità che definiscono "
"un hard limit."

#: pkg/kubectl/cmd/create_pdb.go:64
msgid ""
"A label selector to use for this budget. Only equality-based selector "
"requirements are supported."
msgstr ""
"Un label selector da utilizzare per questo budget. Sono supportati solo i "
"selettori equality-based selector."

#: pkg/kubectl/cmd/expose.go:104
msgid ""
"A label selector to use for this service. Only equality-based selector "
"requirements are supported. If empty (the default) infer the selector from "
"the replication controller or replica set.)"
msgstr ""
"Un selettore di label da utilizzare per questo servizio. Sono supportati solo "
"equality-based selector.  Se vuota (default) dedurre il selettore dal "
"replication controller o replica set.)"

#: pkg/kubectl/cmd/run.go:139
msgid "A schedule in the Cron format the job should be run with."
msgstr "Un calendario in formato Cron del lavoro che deve essere eseguito."

#: pkg/kubectl/cmd/expose.go:109
msgid ""
"Additional external IP address (not managed by Kubernetes) to accept for the "
"service. If this IP is routed to a node, the service can be accessed by this "
"IP in addition to its generated service IP."
msgstr ""
"Indirizzo IP esterno aggiuntivo (non gestito da Kubernetes) da accettare per "
"il servizio. Se questo IP viene indirizzato a un nodo, è possibile accedere "
"da questo IP in aggiunta al service IP generato."

#: pkg/kubectl/cmd/expose.go:110 pkg/kubectl/cmd/run.go:122
msgid ""
"An inline JSON override for the generated object. If this is non-empty, it is "
"used to override the generated object. Requires that the object supply a "
"valid apiVersion field."
msgstr ""
"Un override JSON inline per l'oggetto generato. Se questo non è vuoto, viene "
"utilizzato per ignorare l'oggetto generato. Richiede che l'oggetto fornisca "
"un campo valido apiVersion."

#: pkg/kubectl/cmd/run.go:137
msgid ""
"An inline JSON override for the generated service object. If this is non-"
"empty, it is used to override the generated object. Requires that the object "
"supply a valid apiVersion field.  Only used if --expose is true."
msgstr ""
"Un override JSON inline per l'oggetto di servizio generato. Se questo non è "
"vuoto, viene utilizzato per ignorare l'oggetto generato. Richiede che "
"l'oggetto fornisca un campo valido apiVersion. Utilizzato solo se --expose è "
"true."

#: pkg/kubectl/cmd/apply.go:104
msgid "Apply a configuration to a resource by filename or stdin"
msgstr "Applica una configurazione risorsa per nomefile o stdin"

#: pkg/kubectl/cmd/certificates.go:72
msgid "Approve a certificate signing request"
msgstr "Approva una richiesta di firma del certificato"

#: pkg/kubectl/cmd/create_service.go:82
msgid ""
"Assign your own ClusterIP or set to 'None' for a 'headless' service (no "
"loadbalancing)."
msgstr ""
"Assegnare il proprio ClusterIP o impostare su 'None' per un servizio "
"'headless' (nessun bilanciamento del carico)."

#: pkg/kubectl/cmd/attach.go:70
msgid "Attach to a running container"
msgstr "Collega a un container in esecuzione"

#: pkg/kubectl/cmd/autoscale.go:56
msgid "Auto-scale a Deployment, ReplicaSet, or ReplicationController"
msgstr "Auto-scale a Deployment, ReplicaSet, o ReplicationController"

#: pkg/kubectl/cmd/expose.go:113
msgid ""
"ClusterIP to be assigned to the service. Leave empty to auto-allocate, or set "
"to 'None' to create a headless service."
msgstr ""
"ClusterIP da assegnare al servizio. Lasciare vuoto per allocare "
"automaticamente o impostare su 'None' per creare un servizio headless."

#: pkg/kubectl/cmd/create_clusterrolebinding.go:56
msgid "ClusterRole this ClusterRoleBinding should reference"
msgstr "ClusterRole a cui questo ClusterRoleBinding fa riferimento"

#: pkg/kubectl/cmd/create_rolebinding.go:56
msgid "ClusterRole this RoleBinding should reference"
msgstr "ClusterRole a cui questo RoleBinding fa riferimento"

#: pkg/kubectl/cmd/rollingupdate.go:102
msgid ""
"Container name which will have its image upgraded. Only relevant when --image "
"is specified, ignored otherwise. Required when using --image on a multi-"
"container pod"
msgstr ""
"Nome container che avrà la sua immagine aggiornata. Soltanto rilevante quando "
"--image è specificato, altrimenti ignorato. Necessario quando si utilizza --"
"image su un contenitore a più contenitori"

#: pkg/kubectl/cmd/convert.go:68
msgid "Convert config files between different API versions"
msgstr "Convertire i file di configurazione tra diverse versioni APIs"

#: pkg/kubectl/cmd/cp.go:65
msgid "Copy files and directories to and from containers."
msgstr "Copiare file e directory da e verso i container."

#: pkg/kubectl/cmd/create_clusterrolebinding.go:44
msgid "Create a ClusterRoleBinding for a particular ClusterRole"
msgstr "Crea un ClusterRoleBinding per un ClusterRole particolare"

#: pkg/kubectl/cmd/create_service.go:182
msgid "Create a LoadBalancer service."
msgstr "Creare un servizio LoadBalancer."

#: pkg/kubectl/cmd/create_service.go:125
msgid "Create a NodePort service."
msgstr "Crea un servizio NodePort."

#: pkg/kubectl/cmd/create_rolebinding.go:44
msgid "Create a RoleBinding for a particular Role or ClusterRole"
msgstr "Crea un RoleBinding per un particolare Role o ClusterRole"

#: pkg/kubectl/cmd/create_secret.go:214
msgid "Create a TLS secret"
msgstr "Crea un secret TLS"

#: pkg/kubectl/cmd/create_service.go:69
msgid "Create a clusterIP service."
msgstr "Crea un servizio clusterIP."

#: pkg/kubectl/cmd/create_configmap.go:60
msgid "Create a configmap from a local file, directory or literal value"
msgstr ""
"Crea un configmap da un file locale, una directory o un valore letterale"

#: pkg/kubectl/cmd/create_deployment.go:46
msgid "Create a deployment with the specified name."
msgstr "Creare un deployment con il nome specificato."

#: pkg/kubectl/cmd/create_namespace.go:45
msgid "Create a namespace with the specified name"
msgstr "Crea un namespace con il nome specificato"

#: pkg/kubectl/cmd/create_pdb.go:50
msgid "Create a pod disruption budget with the specified name."
msgstr "Crea un pod disruption budget con il nome specificato."

#: pkg/kubectl/cmd/create_quota.go:48
msgid "Create a quota with the specified name."
msgstr "Crea una quota con il nome specificato."

#: pkg/kubectl/cmd/create.go:63
msgid "Create a resource by filename or stdin"
msgstr "Crea una risorsa per nome file o stdin"

#: pkg/kubectl/cmd/create_secret.go:144
msgid "Create a secret for use with a Docker registry"
msgstr "Crea un secret da utilizzare con un registro Docker"

#: pkg/kubectl/cmd/create_secret.go:74
msgid "Create a secret from a local file, directory or literal value"
msgstr "Crea un secret da un file locale, una directory o un valore letterale"

#: pkg/kubectl/cmd/create_secret.go:35
msgid "Create a secret using specified subcommand"
msgstr "Crea un secret utilizzando un subcommand specificato"

#: pkg/kubectl/cmd/create_serviceaccount.go:45
msgid "Create a service account with the specified name"
msgstr "Creare un account di servizio con il nome specificato"

#: pkg/kubectl/cmd/create_service.go:37
msgid "Create a service using specified subcommand."
msgstr "Crea un servizio utilizzando il subcommand specificato."

#: pkg/kubectl/cmd/create_service.go:241
msgid "Create an ExternalName service."
msgstr "Crea un servizio ExternalName."

#: pkg/kubectl/cmd/delete.go:132
msgid ""
"Delete resources by filenames, stdin, resources and names, or by resources "
"and label selector"
msgstr ""
"Elimina risorse selezionate per nomi di file, stdin, risorse e nomi, o per "
"risorsa e selettore di label"

#: pkg/kubectl/cmd/config/delete_cluster.go:39
msgid "Delete the specified cluster from the kubeconfig"
msgstr "Elimina il cluster specificato dal kubeconfig"

#: pkg/kubectl/cmd/config/delete_context.go:39
msgid "Delete the specified context from the kubeconfig"
msgstr "Elimina il context specificato dal kubeconfig"

#: pkg/kubectl/cmd/certificates.go:122
msgid "Deny a certificate signing request"
msgstr "Nega una richiesta di firma del certificato"

#: pkg/kubectl/cmd/stop.go:59
msgid "Deprecated: Gracefully shut down a resource by name or filename"
msgstr "Deprecated: spegne correttamente una risorsa per nome o nome file"

#: pkg/kubectl/cmd/config/get_contexts.go:64
msgid "Describe one or many contexts"
msgstr "Descrive uno o più context"

#: pkg/kubectl/cmd/top_node.go:78
msgid "Display Resource (CPU/Memory) usage of nodes"
msgstr "Visualizza l'utilizzo di risorse (CPU/Memoria) per nodo"

#: pkg/kubectl/cmd/top_pod.go:80
msgid "Display Resource (CPU/Memory) usage of pods"
msgstr "Visualizza l'utilizzo di risorse (CPU/Memoria) per pod."

#: pkg/kubectl/cmd/top.go:44
msgid "Display Resource (CPU/Memory) usage."
msgstr "Visualizza l'utilizzo di risorse (CPU/Memoria)."

#: pkg/kubectl/cmd/clusterinfo.go:51
msgid "Display cluster info"
msgstr "Visualizza informazioni sul cluster"

#: pkg/kubectl/cmd/config/get_clusters.go:41
msgid "Display clusters defined in the kubeconfig"
msgstr "Mostra i cluster definiti nel kubeconfig"

#: pkg/kubectl/cmd/config/view.go:67
msgid "Display merged kubeconfig settings or a specified kubeconfig file"
msgstr ""
"Visualizza le impostazioni merged di kubeconfig o un file kubeconfig "
"specificato"

#: pkg/kubectl/cmd/get.go:111
msgid "Display one or many resources"
msgstr "Visualizza una o più risorse"

#: pkg/kubectl/cmd/config/current_context.go:49
msgid "Displays the current-context"
msgstr "Visualizza il current-context"

#: pkg/kubectl/cmd/explain.go:51
msgid "Documentation of resources"
msgstr "Documentazione delle risorse"

#: pkg/kubectl/cmd/drain.go:178
msgid "Drain node in preparation for maintenance"
msgstr "Drain node in preparazione alla manutenzione"

#: pkg/kubectl/cmd/clusterinfo_dump.go:39
msgid "Dump lots of relevant info for debugging and diagnosis"
msgstr "Dump di un sacco di informazioni pertinenti per il debug e la diagnosi"

#: pkg/kubectl/cmd/edit.go:110
msgid "Edit a resource on the server"
msgstr "Modificare una risorsa sul server"

#: pkg/kubectl/cmd/create_secret.go:160
msgid "Email for Docker registry"
msgstr "Email per il registro Docker"

#: pkg/kubectl/cmd/exec.go:69
msgid "Execute a command in a container"
msgstr "Esegui un comando in un contenitore"

#: pkg/kubectl/cmd/rollingupdate.go:103
msgid ""
"Explicit policy for when to pull container images. Required when --image is "
"same as existing image, ignored otherwise."
msgstr ""
"Politica esplicita per il pull delle immagini container. Richiesto quando --"
"image è uguale all'immagine esistente, altrimenti ignorata."

#: pkg/kubectl/cmd/portforward.go:76
msgid "Forward one or more local ports to a pod"
msgstr "Inoltra una o più porte locali a un pod"

#: pkg/kubectl/cmd/help.go:37
msgid "Help about any command"
msgstr "Aiuto per qualsiasi comando"

#: pkg/kubectl/cmd/expose.go:103
msgid ""
"IP to assign to the Load Balancer. If empty, an ephemeral IP will be created "
"and used (cloud-provider specific)."
msgstr ""
"IP da assegnare al Load Balancer. Se vuota, un IP effimero verrà creato e "
"utilizzato (specifico per provider cloud)."

#: pkg/kubectl/cmd/expose.go:112
msgid ""
"If non-empty, set the session affinity for the service to this; legal values: "
"'None', 'ClientIP'"
msgstr ""
"Se non è vuoto, impostare l'affinità di sessione per il servizio; Valori "
"validi: 'None', 'ClientIP'"

#: pkg/kubectl/cmd/annotate.go:136
msgid ""
"If non-empty, the annotation update will only succeed if this is the current "
"resource-version for the object. Only valid when specifying a single resource."
msgstr ""
"Se non è vuoto, l'aggiornamento delle annotazioni avrà successo solo se "
"questa è la resource-version corrente per l'oggetto. Valido solo quando si "
"specifica una singola risorsa."

#: pkg/kubectl/cmd/label.go:134
msgid ""
"If non-empty, the labels update will only succeed if this is the current "
"resource-version for the object. Only valid when specifying a single resource."
msgstr ""
"Se non vuoto, l'aggiornamento delle label avrà successo solo se questa è la "
"resource-version corrente per l'oggetto. Valido solo quando si specifica una "
"singola risorsa."

#: pkg/kubectl/cmd/rollingupdate.go:99
msgid ""
"Image to use for upgrading the replication controller. Must be distinct from "
"the existing image (either new image or new image tag).  Can not be used with "
"--filename/-f"
msgstr ""
"Immagine da utilizzare per aggiornare il replication controller. Deve essere "
"diversa dall'immagine esistente (nuova immagine o nuovo tag immagine). Non "
"può essere utilizzata con --filename/-f"

#: pkg/kubectl/cmd/rollout/rollout.go:47
msgid "Manage a deployment rollout"
msgstr "Gestisci un deployment rollout"

#: pkg/kubectl/cmd/drain.go:128
msgid "Mark node as schedulable"
msgstr "Contrassegnare il nodo come programmabile"

#: pkg/kubectl/cmd/drain.go:103
msgid "Mark node as unschedulable"
msgstr "Contrassegnare il nodo come non programmabile"

#: pkg/kubectl/cmd/rollout/rollout_pause.go:74
msgid "Mark the provided resource as paused"
msgstr "Imposta la risorsa indicata in pausa"

#: pkg/kubectl/cmd/certificates.go:36
msgid "Modify certificate resources."
msgstr "Modificare le risorse del certificato."

#: pkg/kubectl/cmd/config/config.go:40
msgid "Modify kubeconfig files"
msgstr "Modifica i file kubeconfig"

#: pkg/kubectl/cmd/expose.go:108
msgid ""
"Name or number for the port on the container that the service should direct "
"traffic to. Optional."
msgstr ""
"Nome o numero di porta nel container verso il quale il servizio deve dirigere "
"il traffico. Opzionale."

#: pkg/kubectl/cmd/logs.go:113
msgid ""
"Only return logs after a specific date (RFC3339). Defaults to all logs. Only "
"one of since-time / since may be used."
msgstr ""
"Restituisce solo i log dopo una data specificata (RFC3339). Predefinito tutti "
"i log. È possibile utilizzare solo uno tra data-inizio/a-partire-da."

#: pkg/kubectl/cmd/completion.go:104
msgid "Output shell completion code for the specified shell (bash or zsh)"
msgstr ""
"Codice di completamento shell di output per la shell specificata (bash o zsh)"

#: pkg/kubectl/cmd/convert.go:85
msgid ""
"Output the formatted object with the given group version (for ex: 'extensions/"
"v1beta1').)"
msgstr ""
"Output dell'oggetto formattato con la versione del gruppo fornito (per "
"esempio: 'extensions/v1beta1').)"

#: pkg/kubectl/cmd/create_secret.go:158
msgid "Password for Docker registry authentication"
msgstr "Password per l'autenticazione al registro di Docker"

#: pkg/kubectl/cmd/create_secret.go:226
msgid "Path to PEM encoded public key certificate."
msgstr "Percorso certificato di chiave pubblica codificato PEM."

#: pkg/kubectl/cmd/create_secret.go:227
msgid "Path to private key associated with given certificate."
msgstr "Percorso alla chiave privata associata a un certificato specificato."

#: pkg/kubectl/cmd/rollingupdate.go:85
msgid "Perform a rolling update of the given ReplicationController"
msgstr "Eseguire un rolling update del ReplicationController specificato"

#: pkg/kubectl/cmd/scale.go:83
msgid ""
"Precondition for resource version. Requires that the current resource version "
"match this value in order to scale."
msgstr ""
"Prerequisito per la versione delle risorse. Richiede che la versione corrente "
"delle risorse corrisponda a questo valore per scalare."

#: pkg/kubectl/cmd/version.go:40
msgid "Print the client and server version information"
msgstr "Stampa per client e server le informazioni sulla versione"

#: pkg/kubectl/cmd/options.go:38
msgid "Print the list of flags inherited by all commands"
msgstr "Stampa l'elenco flag ereditati da tutti i comandi"

#: pkg/kubectl/cmd/logs.go:93
msgid "Print the logs for a container in a pod"
msgstr "Stampa i log per container in un pod"

#: pkg/kubectl/cmd/replace.go:71
msgid "Replace a resource by filename or stdin"
msgstr "Sostituire una risorsa per nomefile o stdin"

#: pkg/kubectl/cmd/rollout/rollout_resume.go:72
msgid "Resume a paused resource"
msgstr "Riprendere una risorsa in pausa"

#: pkg/kubectl/cmd/create_rolebinding.go:57
msgid "Role this RoleBinding should reference"
msgstr "Ruolo di riferimento per RoleBinding"

#: pkg/kubectl/cmd/run.go:97
msgid "Run a particular image on the cluster"
msgstr "Esegui una particolare immagine nel cluster"

#: pkg/kubectl/cmd/proxy.go:69
msgid "Run a proxy to the Kubernetes API server"
msgstr "Eseguire un proxy al server Kubernetes API"

#: pkg/kubectl/cmd/create_secret.go:161
msgid "Server location for Docker registry"
msgstr "Posizione del server per il Registro Docker"

#: pkg/kubectl/cmd/scale.go:71
msgid ""
"Set a new size for a Deployment, ReplicaSet, Replication Controller, or Job"
msgstr ""
"Imposta una nuova dimensione per Deployment, ReplicaSet, Replication "
"Controller, o Job"

#: pkg/kubectl/cmd/set/set.go:38
msgid "Set specific features on objects"
msgstr "Imposta caratteristiche specifiche sugli oggetti"

#: pkg/kubectl/cmd/apply_set_last_applied.go:83
msgid ""
"Set the last-applied-configuration annotation on a live object to match the "
"contents of a file."
msgstr ""
"Imposta l'annotazione dell'ultima-configurazione-applicata ad un oggetto live "
"per abbinare il contenuto di un file."

#: pkg/kubectl/cmd/set/set_selector.go:82
msgid "Set the selector on a resource"
msgstr "Impostare il selettore di una risorsa"

#: pkg/kubectl/cmd/config/create_cluster.go:68
msgid "Sets a cluster entry in kubeconfig"
msgstr "Imposta una voce cluster in kubeconfig"

#: pkg/kubectl/cmd/config/create_context.go:58
msgid "Sets a context entry in kubeconfig"
msgstr "Imposta una voce context in kubeconfig"

#: pkg/kubectl/cmd/config/create_authinfo.go:104
msgid "Sets a user entry in kubeconfig"
msgstr "Imposta una voce utente in kubeconfig"

#: pkg/kubectl/cmd/config/set.go:60
msgid "Sets an individual value in a kubeconfig file"
msgstr "Imposta un singolo valore in un file kubeconfig"

#: pkg/kubectl/cmd/config/use_context.go:49
msgid "Sets the current-context in a kubeconfig file"
msgstr "Imposta il current-context in un file kubeconfig"

#: pkg/kubectl/cmd/describe.go:86
msgid "Show details of a specific resource or group of resources"
msgstr "Mostra i dettagli di una specifiche risorsa o un gruppo di risorse"

#: pkg/kubectl/cmd/rollout/rollout_status.go:58
msgid "Show the status of the rollout"
msgstr "Mostra lo stato del rollout"

#: pkg/kubectl/cmd/expose.go:106
msgid "Synonym for --target-port"
msgstr "Sinonimo di --target-port"

#: pkg/kubectl/cmd/expose.go:88
msgid ""
"Take a replication controller, service, deployment or pod and expose it as a "
"new Kubernetes Service"
msgstr ""
"Prende un replication controller, service, deployment o un pod e lo espone "
"come nuovo servizio Kubernetes"

#: pkg/kubectl/cmd/run.go:117
msgid "The image for the container to run."
msgstr "L'immagine per il container da eseguire."

#: pkg/kubectl/cmd/run.go:119
msgid ""
"The image pull policy for the container. If left empty, this value will not "
"be specified by the client and defaulted by the server"
msgstr ""
"La politica di pull dell'immagine per il container. Se lasciato vuoto, questo "
"valore non verrà specificato dal client e predefinito dal server"

#: pkg/kubectl/cmd/rollingupdate.go:101
msgid ""
"The key to use to differentiate between two different controllers, default "
"'deployment'.  Only relevant when --image is specified, ignored otherwise"
msgstr ""
"La chiave da utilizzare per distinguere tra due controller diversi, "
"predefinito \"deployment\". Rilevante soltanto quando --image è specificato, "
"altrimenti ignorato"

#: pkg/kubectl/cmd/create_pdb.go:63
msgid "The minimum number or percentage of available pods this budget requires."
msgstr ""
"Il numero minimo o la percentuale di pod disponibili che questo budget "
"richiede."

#: pkg/kubectl/cmd/expose.go:111
msgid "The name for the newly created object."
msgstr "Il nome dell'oggetto appena creato."

#: pkg/kubectl/cmd/autoscale.go:72
msgid ""
"The name for the newly created object. If not specified, the name of the "
"input resource will be used."
msgstr ""
"Il nome dell'oggetto appena creato. Se non specificato, verrà utilizzato il "
"nome della risorsa di input."

#: pkg/kubectl/cmd/run.go:116
msgid ""
"The name of the API generator to use, see http://kubernetes.io/docs/user-"
"guide/kubectl-conventions/#generators for a list."
msgstr ""
"Il nome del generatore API da utilizzare, si veda http://kubernetes.io/docs/"
"user-guide/kubectl-conventions/#generators per un elenco."

#: pkg/kubectl/cmd/autoscale.go:67
msgid ""
"The name of the API generator to use. Currently there is only 1 generator."
msgstr ""
"Il nome del generatore API da utilizzare. Attualmente c'è solo 1 generatore."

#: pkg/kubectl/cmd/expose.go:99
msgid ""
"The name of the API generator to use. There are 2 generators: 'service/v1' "
"and 'service/v2'. The only difference between them is that service port in v1 "
"is named 'default', while it is left unnamed in v2. Default is 'service/v2'."
msgstr ""
"Il nome del generatore API da utilizzare. Ci sono 2 generatori: 'service/v1' "
"e 'service/v2'. L'unica differenza tra loro è che la porta di servizio in v1 "
"è denominata \"predefinita\", mentre viene lasciata unnamed in v2. Il valore "
"predefinito è 'service/v2'."

#: pkg/kubectl/cmd/run.go:136
msgid ""
"The name of the generator to use for creating a service.  Only used if --"
"expose is true"
msgstr ""
"Il nome del generatore da utilizzare per la creazione di un servizio. "
"Utilizzato solo se --expose è true"

#: pkg/kubectl/cmd/expose.go:100
msgid "The network protocol for the service to be created. Default is 'TCP'."
msgstr ""
"Il protocollo di rete per il servizio da creare. Il valore predefinito è "
"'TCP'."

#: pkg/kubectl/cmd/expose.go:101
msgid ""
"The port that the service should serve on. Copied from the resource being "
"exposed, if unspecified"
msgstr ""
"La porta che il servizio deve servire. Copiato dalla risorsa esposta, se non "
"specificata"

#: pkg/kubectl/cmd/run.go:124
msgid ""
"The port that this container exposes.  If --expose is true, this is also the "
"port used by the service that is created."
msgstr ""
"La porta che questo contenitore espone. Se --expose è true, questa è anche la "
"porta utilizzata dal servizio creato."

#: pkg/kubectl/cmd/run.go:134
msgid ""
"The resource requirement limits for this container.  For example, 'cpu=200m,"
"memory=512Mi'.  Note that server side components may assign limits depending "
"on the server configuration, such as limit ranges."
msgstr ""
"I limiti delle richieste di risorse per questo contenitore.  Ad esempio, "
"'cpu=200m,memory=512Mi'. Si noti che i componenti lato server possono "
"assegnare i limiti a seconda della configurazione del server, ad esempio "
"intervalli di limiti."

#: pkg/kubectl/cmd/run.go:133
msgid ""
"The resource requirement requests for this container.  For example, 'cpu=100m,"
"memory=256Mi'.  Note that server side components may assign requests "
"depending on the server configuration, such as limit ranges."
msgstr ""
"La risorsa necessita di richieste di requisiti per questo pod. Ad esempio, "
"'cpu = 100m, memoria = 256Mi'. Si noti che i componenti lato server possono "
"assegnare i requisiti a seconda della configurazione del server, ad esempio "
"intervalli di limiti."

#: pkg/kubectl/cmd/run.go:131
msgid ""
"The restart policy for this Pod.  Legal values [Always, OnFailure, Never].  "
"If set to 'Always' a deployment is created, if set to 'OnFailure' a job is "
"created, if set to 'Never', a regular pod is created. For the latter two --"
"replicas must be 1.  Default 'Always', for CronJobs `Never`."
msgstr ""
"La politica di riavvio per questo Pod. Valori accettati [Always, OnFailure, "
"Never]. Se impostato su 'Always' viene creato un deployment, se impostato su "
"'OnFailure' viene creato un job, se impostato su 'Never', viene creato un "
"pod. Per questi ultimi due le - repliche devono essere 1. Predefinito "
"'Always', per CronJobs `Never`."

#: pkg/kubectl/cmd/create_secret.go:88
msgid "The type of secret to create"
msgstr "Tipo di segreto da creare"

#: pkg/kubectl/cmd/expose.go:102
msgid ""
"Type for this service: ClusterIP, NodePort, or LoadBalancer. Default is "
"'ClusterIP'."
msgstr ""
"Digitare per questo servizio: ClusterIP, NodePort o LoadBalancer. "
"Ppredefinito è 'ClusterIP'."

#: pkg/kubectl/cmd/rollout/rollout_undo.go:72
msgid "Undo a previous rollout"
msgstr "Annulla un precedente rollout"

#: pkg/kubectl/cmd/config/unset.go:48
msgid "Unsets an individual value in a kubeconfig file"
msgstr "Annulla singolo valore in un file kubeconfig"

#: pkg/kubectl/cmd/patch.go:96
msgid "Update field(s) of a resource using strategic merge patch"
msgstr "Aggiornare campo/i risorsa utilizzando merge patch strategici"

#: pkg/kubectl/cmd/set/set_image.go:95
msgid "Update image of a pod template"
msgstr "Aggiorna immagine di un pod template"

#: pkg/kubectl/cmd/set/set_resources.go:102
msgid "Update resource requests/limits on objects with pod templates"
msgstr "Aggiorna richieste di risorse/limiti sugli oggetti con pod template"

#: pkg/kubectl/cmd/annotate.go:116
msgid "Update the annotations on a resource"
msgstr "Aggiorna annotazioni di risorsa"

#: pkg/kubectl/cmd/label.go:114
msgid "Update the labels on a resource"
msgstr "Aggiorna label di una risorsa"

#: pkg/kubectl/cmd/taint.go:87
msgid "Update the taints on one or more nodes"
msgstr "Aggiorna i taints su uno o più nodi"

#: pkg/kubectl/cmd/create_secret.go:156
msgid "Username for Docker registry authentication"
msgstr "Nome utente per l'autenticazione nel registro Docker"

#: pkg/kubectl/cmd/apply_view_last_applied.go:64
msgid "View latest last-applied-configuration annotations of a resource/object"
msgstr ""
"Visualizza ultime annotazioni dell'ultima configurazione applicata per "
"risorsa/oggetto"

#: pkg/kubectl/cmd/rollout/rollout_history.go:52
msgid "View rollout history"
msgstr "Visualizza la storia del rollout"

#: pkg/kubectl/cmd/clusterinfo_dump.go:46
msgid ""
"Where to output the files.  If empty or '-' uses stdout, otherwise creates a "
"directory hierarchy in that directory"
msgstr ""
"Dove eseguire l'output dei file. Se vuota o '-' utilizza lo stdout, "
"altrimenti crea una gerarchia di directory in quella directory"

#: pkg/kubectl/cmd/run_test.go:85
msgid "dummy restart flag)"
msgstr "flag di riavvio finto)"

#: pkg/kubectl/cmd/create_service.go:254
msgid "external name of service"
msgstr "nome esterno del servizio"

#: pkg/kubectl/cmd/cmd.go:227
msgid "kubectl controls the Kubernetes cluster manager"
msgstr "Kubectl controlla il gestore cluster di Kubernetes"
