// SPDX-License-Identifier: Apache-2.0
// Copyright Authors of Cilium

package main

import (
	"fmt"
	"io"
	"iter"
	"maps"
	"path/filepath"
	"slices"
	"strings"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/btf"
	"golang.org/x/sys/unix"
)

// glob expands the given glob patterns into a sequence of matching file paths.
func glob(patterns []string) iter.Seq[string] {
	var matches []string
	for _, pattern := range patterns {
		m, err := filepath.Glob(pattern)
		if err != nil {
			panic(fmt.Sprintf("invalid glob pattern %q: %v", pattern, err))
		}
		matches = append(matches, m...)
	}

	return slices.Values(matches)
}

// writeCopyrightHeader writes the standard copyright header to the given
// writer.
func writeCopyrightHeader(w io.StringWriter) error {
	_, err := w.WriteString(`// Code generated by dpgen. DO NOT EDIT.

// SPDX-License-Identifier: Apache-2.0
// Copyright Authors of Cilium

`)

	return err
}

// sortedMapSpecs returns the MapSpecs from the given map sorted by their Name
// field.
func sortedMapSpecs(m map[string]*ebpf.MapSpec) iter.Seq[*ebpf.MapSpec] {
	return slices.Values(slices.SortedFunc(maps.Values(m), mapSpecByName))
}

// mapSpecByName compares two ebpf.MapSpec by their Name field. Used for sorting.
func mapSpecByName(a, b *ebpf.MapSpec) int { return strings.Compare(a.Name, b.Name) }

// mapSpecCompatible checks whether two MapSpecs have the same Type, KeySize,
// ValueSize, and MaxEntries. It returns an error if they are not compatible.
func mapSpecCompatible(a, b *ebpf.MapSpec) error {
	if a.Type != b.Type {
		return fmt.Errorf("map %s: type mismatch: %s != %s", a.Name, a.Type, b.Type)
	}

	if a.KeySize != b.KeySize {
		return fmt.Errorf("map %s: key size mismatch: %d != %d", a.Name, a.KeySize, b.KeySize)
	}

	if a.ValueSize != b.ValueSize {
		return fmt.Errorf("map %s: value size mismatch: %d != %d", a.Name, a.ValueSize, b.ValueSize)
	}

	if a.MaxEntries != b.MaxEntries {
		return fmt.Errorf("map %s: max entries mismatch: %d != %d", a.Name, a.MaxEntries, b.MaxEntries)
	}

	return nil
}

// addMapKV adds the BTF types for the map's key and value to the given BTF
// builder.
func addMapKV(bb *btf.Builder, spec *ebpf.MapSpec) error {
	if spec.Key != nil {
		if _, err := bb.Add(spec.Key); err != nil {
			return fmt.Errorf("adding key BTF for map %s: %w", spec.Name, err)
		}
	}

	if spec.Value != nil {
		if _, err := bb.Add(spec.Value); err != nil {
			return fmt.Errorf("adding value BTF for map %s: %w", spec.Name, err)
		}
	}

	return nil
}

// bpfFlagsToString converts BPF map flags into a string representation
// using unix.BPF_F_* constant names where possible.
func bpfFlagsToString(flags uint32) string {
	// The only map flags used by Cilium at time of writing.
	flagNames := map[uint32]string{
		unix.BPF_F_NO_PREALLOC:   "unix.BPF_F_NO_PREALLOC",
		unix.BPF_F_NO_COMMON_LRU: "unix.BPF_F_NO_COMMON_LRU",
		unix.BPF_F_RDONLY_PROG:   "unix.BPF_F_RDONLY_PROG",
	}

	var consts []string
	for i := range 32 {
		if flag := flags & (1 << i); flag != 0 {
			flagStr, ok := flagNames[flag]
			if ok {
				consts = append(consts, flagStr)
			} else {
				// Fallback: print the hex value if we don't have a string translation.
				consts = append(consts, fmt.Sprintf("0x%x", flag))
			}
		}
	}

	if len(consts) == 0 {
		consts = append(consts, "0")
	}

	return strings.Join(consts, " | ")
}
