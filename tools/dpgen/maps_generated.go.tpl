// Code generated by dpgen. DO NOT EDIT.

// SPDX-License-Identifier: Apache-2.0
// Copyright Authors of Cilium

package {{ .Package }}

import (
	"bytes"
	_ "embed"
	"fmt"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/btf"

	"golang.org/x/sys/unix"
)

//go:embed {{ .BTFFile }}
var _mapKVTypes []byte

func LoadMapSpecs() (map[string]*ebpf.MapSpec, error) {
	types, err := btf.LoadSpecFromReader(bytes.NewReader(_mapKVTypes))
	if err != nil {
		return nil, err
	}

	out := make(map[string]*ebpf.MapSpec)
	for _, f := range _outer {
		spec := f(types)
		out[spec.Name] = spec
	}

	return out, nil
}

func anyTypeByName(spec *btf.Spec, name string) btf.Type {
	typ, err := spec.AnyTypeByName(name)
	if err != nil {
		panic(fmt.Sprintf("get type %s by name: %v", name, err))
	}
	return typ
}

// newMapFn is a function that returns a new ebpf.MapSpec.
type newMapFn func(btf *btf.Spec) *ebpf.MapSpec

var _outer []newMapFn = []newMapFn{
{{- range .OuterMaps }}
	new{{ camelCase .Name }}Spec,
{{- end }}
}
{{ range .AllMaps }}
func new{{ camelCase .Name }}Spec(btf *btf.Spec) *ebpf.MapSpec {
	return &ebpf.MapSpec{
		Name:       "{{ .Name }}",
		Type:       ebpf.{{ .Type.String }},
		KeySize:    {{ .KeySize }},
{{- if .Key }}
		Key:        anyTypeByName(btf, "{{ .Key.TypeName }}"),
{{- end }}
		ValueSize:  {{ .ValueSize }},
{{- if .Value }}
		Value:      anyTypeByName(btf, "{{ .Value.TypeName }}"),
{{- end }}
{{- if .InnerMap }}
		InnerMap:   new{{ camelCase .InnerMap.Name }}Spec(btf),
{{- end }}
		MaxEntries: {{ .MaxEntries }},
		Flags:      {{ bpfFlagsToString .Flags }},
		Pinning:    ebpf.{{ .Pinning.String }},
	}
}
{{ end -}}
