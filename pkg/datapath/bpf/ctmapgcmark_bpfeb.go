// Code generated by bpf2go; DO NOT EDIT.
//go:build mips || mips64 || ppc64 || s390x

package bpf

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"
	"structs"

	"github.com/cilium/ebpf"
)

type CTMapGCMarkCtEntry struct {
	_            structs.HostLayout
	Reserved0    uint64
	BackendId    uint64
	Packets      uint64
	Bytes        uint64
	Lifetime     uint32
	_            [2]byte /* unsupported bitfield */
	RevNatIndex  uint16
	Reserved4    uint16
	TxFlagsSeen  uint8
	RxFlagsSeen  uint8
	SrcSecId     uint32
	LastTxReport uint32
	LastRxReport uint32
}

type CTMapGCMarkIpv4CtTuple struct {
	_       structs.HostLayout
	Daddr   uint32
	Saddr   uint32
	Dport   uint16
	Sport   uint16
	Nexthdr uint8
	Flags   uint8
}

type CTMapGCMarkIpv4FragId struct {
	_     structs.HostLayout
	Daddr uint32
	Saddr uint32
	Id    uint16
	Proto uint8
	Pad   uint8
}

type CTMapGCMarkIpv4FragL4ports struct {
	_     structs.HostLayout
	Sport uint16
	Dport uint16
}

type CTMapGCMarkIpv4RevnatEntry struct {
	_           structs.HostLayout
	Address     uint32
	Port        uint16
	RevNatIndex uint16
}

type CTMapGCMarkIpv4RevnatTuple struct {
	_       structs.HostLayout
	Cookie  uint64
	Address uint32
	Port    uint16
	Pad     uint16
}

type CTMapGCMarkIpv6FragId struct {
	_     structs.HostLayout
	Id    uint32
	Proto uint8
	Pad   [3]uint8
	Saddr struct {
		_    structs.HostLayout
		Addr [16]uint8
	}
	Daddr struct {
		_    structs.HostLayout
		Addr [16]uint8
	}
}

type CTMapGCMarkIpv6FragL4ports struct {
	_     structs.HostLayout
	Sport uint16
	Dport uint16
}

type CTMapGCMarkIpv6RevnatEntry struct {
	_       structs.HostLayout
	Address struct {
		_    structs.HostLayout
		Addr [16]uint8
	}
	Port        uint16
	RevNatIndex uint16
}

type CTMapGCMarkIpv6RevnatTuple struct {
	_       structs.HostLayout
	Cookie  uint64
	Address struct {
		_    structs.HostLayout
		Addr [16]uint8
	}
	Port uint16
	Pad  uint16
	_    [4]byte
}

type CTMapGCMarkMetricsKey struct {
	_        structs.HostLayout
	Reason   uint8
	_        [1]byte /* unsupported bitfield */
	Line     uint16
	File     uint8
	Reserved [3]uint8
}

type CTMapGCMarkMetricsValue struct {
	_     structs.HostLayout
	Count uint64
	Bytes uint64
}

type CTMapGCMarkV4addr struct {
	_    structs.HostLayout
	Be32 uint32
}

type CTMapGCMarkV6addr struct {
	_    structs.HostLayout
	Addr [16]uint8
}

// LoadCTMapGCMark returns the embedded CollectionSpec for CTMapGCMark.
func LoadCTMapGCMark() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_CTMapGCMarkBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load CTMapGCMark: %w", err)
	}

	return spec, err
}

// LoadCTMapGCMarkObjects loads CTMapGCMark and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*CTMapGCMarkObjects
//	*CTMapGCMarkPrograms
//	*CTMapGCMarkMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func LoadCTMapGCMarkObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := LoadCTMapGCMark()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// CTMapGCMarkSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type CTMapGCMarkSpecs struct {
	CTMapGCMarkProgramSpecs
	CTMapGCMarkMapSpecs
	CTMapGCMarkVariableSpecs
}

// CTMapGCMarkProgramSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type CTMapGCMarkProgramSpecs struct {
	IterateCt *ebpf.ProgramSpec `ebpf:"iterate_ct"`
}

// CTMapGCMarkMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type CTMapGCMarkMapSpecs struct {
	CiliumIpv4FragDatagrams *ebpf.MapSpec `ebpf:"cilium_ipv4_frag_datagrams"`
	CiliumIpv6FragDatagrams *ebpf.MapSpec `ebpf:"cilium_ipv6_frag_datagrams"`
	CiliumLb4ReverseSk      *ebpf.MapSpec `ebpf:"cilium_lb4_reverse_sk"`
	CiliumLb6ReverseSk      *ebpf.MapSpec `ebpf:"cilium_lb6_reverse_sk"`
	CiliumMetrics           *ebpf.MapSpec `ebpf:"cilium_metrics"`
	CiliumSignals           *ebpf.MapSpec `ebpf:"cilium_signals"`
	Ct4Purge3               *ebpf.MapSpec `ebpf:"ct4_purge3"`
}

// CTMapGCMarkVariableSpecs contains global variables before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type CTMapGCMarkVariableSpecs struct {
	ConfigDirectRoutingDevIfindex    *ebpf.VariableSpec `ebpf:"__config_direct_routing_dev_ifindex"`
	ConfigEnableExtendedIpProtocols  *ebpf.VariableSpec `ebpf:"__config_enable_extended_ip_protocols"`
	ConfigRouterIpv6                 *ebpf.VariableSpec `ebpf:"__config_router_ipv6"`
	ConfigServiceLoopbackIpv4        *ebpf.VariableSpec `ebpf:"__config_service_loopback_ipv4"`
	ConfigServiceLoopbackIpv6        *ebpf.VariableSpec `ebpf:"__config_service_loopback_ipv6"`
	ConfigSupportsFibLookupSkipNeigh *ebpf.VariableSpec `ebpf:"__config_supports_fib_lookup_skip_neigh"`
	ConfigTracePayloadLen            *ebpf.VariableSpec `ebpf:"__config_trace_payload_len"`
	ConfigTracePayloadLenOverlay     *ebpf.VariableSpec `ebpf:"__config_trace_payload_len_overlay"`
}

// CTMapGCMarkObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to LoadCTMapGCMarkObjects or ebpf.CollectionSpec.LoadAndAssign.
type CTMapGCMarkObjects struct {
	CTMapGCMarkPrograms
	CTMapGCMarkMaps
	CTMapGCMarkVariables
}

func (o *CTMapGCMarkObjects) Close() error {
	return _CTMapGCMarkClose(
		&o.CTMapGCMarkPrograms,
		&o.CTMapGCMarkMaps,
	)
}

// CTMapGCMarkMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to LoadCTMapGCMarkObjects or ebpf.CollectionSpec.LoadAndAssign.
type CTMapGCMarkMaps struct {
	CiliumIpv4FragDatagrams *ebpf.Map `ebpf:"cilium_ipv4_frag_datagrams"`
	CiliumIpv6FragDatagrams *ebpf.Map `ebpf:"cilium_ipv6_frag_datagrams"`
	CiliumLb4ReverseSk      *ebpf.Map `ebpf:"cilium_lb4_reverse_sk"`
	CiliumLb6ReverseSk      *ebpf.Map `ebpf:"cilium_lb6_reverse_sk"`
	CiliumMetrics           *ebpf.Map `ebpf:"cilium_metrics"`
	CiliumSignals           *ebpf.Map `ebpf:"cilium_signals"`
	Ct4Purge3               *ebpf.Map `ebpf:"ct4_purge3"`
}

func (m *CTMapGCMarkMaps) Close() error {
	return _CTMapGCMarkClose(
		m.CiliumIpv4FragDatagrams,
		m.CiliumIpv6FragDatagrams,
		m.CiliumLb4ReverseSk,
		m.CiliumLb6ReverseSk,
		m.CiliumMetrics,
		m.CiliumSignals,
		m.Ct4Purge3,
	)
}

// CTMapGCMarkVariables contains all global variables after they have been loaded into the kernel.
//
// It can be passed to LoadCTMapGCMarkObjects or ebpf.CollectionSpec.LoadAndAssign.
type CTMapGCMarkVariables struct {
	ConfigDirectRoutingDevIfindex    *ebpf.Variable `ebpf:"__config_direct_routing_dev_ifindex"`
	ConfigEnableExtendedIpProtocols  *ebpf.Variable `ebpf:"__config_enable_extended_ip_protocols"`
	ConfigRouterIpv6                 *ebpf.Variable `ebpf:"__config_router_ipv6"`
	ConfigServiceLoopbackIpv4        *ebpf.Variable `ebpf:"__config_service_loopback_ipv4"`
	ConfigServiceLoopbackIpv6        *ebpf.Variable `ebpf:"__config_service_loopback_ipv6"`
	ConfigSupportsFibLookupSkipNeigh *ebpf.Variable `ebpf:"__config_supports_fib_lookup_skip_neigh"`
	ConfigTracePayloadLen            *ebpf.Variable `ebpf:"__config_trace_payload_len"`
	ConfigTracePayloadLenOverlay     *ebpf.Variable `ebpf:"__config_trace_payload_len_overlay"`
}

// CTMapGCMarkPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to LoadCTMapGCMarkObjects or ebpf.CollectionSpec.LoadAndAssign.
type CTMapGCMarkPrograms struct {
	IterateCt *ebpf.Program `ebpf:"iterate_ct"`
}

func (p *CTMapGCMarkPrograms) Close() error {
	return _CTMapGCMarkClose(
		p.IterateCt,
	)
}

func _CTMapGCMarkClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed ctmapgcmark_bpfeb.o
var _CTMapGCMarkBytes []byte
