// SPDX-License-Identifier: Apache-2.0
// Copyright Authors of Cilium

package config

import (
	"errors"
	"fmt"
	"reflect"
)

var errDuplicateVariable = fmt.Errorf("duplicate variable")

// Map converts an instance of a Go struct generated by [varsToStruct], or a
// slice of such structs, into a map of configuration values to be passed to
// LoadCollection.
//
// Only struct members with a `config` tag are included. The tag value is used
// as the key in the map, and the map value is the runtime value of the member.
//
// Duplicate variables (e.g. by specifying the same object twice) are not
// allowed.
func Map(obj any) (map[string]any, error) {
	if reflect.ValueOf(obj).Kind() == reflect.Slice {
		return sliceOfStructsToMap(obj)
	}

	return structToMap(obj)
}

func sliceOfStructsToMap(objs any) (map[string]any, error) {
	result := make(map[string]any)
	val := reflect.ValueOf(objs)

	if val.Kind() != reflect.Slice {
		return nil, fmt.Errorf("expected slice, got %T", objs)
	}

	for i := 0; i < val.Len(); i++ {
		elem := val.Index(i).Interface()
		m, err := structToMap(elem)
		if err != nil {
			return nil, fmt.Errorf("config object %T(%d): %w", elem, i, err)
		}

		for name, v := range m {
			if _, ok := result[name]; ok {
				return nil, fmt.Errorf("variable %s (in %T) specified more than once: %w", name, elem, errDuplicateVariable)
			}
			result[name] = v
		}
	}

	return result, nil
}

func structToMap(obj any) (map[string]any, error) {
	typ := reflect.TypeOf(obj)
	val := reflect.ValueOf(obj)

	if typ == nil {
		return nil, errors.New("obj is nil")
	}

	if typ.Kind() == reflect.Pointer {
		if val.IsNil() {
			return nil, fmt.Errorf("obj is nil pointer to %T", obj)
		}
		val = val.Elem()
	}

	fields, err := structFields(val, TagName, nil)
	if err != nil {
		return nil, err
	}

	vars := make(map[string]any, len(fields))
	for _, field := range fields {
		tag := field.Tag.Get(TagName)
		if tag == "" {
			return nil, fmt.Errorf("field %s has no tag", field.Name)
		}

		if vars[tag] != nil {
			return nil, fmt.Errorf("tag %s on field %s occurs multiple times in object", tag, field.Name)
		}

		vars[tag] = field.value.Interface()
	}

	return vars, nil
}

// structField represents a struct field containing a struct tag.
type structField struct {
	reflect.StructField
	value reflect.Value
}

// structFields recursively gathers all fields of a struct and its nested
// structs that are tagged with the given tag.
func structFields(structVal reflect.Value, tag string, visited map[reflect.Type]bool) ([]structField, error) {
	if visited == nil {
		visited = make(map[reflect.Type]bool)
	}

	structType := structVal.Type()
	if structType.Kind() != reflect.Struct {
		return nil, fmt.Errorf("%s is not a struct", structType)
	}

	if visited[structType] {
		return nil, fmt.Errorf("recursion on type %s", structType)
	}

	fields := make([]structField, 0, structType.NumField())
	for i := range structType.NumField() {
		field := structField{structType.Field(i), structVal.Field(i)}

		// If the field is tagged, gather it and move on.
		name := field.Tag.Get(tag)
		if name != "" {
			fields = append(fields, field)
			continue
		}

		// If the field does not have an ebpf tag, but is a struct or a pointer
		// to a struct, attempt to gather its fields as well.
		var v reflect.Value
		switch field.Type.Kind() {
		case reflect.Ptr:
			if field.Type.Elem().Kind() != reflect.Struct {
				continue
			}

			if field.value.IsNil() {
				return nil, fmt.Errorf("nil pointer to %s", structType)
			}

			// Obtain the destination type of the pointer.
			v = field.value.Elem()

		case reflect.Struct:
			// Reference the value's type directly.
			v = field.value

		default:
			continue
		}

		inner, err := structFields(v, tag, visited)
		if err != nil {
			return nil, fmt.Errorf("field %s: %w", field.Name, err)
		}

		fields = append(fields, inner...)
	}

	return fields, nil
}
