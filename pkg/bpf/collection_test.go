// SPDX-License-Identifier: Apache-2.0
// Copyright Authors of Cilium

package bpf

import (
	"testing"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/asm"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/cilium/cilium/pkg/testutils"
)

// Generate a program of sufficient size whose verifier log does not fit into a
// 128-byte buffer. Load the program while requesting a verifier log using an
// undersized buffer and expect the load to be successful.
func TestLoadCollectionResizeLogBuffer(t *testing.T) {
	testutils.PrivilegedTest(t)

	num := 32
	insns := make(asm.Instructions, 0, num)
	for range num - 1 {
		insns = append(insns, asm.Mov.Reg(asm.R0, asm.R1))
	}
	insns = append(insns, asm.Return())

	spec := &ebpf.CollectionSpec{
		Programs: map[string]*ebpf.ProgramSpec{
			"test": {
				Type:         ebpf.SocketFilter,
				License:      "MIT",
				Instructions: insns,
			},
		},
	}

	coll, _, err := LoadCollection(spec, &CollectionOptions{
		CollectionOptions: ebpf.CollectionOptions{
			Programs: ebpf.ProgramOptions{
				// Request instruction-level verifier state to ensure sufficient
				// output is generated by the verifier. For example, one instruction:
				// 0: (bf) r0 = r1		; R0_w=ctx(off=0,imm=0) R1=ctx(off=0,imm=0)
				LogLevel: ebpf.LogLevelInstruction,
			},
		},
	})
	if err != nil {
		t.Fatal("Error loading collection:", err)
	}

	// Expect successful program creation, with a complementary verifier log.
	log := coll.Programs["test"].VerifierLog
	if len(log) == 0 {
		t.Fatal("Received empty verifier log")
	}
}

func TestRemoveUnreachableTailcalls(t *testing.T) {
	// Use upstream LoadCollectionSpec to defer the call to
	// removeUnreachableTailcalls.
	spec, err := ebpf.LoadCollectionSpec("testdata/unreachable-tailcall.o")
	if err != nil {
		t.Fatal(err)
	}

	assert.Contains(t, spec.Programs, "cil_entry")
	assert.Contains(t, spec.Programs, "a")
	assert.Contains(t, spec.Programs, "b")
	assert.Contains(t, spec.Programs, "c")
	assert.Contains(t, spec.Programs, "d")
	assert.Contains(t, spec.Programs, "e")

	if err := removeUnreachableTailcalls(spec); err != nil {
		t.Fatal(err)
	}

	assert.Contains(t, spec.Programs, "cil_entry")
	assert.Contains(t, spec.Programs, "a")
	assert.Contains(t, spec.Programs, "b")
	assert.Contains(t, spec.Programs, "c")
	assert.NotContains(t, spec.Programs, "d")
	assert.NotContains(t, spec.Programs, "e")
}

func TestUpgradeMap(t *testing.T) {
	testutils.PrivilegedTest(t)

	temp := testutils.TempBPFFS(t)

	// Pin a dummy map in order to test upgrading it.
	_, err := ebpf.NewMapWithOptions(&ebpf.MapSpec{
		Name:       "upgraded_map",
		Type:       ebpf.Array,
		KeySize:    4,
		ValueSize:  4,
		MaxEntries: 1,
		Pinning:    ebpf.PinByName,
	}, ebpf.MapOptions{PinPath: temp})
	require.NoError(t, err)

	spec, err := LoadCollectionSpec("testdata/upgrade-map.o")
	require.NoError(t, err)

	// Use LoadAndAssign to make sure commit works through map upgrades. This is a
	// regression test, as [ebpf.Collection.Assign] deletes Map objects from the
	// Collection when successful, causing commit() to fail afterwards if it uses
	// stringly references to Collection.Maps entries.
	obj := struct {
		UpgradedMap *ebpf.Map `ebpf:"upgraded_map"`
	}{}
	commit, err := LoadAndAssign(&obj, spec, &CollectionOptions{
		CollectionOptions: ebpf.CollectionOptions{
			Maps: ebpf.MapOptions{PinPath: temp},
		},
	})
	require.NoError(t, err)
	require.NoError(t, commit())

	// Check if the map was upgraded correctly.
	assert.True(t, obj.UpgradedMap.IsPinned())
	assert.EqualValues(t, 10, obj.UpgradedMap.MaxEntries())
}
