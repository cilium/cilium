// Copyright 2017-2020 Authors of Cilium
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package client

import (
	"context"
	goerrors "errors"
	"fmt"
	"time"

	k8sconstv2 "github.com/cilium/cilium/pkg/k8s/apis/cilium.io/v2"
	"github.com/cilium/cilium/pkg/logging"
	"github.com/cilium/cilium/pkg/logging/logfields"
	"github.com/cilium/cilium/pkg/option"
	"github.com/cilium/cilium/pkg/versioncheck"

	"golang.org/x/sync/errgroup"
	apiextensionsv1beta1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1beta1"
	apiextensionsclient "k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/wait"
	"sigs.k8s.io/yaml"
)

const (
	// subsysK8s is the value for logfields.LogSubsys
	subsysK8s = "k8s"

	// CNPCRDName is the full name of the CNP CRD.
	CNPCRDName = k8sconstv2.CNPKindDefinition + "/" + k8sconstv2.CustomResourceDefinitionVersion

	// CCNPCRDName is the full name of the CCNP CRD.
	CCNPCRDName = k8sconstv2.CCNPKindDefinition + "/" + k8sconstv2.CustomResourceDefinitionVersion

	// CEPCRDName is the full name of the CEP CRD.
	CEPCRDName = k8sconstv2.CEPKindDefinition + "/" + k8sconstv2.CustomResourceDefinitionVersion
)

var (
	// log is the k8s package logger object.
	log = logging.DefaultLogger.WithField(logfields.LogSubsys, subsysK8s)

	comparableCRDSchemaVersion = versioncheck.MustVersion(k8sconstv2.CustomResourceDefinitionSchemaVersion)
)

// CreateCustomResourceDefinitions creates our CRD objects in the Kubernetes
// cluster.
func CreateCustomResourceDefinitions(clientset apiextensionsclient.Interface) error {
	g, _ := errgroup.WithContext(context.Background())

	g.Go(func() error {
		return createCNPCRD(clientset)
	})

	g.Go(func() error {
		return createCCNPCRD(clientset)
	})

	g.Go(func() error {
		return createCEPCRD(clientset)
	})

	g.Go(func() error {
		return createNodeCRD(clientset)
	})

	if option.Config.IdentityAllocationMode == option.IdentityAllocationModeCRD {
		g.Go(func() error {
			return createIdentityCRD(clientset)
		})
	}

	return g.Wait()
}

// GetPregeneratedCRD returns the pregenerated CRD based on the requested CRD
// name. The pregenerated CRDs are generated by the controller-gen tool and
// serialized into binary form by go-bindata. This function retrieves CRDs from
// the binary form.
func GetPregeneratedCRD(crdName string) apiextensionsv1beta1.CustomResourceDefinition {
	var (
		err      error
		crdBytes []byte
	)

	scopedLog := log.WithField("crdName", crdName)

	switch crdName {
	case CNPCRDName:
		crdBytes, err = examplesCrdsCiliumnetworkpoliciesYamlBytes()
	case CCNPCRDName:
		crdBytes, err = examplesCrdsCiliumclusterwidenetworkpoliciesYamlBytes()
	case CEPCRDName:
		crdBytes, err = examplesCrdsCiliumendpointsYamlBytes()
	default:
		scopedLog.Fatal("Pregenerated CRD does not exist")
	}

	if err != nil {
		scopedLog.WithError(err).Fatal("Error retrieving pregenerated CRD")
	}

	ciliumCRD := apiextensionsv1beta1.CustomResourceDefinition{}
	err = yaml.Unmarshal(crdBytes, &ciliumCRD)
	if err != nil {
		scopedLog.WithError(err).Fatal("Error unmarshalling pregenerated CRD")
	}

	return ciliumCRD
}

// createCNPCRD creates and updates the CiliumNetworkPolicies CRD. It should be called
// on agent startup but is idempotent and safe to call again.
func createCNPCRD(clientset apiextensionsclient.Interface) error {
	ciliumCRD := GetPregeneratedCRD(CNPCRDName)

	res := &apiextensionsv1beta1.CustomResourceDefinition{
		ObjectMeta: metav1.ObjectMeta{
			Name: k8sconstv2.CNPName,
			Labels: map[string]string{
				k8sconstv2.CustomResourceDefinitionSchemaVersionKey: k8sconstv2.CustomResourceDefinitionSchemaVersion,
			},
		},
		Spec: apiextensionsv1beta1.CustomResourceDefinitionSpec{
			Group:   k8sconstv2.CustomResourceDefinitionGroup,
			Version: k8sconstv2.CustomResourceDefinitionVersion,
			Names: apiextensionsv1beta1.CustomResourceDefinitionNames{
				Kind:       ciliumCRD.Spec.Names.Kind,
				Plural:     ciliumCRD.Spec.Names.Plural,
				ShortNames: ciliumCRD.Spec.Names.ShortNames,
				Singular:   ciliumCRD.Spec.Names.Singular,
			},
			AdditionalPrinterColumns: ciliumCRD.Spec.AdditionalPrinterColumns,
			Subresources:             ciliumCRD.Spec.Subresources,
			Scope:                    ciliumCRD.Spec.Scope,
			Validation:               ciliumCRD.Spec.Validation,
		},
	}

	return createUpdateCRD(clientset, CNPCRDName, res)
}

// createCCNPCRD creates and updates the CiliumClusterwideNetworkPolicy CRD. It
// should be called on agent startup but is idempotent and safe to call again.
func createCCNPCRD(clientset apiextensionsclient.Interface) error {
	ciliumCRD := GetPregeneratedCRD(CCNPCRDName)

	res := &apiextensionsv1beta1.CustomResourceDefinition{
		ObjectMeta: metav1.ObjectMeta{
			Name: k8sconstv2.CCNPName,
			Labels: map[string]string{
				k8sconstv2.CustomResourceDefinitionSchemaVersionKey: k8sconstv2.CustomResourceDefinitionSchemaVersion,
			},
		},
		Spec: apiextensionsv1beta1.CustomResourceDefinitionSpec{
			Group:   k8sconstv2.CustomResourceDefinitionGroup,
			Version: k8sconstv2.CustomResourceDefinitionVersion,
			Names: apiextensionsv1beta1.CustomResourceDefinitionNames{
				Kind:       ciliumCRD.Spec.Names.Kind,
				Plural:     ciliumCRD.Spec.Names.Plural,
				ShortNames: ciliumCRD.Spec.Names.ShortNames,
				Singular:   ciliumCRD.Spec.Names.Singular,
			},
			Subresources: ciliumCRD.Spec.Subresources,
			Scope:        ciliumCRD.Spec.Scope,
			Validation:   ciliumCRD.Spec.Validation,
		},
	}

	return createUpdateCRD(clientset, CCNPCRDName, res)
}

// createCEPCRD creates and updates the CiliumEndpoint CRD. It should be called
// on agent startup but is idempotent and safe to call again.
func createCEPCRD(clientset apiextensionsclient.Interface) error {
	ciliumCRD := GetPregeneratedCRD(CEPCRDName)

	res := &apiextensionsv1beta1.CustomResourceDefinition{
		ObjectMeta: metav1.ObjectMeta{
			Name: k8sconstv2.CEPName,
			Labels: map[string]string{
				k8sconstv2.CustomResourceDefinitionSchemaVersionKey: k8sconstv2.CustomResourceDefinitionSchemaVersion,
			},
		},
		Spec: apiextensionsv1beta1.CustomResourceDefinitionSpec{
			Group:   k8sconstv2.CustomResourceDefinitionGroup,
			Version: k8sconstv2.CustomResourceDefinitionVersion,
			Names: apiextensionsv1beta1.CustomResourceDefinitionNames{
				Plural:     ciliumCRD.Spec.Names.Plural,
				Singular:   ciliumCRD.Spec.Names.Singular,
				ShortNames: ciliumCRD.Spec.Names.ShortNames,
				Kind:       ciliumCRD.Spec.Names.Kind,
			},
			AdditionalPrinterColumns: ciliumCRD.Spec.AdditionalPrinterColumns,
			Subresources:             ciliumCRD.Spec.Subresources,
			Scope:                    ciliumCRD.Spec.Scope,
			Validation:               ciliumCRD.Spec.Validation,
		},
	}

	return createUpdateCRD(clientset, CEPCRDName, res)
}

// createNodeCRD creates and updates the CiliumNode CRD. It should be called on
// agent startup but is idempotent and safe to call again.
func createNodeCRD(clientset apiextensionsclient.Interface) error {
	var (
		// CustomResourceDefinitionShortNames are the abbreviated names to refer to this CRD's instances
		CustomResourceDefinitionShortNames = []string{"cn", "ciliumn"}
	)

	res := &apiextensionsv1beta1.CustomResourceDefinition{
		ObjectMeta: metav1.ObjectMeta{
			Name: k8sconstv2.CNName,
		},
		Spec: apiextensionsv1beta1.CustomResourceDefinitionSpec{
			Group:   k8sconstv2.CustomResourceDefinitionGroup,
			Version: k8sconstv2.CustomResourceDefinitionVersion,
			Names: apiextensionsv1beta1.CustomResourceDefinitionNames{
				Plural:     k8sconstv2.CNPluralName,
				Singular:   k8sconstv2.CNSingularName,
				ShortNames: CustomResourceDefinitionShortNames,
				Kind:       k8sconstv2.CNKindDefinition,
			},
			Subresources: &apiextensionsv1beta1.CustomResourceSubresources{
				Status: &apiextensionsv1beta1.CustomResourceSubresourceStatus{},
			},
			Scope: apiextensionsv1beta1.ClusterScoped,
			Validation: &apiextensionsv1beta1.CustomResourceValidation{
				OpenAPIV3Schema: &apiextensionsv1beta1.JSONSchemaProps{
					Description: "CiliumNode represents the k8s node from the view of Cilium.",
					Properties: map[string]apiextensionsv1beta1.JSONSchemaProps{
						"spec": {
							Properties: map[string]apiextensionsv1beta1.JSONSchemaProps{
								"azure": {
									Type: "object",
									Properties: map[string]apiextensionsv1beta1.JSONSchemaProps{
										"instance-id": {
											Type:        "string",
											Description: "instance-id is the Azure specific identifier of the node",
										},
										"interface-name": {
											Type:        "string",
											Description: "interface-name represents the name of the interface on which additional IP addreses will be allocated",
										},
									},
								},
								"eni": {
									Type: "object",
									Properties: map[string]apiextensionsv1beta1.JSONSchemaProps{
										"min-allocate": {
											Type:        "integer",
											Minimum:     getFloat64(0),
											Description: "min-allocate is the minimum number of IPs that will be allocated before the cilium-agent will write the CNI config.",
										},
										"max-allocate": {
											Type:        "integer",
											Minimum:     getFloat64(0),
											Description: "max-allocate is the maximum number of IPs that will be allocated to the node.",
										},
										"pre-allocate": {
											Type:        "integer",
											Minimum:     getFloat64(0),
											Description: "pre-allocate defines the number of IP addresses that must be available for allocation at all times.",
										},
										"max-above-watermark": {
											Type:        "integer",
											Minimum:     getFloat64(0),
											Description: "max-above-watermark defines the number of addresses to allocate beyond what is needed to reach the PreAllocate watermark.",
										},
										"first-interface-index": {
											Type:        "integer",
											Description: "first-interface-index represents the start EC2 interface index at which the ENI will be attached at.",
											Minimum:     getFloat64(0),
										},
										"security-groups": {
											Type:        "array",
											Description: "security-groups represents the list of AWS EC2 security groups which will be attached to the ENI.",
											Items: &apiextensionsv1beta1.JSONSchemaPropsOrArray{
												Schema: &apiextensionsv1beta1.JSONSchemaProps{
													Type: "string",
												},
											},
										},
										"security-group-tags": {
											Type:        "object",
											Description: "security-group-tags represents a filter to narrow down the security group ids which will be attached on the allocated ENI",
										},
										"subnet-tags": {
											Type:        "object",
											Description: "subnet-tags represents a filter to narrow down the available subnets in which the ENI will be allocated",
										},
										"vpc-id": {
											Type:        "string",
											Description: "vpc-id represents the AWS EC2 vpc-id in which the ENI will be allocated.",
										},
										"availability-zone": {
											Type:        "string",
											Description: "availability-zone represents the AWS availability-zone in which the ENI will be allocated.",
										},
										"delete-on-termination": {
											Type:        "boolean",
											Description: "delete-on-termination marks the ENI to be deleted when the EC2 instance is terminated.",
										},
									},
								},
								"ipam": {
									Type: "object",
									Properties: map[string]apiextensionsv1beta1.JSONSchemaProps{
										"min-allocate": {
											Type:        "integer",
											Minimum:     getFloat64(0),
											Description: "min-allocate is the minimum number of IPs that will be allocated before the cilium-agent will write the CNI config.",
										},
										"max-allocate": {
											Type:        "integer",
											Minimum:     getFloat64(0),
											Description: "max-allocate is the maximum number of IPs that will be allocated to the node.",
										},
										"pre-allocate": {
											Type:        "integer",
											Minimum:     getFloat64(0),
											Description: "pre-allocate is number of IP addresses that must be available for allocation at all times.",
										},
										"max-above-watermark": {
											Type:        "integer",
											Minimum:     getFloat64(0),
											Description: "max-above-watermark defines the number of addresses to allocate beyond what is needed to reach the PreAllocate watermark.",
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}

	return createUpdateCRD(clientset, "v2.CiliumNode", res)
}

// createIdentityCRD creates and updates the CiliumIdentity CRD. It should be
// called on agent startup but is idempotent and safe to call again.
func createIdentityCRD(clientset apiextensionsclient.Interface) error {

	var (
		// CustomResourceDefinitionShortNames are the abbreviated names to refer to this CRD's instances
		CustomResourceDefinitionShortNames = []string{"ciliumid"}
	)

	res := &apiextensionsv1beta1.CustomResourceDefinition{
		ObjectMeta: metav1.ObjectMeta{
			Name: k8sconstv2.CIDName,
		},
		Spec: apiextensionsv1beta1.CustomResourceDefinitionSpec{
			Group:   k8sconstv2.CustomResourceDefinitionGroup,
			Version: k8sconstv2.CustomResourceDefinitionVersion,
			Names: apiextensionsv1beta1.CustomResourceDefinitionNames{
				Plural:     k8sconstv2.CIDPluralName,
				Singular:   k8sconstv2.CIDSingularName,
				ShortNames: CustomResourceDefinitionShortNames,
				Kind:       k8sconstv2.CIDKindDefinition,
			},
			Subresources: &apiextensionsv1beta1.CustomResourceSubresources{
				Status: &apiextensionsv1beta1.CustomResourceSubresourceStatus{},
			},
			Scope: apiextensionsv1beta1.ClusterScoped,
		},
	}

	return createUpdateCRD(clientset, "v2.CiliumIdentity", res)
}

// createUpdateCRD ensures the CRD object is installed into the k8s cluster. It
// will create or update the CRD and it's validation when needed
func createUpdateCRD(clientset apiextensionsclient.Interface, CRDName string, crd *apiextensionsv1beta1.CustomResourceDefinition) error {
	scopedLog := log.WithField("name", CRDName)

	clusterCRD, err := clientset.ApiextensionsV1beta1().CustomResourceDefinitions().Get(context.TODO(), crd.ObjectMeta.Name, metav1.GetOptions{})
	if errors.IsNotFound(err) {
		scopedLog.Info("Creating CRD (CustomResourceDefinition)...")
		clusterCRD, err = clientset.ApiextensionsV1beta1().CustomResourceDefinitions().Create(context.TODO(), crd, metav1.CreateOptions{})
		// This occurs when multiple agents race to create the CRD. Since another has
		// created it, it will also update it, hence the non-error return.
		if errors.IsAlreadyExists(err) {
			return nil
		}
	}
	if err != nil {
		return err
	}

	scopedLog.Debug("Checking if CRD (CustomResourceDefinition) needs update...")
	if crd.Spec.Validation != nil &&
		clusterCRD.Labels[k8sconstv2.CustomResourceDefinitionSchemaVersionKey] != "" &&
		needsUpdate(clusterCRD) {
		scopedLog.Info("Updating CRD (CustomResourceDefinition)...")
		// Update the CRD with the validation schema.
		err = wait.Poll(500*time.Millisecond, 60*time.Second, func() (bool, error) {
			clusterCRD, err = clientset.ApiextensionsV1beta1().
				CustomResourceDefinitions().Get(context.TODO(), crd.ObjectMeta.Name, metav1.GetOptions{})

			if err != nil {
				return false, err
			}

			// This seems too permissive but we only get here if the version is
			// different per needsUpdate above. If so, we want to update on any
			// validation change including adding or removing validation.
			if needsUpdate(clusterCRD) {
				scopedLog.Debug("CRD validation is different, updating it...")
				clusterCRD.ObjectMeta.Labels = crd.ObjectMeta.Labels
				clusterCRD.Spec = crd.Spec
				_, err = clientset.ApiextensionsV1beta1().CustomResourceDefinitions().Update(context.TODO(), clusterCRD, metav1.UpdateOptions{})
				if err == nil {
					return true, nil
				}
				scopedLog.WithError(err).Debug("Unable to update CRD validation")
				return false, err
			}

			return true, nil
		})
		if err != nil {
			scopedLog.WithError(err).Error("Unable to update CRD")
			return err
		}
	}

	// wait for the CRD to be established
	scopedLog.Debug("Waiting for CRD (CustomResourceDefinition) to be available...")
	err = wait.Poll(500*time.Millisecond, 60*time.Second, func() (bool, error) {
		for _, cond := range clusterCRD.Status.Conditions {
			switch cond.Type {
			case apiextensionsv1beta1.Established:
				if cond.Status == apiextensionsv1beta1.ConditionTrue {
					return true, err
				}
			case apiextensionsv1beta1.NamesAccepted:
				if cond.Status == apiextensionsv1beta1.ConditionFalse {
					scopedLog.WithError(goerrors.New(cond.Reason)).Error("Name conflict for CRD")
					return false, err
				}
			}
		}
		clusterCRD, err = clientset.ApiextensionsV1beta1().CustomResourceDefinitions().Get(context.TODO(), crd.ObjectMeta.Name, metav1.GetOptions{})
		if err != nil {
			return false, err
		}
		return false, err
	})
	if err != nil {
		deleteErr := clientset.ApiextensionsV1beta1().CustomResourceDefinitions().Delete(context.TODO(), crd.ObjectMeta.Name, metav1.DeleteOptions{})
		if deleteErr != nil {
			return fmt.Errorf("unable to delete k8s %s CRD %s. Deleting CRD due: %s", CRDName, deleteErr, err)
		}
		return err
	}

	scopedLog.Info("CRD (CustomResourceDefinition) is installed and up-to-date")
	return nil
}

func needsUpdate(clusterCRD *apiextensionsv1beta1.CustomResourceDefinition) bool {

	if clusterCRD.Spec.Validation == nil {
		// no validation detected
		return true
	}
	v, ok := clusterCRD.Labels[k8sconstv2.CustomResourceDefinitionSchemaVersionKey]
	if !ok {
		// no schema version detected
		return true
	}
	clusterVersion, err := versioncheck.Version(v)
	if err != nil || clusterVersion.LT(comparableCRDSchemaVersion) {
		// version in cluster is either unparsable or smaller than current version
		return true
	}
	return false
}
