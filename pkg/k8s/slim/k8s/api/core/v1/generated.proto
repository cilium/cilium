// Copyright 2017-2020 Authors of Cilium
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package github.com.cilium.cilium.pkg.k8s.slim.k8s.api.core.v1;

import "github.com/cilium/cilium/pkg/k8s/slim/k8s/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "v1";

// ClientIPConfig represents the configurations of Client IP based session affinity.
message ClientIPConfig {
  // timeoutSeconds specifies the seconds of ClientIP type session sticky time.
  // The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
  // Default value is 10800(for 3 hours).
  // +optional
  optional int32 timeoutSeconds = 1;
}

// A single application container that you want to run within a pod.
message Container {
  // Name of the container specified as a DNS_LABEL.
  // Each container in a pod must have a unique name (DNS_LABEL).
  // Cannot be updated.
  optional string name = 1;

  // Docker image name.
  // More info: https://kubernetes.io/docs/concepts/containers/images
  // This field is optional to allow higher level config management to default or override
  // container images in workload controllers like Deployments and StatefulSets.
  // +optional
  optional string image = 2;

  // List of ports to expose from the container. Exposing a port here gives
  // the system additional information about the network connections a
  // container uses, but is primarily informational. Not specifying a port here
  // DOES NOT prevent that port from being exposed. Any port which is
  // listening on the default "0.0.0.0" address inside a container will be
  // accessible from the network.
  // Cannot be updated.
  // +optional
  // +patchMergeKey=containerPort
  // +patchStrategy=merge
  // +listType=map
  // +listMapKey=containerPort
  // +listMapKey=protocol
  repeated ContainerPort ports = 6;

  // Pod volumes to mount into the container's filesystem.
  // Cannot be updated.
  // +optional
  // +patchMergeKey=mountPath
  // +patchStrategy=merge
  repeated VolumeMount volumeMounts = 9;
}

// ContainerPort represents a network port in a single container.
message ContainerPort {
  // If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
  // named port in a pod must have a unique name. Name for the port that can be
  // referred to by services.
  // +optional
  optional string name = 1;

  // Number of port to expose on the host.
  // If specified, this must be a valid port number, 0 < x < 65536.
  // If HostNetwork is specified, this must match ContainerPort.
  // Most containers do not need this.
  // +optional
  optional int32 hostPort = 2;

  // Number of port to expose on the pod's IP address.
  // This must be a valid port number, 0 < x < 65536.
  optional int32 containerPort = 3;

  // Protocol for port. Must be UDP, TCP, or SCTP.
  // Defaults to "TCP".
  // +optional
  // +default="TCP"
  optional string protocol = 4;

  // What host IP to bind the external port to.
  // +optional
  optional string hostIP = 5;
}

// EndpointAddress is a tuple that describes single IP address.
message EndpointAddress {
  // The IP of this endpoint.
  // May not be loopback (127.0.0.0/8), link-local (169.254.0.0/16),
  // or link-local multicast ((224.0.0.0/24).
  // IPv6 is also accepted but not fully supported on all platforms. Also, certain
  // kubernetes components, like kube-proxy, are not IPv6 ready.
  // TODO: This should allow hostname or IP, See #4447.
  optional string ip = 1;

  // Optional: Node hosting this endpoint. This can be used to determine endpoints local to a node.
  // +optional
  optional string nodeName = 4;
}

// EndpointPort is a tuple that describes a single port.
message EndpointPort {
  // The name of this port.  This must match the 'name' field in the
  // corresponding ServicePort.
  // Must be a DNS_LABEL.
  // Optional only if one port is defined.
  // +optional
  optional string name = 1;

  // The port number of the endpoint.
  optional int32 port = 2;

  // The IP protocol for this port.
  // Must be UDP, TCP, or SCTP.
  // Default is TCP.
  // +optional
  optional string protocol = 3;
}

// EndpointSubset is a group of addresses with a common set of ports. The
// expanded set of endpoints is the Cartesian product of Addresses x Ports.
// For example, given:
//   {
//     Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
//     Ports:     [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
//   }
// The resulting set of endpoints can be viewed as:
//     a: [ 10.10.1.1:8675, 10.10.2.2:8675 ],
//     b: [ 10.10.1.1:309, 10.10.2.2:309 ]
message EndpointSubset {
  // IP addresses which offer the related ports that are marked as ready. These endpoints
  // should be considered safe for load balancers and clients to utilize.
  // +optional
  repeated EndpointAddress addresses = 1;

  // Port numbers available on the related IP addresses.
  // +optional
  repeated EndpointPort ports = 3;
}

// Endpoints is a collection of endpoints that implement the actual service. Example:
//   Name: "mysvc",
//   Subsets: [
//     {
//       Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
//       Ports: [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
//     },
//     {
//       Addresses: [{"ip": "10.10.3.3"}],
//       Ports: [{"name": "a", "port": 93}, {"name": "b", "port": 76}]
//     },
//  ]
message Endpoints {
  // Standard object's metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  // +optional
  optional github.com.cilium.cilium.pkg.k8s.slim.k8s.apis.meta.v1.ObjectMeta metadata = 1;

  // The set of all endpoints is the union of all subsets. Addresses are placed into
  // subsets according to the IPs they share. A single address with multiple ports,
  // some of which are ready and some of which are not (because they come from
  // different containers) will result in the address being displayed in different
  // subsets for the different ports. No address will appear in both Addresses and
  // NotReadyAddresses in the same subset.
  // Sets of addresses and ports that comprise a service.
  // +optional
  repeated EndpointSubset subsets = 2;
}

// EndpointsList is a list of endpoints.
message EndpointsList {
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  // +optional
  optional github.com.cilium.cilium.pkg.k8s.slim.k8s.apis.meta.v1.ListMeta metadata = 1;

  // List of endpoints.
  repeated Endpoints items = 2;
}

// A list of ephemeral containers used with the Pod ephemeralcontainers subresource.
message EphemeralContainers {
  // +optional
  optional github.com.cilium.cilium.pkg.k8s.slim.k8s.apis.meta.v1.ObjectMeta metadata = 1;
}

// LoadBalancerIngress represents the status of a load-balancer ingress point:
// traffic intended for the service should be sent to an ingress point.
message LoadBalancerIngress {
  // IP is set for load-balancer ingress points that are IP based
  // (typically GCE or OpenStack load-balancers)
  // +optional
  optional string ip = 1;
}

// LoadBalancerStatus represents the status of a load-balancer.
message LoadBalancerStatus {
  // Ingress is a list containing ingress points for the load-balancer.
  // Traffic intended for the service should be sent to these ingress points.
  // +optional
  repeated LoadBalancerIngress ingress = 1;
}

// Namespace provides a scope for Names.
// Use of multiple namespaces is optional.
message Namespace {
  // Standard object's metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  // +optional
  optional github.com.cilium.cilium.pkg.k8s.slim.k8s.apis.meta.v1.ObjectMeta metadata = 1;
}

// NamespaceList is a list of Namespaces.
message NamespaceList {
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  // +optional
  optional github.com.cilium.cilium.pkg.k8s.slim.k8s.apis.meta.v1.ListMeta metadata = 1;

  // Items is the list of Namespace objects in the list.
  // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  repeated Namespace items = 2;
}

// Node is a worker node in Kubernetes.
// Each node will have a unique identifier in the cache (i.e. in etcd).
message Node {
  // Standard object's metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  // +optional
  optional github.com.cilium.cilium.pkg.k8s.slim.k8s.apis.meta.v1.ObjectMeta metadata = 1;

  // Spec defines the behavior of a node.
  // https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  // +optional
  optional NodeSpec spec = 2;

  // Most recently observed status of the node.
  // Populated by the system.
  // Read-only.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  // +optional
  optional NodeStatus status = 3;
}

// NodeAddress contains information for the node's address.
message NodeAddress {
  // Node address type, one of Hostname, ExternalIP or InternalIP.
  optional string type = 1;

  // The node address.
  optional string address = 2;
}

// NodeList is the whole list of all Nodes which have been registered with master.
message NodeList {
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  // +optional
  optional github.com.cilium.cilium.pkg.k8s.slim.k8s.apis.meta.v1.ListMeta metadata = 1;

  // List of nodes
  repeated Node items = 2;
}

// NodeSpec describes the attributes that a node is created with.
message NodeSpec {
  // PodCIDR represents the pod IP range assigned to the node.
  // +optional
  optional string podCIDR = 1;

  // podCIDRs represents the IP ranges assigned to the node for usage by Pods on that node. If this
  // field is specified, the 0th entry must match the podCIDR field. It may contain at most 1 value for
  // each of IPv4 and IPv6.
  // +optional
  // +patchStrategy=merge
  repeated string podCIDRs = 7;

  // If specified, the node's taints.
  // +optional
  repeated Taint taints = 5;
}

// NodeStatus is information about the current status of a node.
message NodeStatus {
  // List of addresses reachable to the node.
  // Queried from cloud provider, if available.
  // More info: https://kubernetes.io/docs/concepts/nodes/node/#addresses
  // Note: This field is declared as mergeable, but the merge key is not sufficiently
  // unique, which can cause data corruption when it is merged. Callers should instead
  // use a full-replacement patch. See http://pr.k8s.io/79391 for an example.
  // +optional
  // +patchMergeKey=type
  // +patchStrategy=merge
  repeated NodeAddress addresses = 5;
}

// Pod is a collection of containers that can run on a host. This resource is created
// by clients and scheduled onto hosts.
message Pod {
  // Standard object's metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  // +optional
  optional github.com.cilium.cilium.pkg.k8s.slim.k8s.apis.meta.v1.ObjectMeta metadata = 1;

  // Specification of the desired behavior of the pod.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  // +optional
  optional PodSpec spec = 2;

  // Most recently observed status of the pod.
  // This data may not be up to date.
  // Populated by the system.
  // Read-only.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  // +optional
  optional PodStatus status = 3;
}

// PodCondition contains details for the current condition of this pod.
message PodCondition {
  // Type is the type of the condition.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
  optional string type = 1;

  // Status is the status of the condition.
  // Can be True, False, Unknown.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
  optional string status = 2;

  // Last time we probed the condition.
  // +optional
  optional github.com.cilium.cilium.pkg.k8s.slim.k8s.apis.meta.v1.Time lastProbeTime = 3;

  // Last time the condition transitioned from one status to another.
  // +optional
  optional github.com.cilium.cilium.pkg.k8s.slim.k8s.apis.meta.v1.Time lastTransitionTime = 4;

  // Unique, one-word, CamelCase reason for the condition's last transition.
  // +optional
  optional string reason = 5;

  // Human-readable message indicating details about last transition.
  // +optional
  optional string message = 6;
}

// IP address information for entries in the (plural) PodIPs field.
// Each entry includes:
//    IP: An IP address allocated to the pod. Routable at least within the cluster.
message PodIP {
  // ip is an IP address (IPv4 or IPv6) assigned to the pod
  optional string ip = 1;
}

// PodList is a list of Pods.
message PodList {
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  // +optional
  optional github.com.cilium.cilium.pkg.k8s.slim.k8s.apis.meta.v1.ListMeta metadata = 1;

  // List of pods.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
  repeated Pod items = 2;
}

// PodSpec is a description of a pod.
message PodSpec {
  // List of initialization containers belonging to the pod.
  // Init containers are executed in order prior to containers being started. If any
  // init container fails, the pod is considered to have failed and is handled according
  // to its restartPolicy. The name for an init container or normal container must be
  // unique among all containers.
  // Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
  // The resourceRequirements of an init container are taken into account during scheduling
  // by finding the highest request/limit for each resource type, and then using the max of
  // of that value or the sum of the normal containers. Limits are applied to init containers
  // in a similar fashion.
  // Init containers cannot currently be added or removed.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated Container initContainers = 20;

  // List of containers belonging to the pod.
  // Containers cannot currently be added or removed.
  // There must be at least one container in a Pod.
  // Cannot be updated.
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated Container containers = 2;

  // ServiceAccountName is the name of the ServiceAccount to use to run this pod.
  // More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
  // +optional
  optional string serviceAccountName = 8;

  // Host networking requested for this pod. Use the host's network namespace.
  // If this option is set, the ports that will be used must be specified.
  // Default to false.
  // +k8s:conversion-gen=false
  // +optional
  optional bool hostNetwork = 11;
}

// PodStatus represents information about the status of a pod. Status may trail the actual
// state of a system, especially if the node that hosts the pod cannot contact the control
// plane.
message PodStatus {
  // The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
  // The conditions array, the reason and message fields, and the individual container status
  // arrays contain more detail about the pod's status.
  // There are five possible phase values:
  //
  // Pending: The pod has been accepted by the Kubernetes system, but one or more of the
  // container images has not been created. This includes time before being scheduled as
  // well as time spent downloading images over the network, which could take a while.
  // Running: The pod has been bound to a node, and all of the containers have been created.
  // At least one container is still running, or is in the process of starting or restarting.
  // Succeeded: All containers in the pod have terminated in success, and will not be restarted.
  // Failed: All containers in the pod have terminated, and at least one container has
  // terminated in failure. The container either exited with non-zero status or was terminated
  // by the system.
  // Unknown: For some reason the state of the pod could not be obtained, typically due to an
  // error in communicating with the host of the pod.
  //
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
  // +optional
  optional string phase = 1;

  // Current service state of pod.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
  // +optional
  // +patchMergeKey=type
  // +patchStrategy=merge
  repeated PodCondition conditions = 2;

  // IP address of the host to which the pod is assigned. Empty if not yet scheduled.
  // +optional
  optional string hostIP = 5;

  // IP address allocated to the pod. Routable at least within the cluster.
  // Empty if not yet allocated.
  // +optional
  optional string podIP = 6;

  // podIPs holds the IP addresses allocated to the pod. If this field is specified, the 0th entry must
  // match the podIP field. Pods may be allocated at most 1 value for each of IPv4 and IPv6. This list
  // is empty if no IPs have been allocated yet.
  // +optional
  // +patchStrategy=merge
  // +patchMergeKey=ip
  repeated PodIP podIPs = 12;

  // RFC 3339 date and time at which the object was acknowledged by the Kubelet.
  // This is before the Kubelet pulled the container image(s) for the pod.
  // +optional
  optional github.com.cilium.cilium.pkg.k8s.slim.k8s.apis.meta.v1.Time startTime = 7;
}

// Service is a named abstraction of software service (for example, mysql) consisting of local port
// (for example 3306) that the proxy listens on, and the selector that determines which pods
// will answer requests sent through the proxy.
message Service {
  // Standard object's metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  // +optional
  optional github.com.cilium.cilium.pkg.k8s.slim.k8s.apis.meta.v1.ObjectMeta metadata = 1;

  // Spec defines the behavior of a service.
  // https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  // +optional
  optional ServiceSpec spec = 2;

  // Most recently observed status of the service.
  // Populated by the system.
  // Read-only.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  // +optional
  optional ServiceStatus status = 3;
}

// ServiceList holds a list of services.
message ServiceList {
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  // +optional
  optional github.com.cilium.cilium.pkg.k8s.slim.k8s.apis.meta.v1.ListMeta metadata = 1;

  // List of services
  repeated Service items = 2;
}

// ServicePort contains information on service's port.
message ServicePort {
  // The name of this port within the service. This must be a DNS_LABEL.
  // All ports within a ServiceSpec must have unique names. When considering
  // the endpoints for a Service, this must match the 'name' field in the
  // EndpointPort.
  // Optional if only one ServicePort is defined on this service.
  // +optional
  optional string name = 1;

  // The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
  // Default is TCP.
  // +optional
  optional string protocol = 2;

  // The port that will be exposed by this service.
  optional int32 port = 3;

  // The port on each node on which this service is exposed when type is
  // NodePort or LoadBalancer.  Usually assigned by the system. If a value is
  // specified, in-range, and not in use it will be used, otherwise the
  // operation will fail.  If not specified, a port will be allocated if this
  // Service requires one.  If this field is specified when creating a
  // Service which does not need it, creation will fail. This field will be
  // wiped when updating a Service to no longer need it (e.g. changing type
  // from NodePort to ClusterIP).
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
  // +optional
  optional int32 nodePort = 5;
}

// ServiceSpec describes the attributes that a user creates on a service.
message ServiceSpec {
  // The list of ports that are exposed by this service.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  // +patchMergeKey=port
  // +patchStrategy=merge
  // +listType=map
  // +listMapKey=port
  // +listMapKey=protocol
  repeated ServicePort ports = 1;

  // Route service traffic to pods with label keys and values matching this
  // selector. If empty or not present, the service is assumed to have an
  // external process managing its endpoints, which Kubernetes will not
  // modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
  // Ignored if type is ExternalName.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/
  // +optional
  map<string, string> selector = 2;

  // clusterIP is the IP address of the service and is usually assigned
  // randomly. If an address is specified manually, is in-range (as per
  // system configuration), and is not in use, it will be allocated to the
  // service; otherwise creation of the service will fail. This field may not
  // be changed through updates unless the type field is also being changed
  // to ExternalName (which requires this field to be blank) or the type
  // field is being changed from ExternalName (in which case this field may
  // optionally be specified, as describe above).  Valid values are "None",
  // empty string (""), or a valid IP address. Setting this to "None" makes a
  // "headless service" (no virtual IP), which is useful when direct endpoint
  // connections are preferred and proxying is not required.  Only applies to
  // types ClusterIP, NodePort, and LoadBalancer. If this field is specified
  // when creating a Service of type ExternalName, creation will fail. This
  // field will be wiped when updating a Service to type ExternalName.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  // +optional
  optional string clusterIP = 3;

  // ClusterIPs is a list of IP addresses assigned to this service, and are
  // usually assigned randomly.  If an address is specified manually, is
  // in-range (as per system configuration), and is not in use, it will be
  // allocated to the service; otherwise creation of the service will fail.
  // This field may not be changed through updates unless the type field is
  // also being changed to ExternalName (which requires this field to be
  // empty) or the type field is being changed from ExternalName (in which
  // case this field may optionally be specified, as describe above).  Valid
  // values are "None", empty string (""), or a valid IP address.  Setting
  // this to "None" makes a "headless service" (no virtual IP), which is
  // useful when direct endpoint connections are preferred and proxying is
  // not required.  Only applies to types ClusterIP, NodePort, and
  // LoadBalancer. If this field is specified when creating a Service of type
  // ExternalName, creation will fail. This field will be wiped when updating
  // a Service to type ExternalName.  If this field is not specified, it will
  // be initialized from the clusterIP field.  If this field is specified,
  // clients must ensure that clusterIPs[0] and clusterIP have the same
  // value.
  //
  // Unless the "IPv6DualStack" feature gate is enabled, this field is
  // limited to one value, which must be the same as the clusterIP field.  If
  // the feature gate is enabled, this field may hold a maximum of two
  // entries (dual-stack IPs, in either order).  These IPs must correspond to
  // the values of the ipFamilies field. Both clusterIPs and ipFamilies are
  // governed by the ipFamilyPolicy field.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  // +listType=atomic
  // +optional
  repeated string clusterIPs = 18;

  // type determines how the Service is exposed. Defaults to ClusterIP. Valid
  // options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
  // "ClusterIP" allocates a cluster-internal IP address for load-balancing
  // to endpoints. Endpoints are determined by the selector or if that is not
  // specified, by manual construction of an Endpoints object or
  // EndpointSlice objects. If clusterIP is "None", no virtual IP is
  // allocated and the endpoints are published as a set of endpoints rather
  // than a virtual IP.
  // "NodePort" builds on ClusterIP and allocates a port on every node which
  // routes to the same endpoints as the clusterIP.
  // "LoadBalancer" builds on NodePort and creates an external load-balancer
  // (if supported in the current cloud) which routes to the same endpoints
  // as the clusterIP.
  // "ExternalName" aliases this service to the specified externalName.
  // Several other fields do not apply to ExternalName services.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  // +optional
  optional string type = 4;

  // externalIPs is a list of IP addresses for which nodes in the cluster
  // will also accept traffic for this service.  These IPs are not managed by
  // Kubernetes.  The user is responsible for ensuring that traffic arrives
  // at a node with this IP.  A common example is external load-balancers
  // that are not part of the Kubernetes system.
  // +optional
  repeated string externalIPs = 5;

  // Supports "ClientIP" and "None". Used to maintain session affinity.
  // Enable client IP based session affinity.
  // Must be ClientIP or None.
  // Defaults to None.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  // +optional
  optional string sessionAffinity = 7;

  // If specified and supported by the platform, this will restrict traffic through the cloud-provider
  // load-balancer will be restricted to the specified client IPs. This field will be ignored if the
  // cloud-provider does not support the feature."
  // More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
  // +optional
  repeated string loadBalancerSourceRanges = 9;

  // externalTrafficPolicy denotes if this Service desires to route external
  // traffic to node-local or cluster-wide endpoints. "Local" preserves the
  // client source IP and avoids a second hop for LoadBalancer and Nodeport
  // type services, but risks potentially imbalanced traffic spreading.
  // "Cluster" obscures the client source IP and may cause a second hop to
  // another node, but should have good overall load-spreading.
  // +optional
  optional string externalTrafficPolicy = 11;

  // healthCheckNodePort specifies the healthcheck nodePort for the service.
  // This only applies when type is set to LoadBalancer and
  // externalTrafficPolicy is set to Local. If a value is specified, is
  // in-range, and is not in use, it will be used.  If not specified, a value
  // will be automatically allocated.  External systems (e.g. load-balancers)
  // can use this port to determine if a given node holds endpoints for this
  // service or not.  If this field is specified when creating a Service
  // which does not need it, creation will fail. This field will be wiped
  // when updating a Service to no longer need it (e.g. changing type).
  // +optional
  optional int32 healthCheckNodePort = 12;

  // sessionAffinityConfig contains the configurations of session affinity.
  // +optional
  optional SessionAffinityConfig sessionAffinityConfig = 14;

  // IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
  // service, and is gated by the "IPv6DualStack" feature gate.  This field
  // is usually assigned automatically based on cluster configuration and the
  // ipFamilyPolicy field. If this field is specified manually, the requested
  // family is available in the cluster, and ipFamilyPolicy allows it, it
  // will be used; otherwise creation of the service will fail.  This field
  // is conditionally mutable: it allows for adding or removing a secondary
  // IP family, but it does not allow changing the primary IP family of the
  // Service.  Valid values are "IPv4" and "IPv6".  This field only applies
  // to Services of types ClusterIP, NodePort, and LoadBalancer, and does
  // apply to "headless" services.  This field will be wiped when updating a
  // Service to type ExternalName.
  //
  // This field may hold a maximum of two entries (dual-stack families, in
  // either order).  These families must correspond to the values of the
  // clusterIPs field, if specified. Both clusterIPs and ipFamilies are
  // governed by the ipFamilyPolicy field.
  // +listType=atomic
  // +optional
  repeated string ipFamilies = 19;
}

// ServiceStatus represents the current status of a service.
message ServiceStatus {
  // LoadBalancer contains the current status of the load-balancer,
  // if one is present.
  // +optional
  optional LoadBalancerStatus loadBalancer = 1;
}

// SessionAffinityConfig represents the configurations of session affinity.
message SessionAffinityConfig {
  // clientIP contains the configurations of Client IP based session affinity.
  // +optional
  optional ClientIPConfig clientIP = 1;
}

// The node this Taint is attached to has the "effect" on
// any pod that does not tolerate the Taint.
message Taint {
  // Required. The taint key to be applied to a node.
  optional string key = 1;

  // The taint value corresponding to the taint key.
  // +optional
  optional string value = 2;

  // Required. The effect of the taint on pods
  // that do not tolerate the taint.
  // Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
  optional string effect = 3;

  // TimeAdded represents the time at which the taint was added.
  // It is only written for NoExecute taints.
  // +optional
  optional github.com.cilium.cilium.pkg.k8s.slim.k8s.apis.meta.v1.Time timeAdded = 4;
}

// VolumeMount describes a mounting of a Volume within a container.
message VolumeMount {
  // Path within the container at which the volume should be mounted.  Must
  // not contain ':'.
  optional string mountPath = 3;
}

