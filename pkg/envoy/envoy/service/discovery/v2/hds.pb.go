// Code generated by protoc-gen-go. DO NOT EDIT.
// source: envoy/service/discovery/v2/hds.proto

package v2

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import envoy_api_v2_core "github.com/cilium/cilium/pkg/envoy/envoy/api/v2/core"
import envoy_api_v2_core1 "github.com/cilium/cilium/pkg/envoy/envoy/api/v2/core"
import envoy_api_v2_endpoint "github.com/cilium/cilium/pkg/envoy/envoy/api/v2/endpoint"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf3 "github.com/golang/protobuf/ptypes/duration"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Different Envoy instances may have different capabilities (e.g. Redis)
// and/or have ports enabled for different protocols.
type Capability_Protocol int32

const (
	Capability_HTTP  Capability_Protocol = 0
	Capability_TCP   Capability_Protocol = 1
	Capability_REDIS Capability_Protocol = 2
)

var Capability_Protocol_name = map[int32]string{
	0: "HTTP",
	1: "TCP",
	2: "REDIS",
}
var Capability_Protocol_value = map[string]int32{
	"HTTP":  0,
	"TCP":   1,
	"REDIS": 2,
}

func (x Capability_Protocol) String() string {
	return proto.EnumName(Capability_Protocol_name, int32(x))
}
func (Capability_Protocol) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 0} }

// Defines supported protocols etc, so the management server can assign proper
// endpoints to healthcheck.
type Capability struct {
	HealthCheckProtocol []Capability_Protocol `protobuf:"varint,1,rep,packed,name=health_check_protocol,json=healthCheckProtocol,enum=envoy.service.discovery.v2.Capability_Protocol" json:"health_check_protocol,omitempty"`
}

func (m *Capability) Reset()                    { *m = Capability{} }
func (m *Capability) String() string            { return proto.CompactTextString(m) }
func (*Capability) ProtoMessage()               {}
func (*Capability) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *Capability) GetHealthCheckProtocol() []Capability_Protocol {
	if m != nil {
		return m.HealthCheckProtocol
	}
	return nil
}

type HealthCheckRequest struct {
	Node       *envoy_api_v2_core.Node `protobuf:"bytes,1,opt,name=node" json:"node,omitempty"`
	Capability *Capability             `protobuf:"bytes,2,opt,name=capability" json:"capability,omitempty"`
}

func (m *HealthCheckRequest) Reset()                    { *m = HealthCheckRequest{} }
func (m *HealthCheckRequest) String() string            { return proto.CompactTextString(m) }
func (*HealthCheckRequest) ProtoMessage()               {}
func (*HealthCheckRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *HealthCheckRequest) GetNode() *envoy_api_v2_core.Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *HealthCheckRequest) GetCapability() *Capability {
	if m != nil {
		return m.Capability
	}
	return nil
}

type EndpointHealth struct {
	Endpoint     *envoy_api_v2_endpoint.Endpoint `protobuf:"bytes,1,opt,name=endpoint" json:"endpoint,omitempty"`
	HealthStatus envoy_api_v2_core1.HealthStatus `protobuf:"varint,2,opt,name=health_status,json=healthStatus,enum=envoy.api.v2.core.HealthStatus" json:"health_status,omitempty"`
}

func (m *EndpointHealth) Reset()                    { *m = EndpointHealth{} }
func (m *EndpointHealth) String() string            { return proto.CompactTextString(m) }
func (*EndpointHealth) ProtoMessage()               {}
func (*EndpointHealth) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *EndpointHealth) GetEndpoint() *envoy_api_v2_endpoint.Endpoint {
	if m != nil {
		return m.Endpoint
	}
	return nil
}

func (m *EndpointHealth) GetHealthStatus() envoy_api_v2_core1.HealthStatus {
	if m != nil {
		return m.HealthStatus
	}
	return envoy_api_v2_core1.HealthStatus_UNKNOWN
}

type EndpointHealthResponse struct {
	EndpointsHealth []*EndpointHealth `protobuf:"bytes,1,rep,name=endpoints_health,json=endpointsHealth" json:"endpoints_health,omitempty"`
}

func (m *EndpointHealthResponse) Reset()                    { *m = EndpointHealthResponse{} }
func (m *EndpointHealthResponse) String() string            { return proto.CompactTextString(m) }
func (*EndpointHealthResponse) ProtoMessage()               {}
func (*EndpointHealthResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *EndpointHealthResponse) GetEndpointsHealth() []*EndpointHealth {
	if m != nil {
		return m.EndpointsHealth
	}
	return nil
}

type HealthCheckRequestOrEndpointHealthResponse struct {
	// Types that are valid to be assigned to RequestType:
	//	*HealthCheckRequestOrEndpointHealthResponse_HealthCheckRequest
	//	*HealthCheckRequestOrEndpointHealthResponse_EndpointHealthResponse
	RequestType isHealthCheckRequestOrEndpointHealthResponse_RequestType `protobuf_oneof:"request_type"`
}

func (m *HealthCheckRequestOrEndpointHealthResponse) Reset() {
	*m = HealthCheckRequestOrEndpointHealthResponse{}
}
func (m *HealthCheckRequestOrEndpointHealthResponse) String() string {
	return proto.CompactTextString(m)
}
func (*HealthCheckRequestOrEndpointHealthResponse) ProtoMessage() {}
func (*HealthCheckRequestOrEndpointHealthResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor1, []int{4}
}

type isHealthCheckRequestOrEndpointHealthResponse_RequestType interface {
	isHealthCheckRequestOrEndpointHealthResponse_RequestType()
}

type HealthCheckRequestOrEndpointHealthResponse_HealthCheckRequest struct {
	HealthCheckRequest *HealthCheckRequest `protobuf:"bytes,1,opt,name=health_check_request,json=healthCheckRequest,oneof"`
}
type HealthCheckRequestOrEndpointHealthResponse_EndpointHealthResponse struct {
	EndpointHealthResponse *EndpointHealthResponse `protobuf:"bytes,2,opt,name=endpoint_health_response,json=endpointHealthResponse,oneof"`
}

func (*HealthCheckRequestOrEndpointHealthResponse_HealthCheckRequest) isHealthCheckRequestOrEndpointHealthResponse_RequestType() {
}
func (*HealthCheckRequestOrEndpointHealthResponse_EndpointHealthResponse) isHealthCheckRequestOrEndpointHealthResponse_RequestType() {
}

func (m *HealthCheckRequestOrEndpointHealthResponse) GetRequestType() isHealthCheckRequestOrEndpointHealthResponse_RequestType {
	if m != nil {
		return m.RequestType
	}
	return nil
}

func (m *HealthCheckRequestOrEndpointHealthResponse) GetHealthCheckRequest() *HealthCheckRequest {
	if x, ok := m.GetRequestType().(*HealthCheckRequestOrEndpointHealthResponse_HealthCheckRequest); ok {
		return x.HealthCheckRequest
	}
	return nil
}

func (m *HealthCheckRequestOrEndpointHealthResponse) GetEndpointHealthResponse() *EndpointHealthResponse {
	if x, ok := m.GetRequestType().(*HealthCheckRequestOrEndpointHealthResponse_EndpointHealthResponse); ok {
		return x.EndpointHealthResponse
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HealthCheckRequestOrEndpointHealthResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HealthCheckRequestOrEndpointHealthResponse_OneofMarshaler, _HealthCheckRequestOrEndpointHealthResponse_OneofUnmarshaler, _HealthCheckRequestOrEndpointHealthResponse_OneofSizer, []interface{}{
		(*HealthCheckRequestOrEndpointHealthResponse_HealthCheckRequest)(nil),
		(*HealthCheckRequestOrEndpointHealthResponse_EndpointHealthResponse)(nil),
	}
}

func _HealthCheckRequestOrEndpointHealthResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HealthCheckRequestOrEndpointHealthResponse)
	// request_type
	switch x := m.RequestType.(type) {
	case *HealthCheckRequestOrEndpointHealthResponse_HealthCheckRequest:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HealthCheckRequest); err != nil {
			return err
		}
	case *HealthCheckRequestOrEndpointHealthResponse_EndpointHealthResponse:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EndpointHealthResponse); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("HealthCheckRequestOrEndpointHealthResponse.RequestType has unexpected type %T", x)
	}
	return nil
}

func _HealthCheckRequestOrEndpointHealthResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HealthCheckRequestOrEndpointHealthResponse)
	switch tag {
	case 1: // request_type.health_check_request
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HealthCheckRequest)
		err := b.DecodeMessage(msg)
		m.RequestType = &HealthCheckRequestOrEndpointHealthResponse_HealthCheckRequest{msg}
		return true, err
	case 2: // request_type.endpoint_health_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EndpointHealthResponse)
		err := b.DecodeMessage(msg)
		m.RequestType = &HealthCheckRequestOrEndpointHealthResponse_EndpointHealthResponse{msg}
		return true, err
	default:
		return false, nil
	}
}

func _HealthCheckRequestOrEndpointHealthResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HealthCheckRequestOrEndpointHealthResponse)
	// request_type
	switch x := m.RequestType.(type) {
	case *HealthCheckRequestOrEndpointHealthResponse_HealthCheckRequest:
		s := proto.Size(x.HealthCheckRequest)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *HealthCheckRequestOrEndpointHealthResponse_EndpointHealthResponse:
		s := proto.Size(x.EndpointHealthResponse)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type LocalityEndpoints struct {
	Locality  *envoy_api_v2_core.Locality       `protobuf:"bytes,1,opt,name=locality" json:"locality,omitempty"`
	Endpoints []*envoy_api_v2_endpoint.Endpoint `protobuf:"bytes,2,rep,name=endpoints" json:"endpoints,omitempty"`
}

func (m *LocalityEndpoints) Reset()                    { *m = LocalityEndpoints{} }
func (m *LocalityEndpoints) String() string            { return proto.CompactTextString(m) }
func (*LocalityEndpoints) ProtoMessage()               {}
func (*LocalityEndpoints) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

func (m *LocalityEndpoints) GetLocality() *envoy_api_v2_core.Locality {
	if m != nil {
		return m.Locality
	}
	return nil
}

func (m *LocalityEndpoints) GetEndpoints() []*envoy_api_v2_endpoint.Endpoint {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

// The cluster name and locality is provided to Envoy for the endpoints that it
// health checks to support statistics reporting, logging and debugging by the
// Envoy instance (outside of HDS). For maximum usefulness, it should match the
// same cluster structure as that provided by EDS.
type ClusterHealthCheck struct {
	ClusterName  string                            `protobuf:"bytes,1,opt,name=cluster_name,json=clusterName" json:"cluster_name,omitempty"`
	HealthChecks []*envoy_api_v2_core1.HealthCheck `protobuf:"bytes,2,rep,name=health_checks,json=healthChecks" json:"health_checks,omitempty"`
	Endpoints    []*LocalityEndpoints              `protobuf:"bytes,3,rep,name=endpoints" json:"endpoints,omitempty"`
}

func (m *ClusterHealthCheck) Reset()                    { *m = ClusterHealthCheck{} }
func (m *ClusterHealthCheck) String() string            { return proto.CompactTextString(m) }
func (*ClusterHealthCheck) ProtoMessage()               {}
func (*ClusterHealthCheck) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{6} }

func (m *ClusterHealthCheck) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

func (m *ClusterHealthCheck) GetHealthChecks() []*envoy_api_v2_core1.HealthCheck {
	if m != nil {
		return m.HealthChecks
	}
	return nil
}

func (m *ClusterHealthCheck) GetEndpoints() []*LocalityEndpoints {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

type HealthCheckSpecifier struct {
	HealthCheck []*ClusterHealthCheck `protobuf:"bytes,1,rep,name=health_check,json=healthCheck" json:"health_check,omitempty"`
	// The default is 1 second.
	Interval *google_protobuf3.Duration `protobuf:"bytes,2,opt,name=interval" json:"interval,omitempty"`
}

func (m *HealthCheckSpecifier) Reset()                    { *m = HealthCheckSpecifier{} }
func (m *HealthCheckSpecifier) String() string            { return proto.CompactTextString(m) }
func (*HealthCheckSpecifier) ProtoMessage()               {}
func (*HealthCheckSpecifier) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{7} }

func (m *HealthCheckSpecifier) GetHealthCheck() []*ClusterHealthCheck {
	if m != nil {
		return m.HealthCheck
	}
	return nil
}

func (m *HealthCheckSpecifier) GetInterval() *google_protobuf3.Duration {
	if m != nil {
		return m.Interval
	}
	return nil
}

func init() {
	proto.RegisterType((*Capability)(nil), "envoy.service.discovery.v2.Capability")
	proto.RegisterType((*HealthCheckRequest)(nil), "envoy.service.discovery.v2.HealthCheckRequest")
	proto.RegisterType((*EndpointHealth)(nil), "envoy.service.discovery.v2.EndpointHealth")
	proto.RegisterType((*EndpointHealthResponse)(nil), "envoy.service.discovery.v2.EndpointHealthResponse")
	proto.RegisterType((*HealthCheckRequestOrEndpointHealthResponse)(nil), "envoy.service.discovery.v2.HealthCheckRequestOrEndpointHealthResponse")
	proto.RegisterType((*LocalityEndpoints)(nil), "envoy.service.discovery.v2.LocalityEndpoints")
	proto.RegisterType((*ClusterHealthCheck)(nil), "envoy.service.discovery.v2.ClusterHealthCheck")
	proto.RegisterType((*HealthCheckSpecifier)(nil), "envoy.service.discovery.v2.HealthCheckSpecifier")
	proto.RegisterEnum("envoy.service.discovery.v2.Capability_Protocol", Capability_Protocol_name, Capability_Protocol_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for HealthDiscoveryService service

type HealthDiscoveryServiceClient interface {
	// 1. Envoy starts up and if its can_healthcheck option in the static
	//    bootstrap config is enabled, sends HealthCheckRequest to the management
	//    server. It supplies its capabilities (which protocol it can health check
	//    with, what zone it resides in, etc.).
	// 2. In response to (1), the management server designates this Envoy as a
	//    healthchecker to health check a subset of all upstream hosts for a given
	//    cluster (for example upstream Host 1 and Host 2). It streams
	//    HealthCheckSpecifier messages with cluster related configuration for all
	//    clusters this Envoy is designated to health check. Subsequent
	//    HealthCheckSpecifier message will be sent on changes to:
	//    a. Endpoints to health checks
	//    b. Per cluster configuration change
	// 3. Envoy creates a health probe based on the HealthCheck config and sends
	//    it to endpoint(ip:port) of Host 1 and 2. Based on the HealthCheck
	//    configuration Envoy waits upon the arrival of the probe response and
	//    looks at the content of the response to decide whether the endpoint is
	//    healthy or not. If a response hasn’t been received within the timeout
	//    interval, the endpoint health status is considered TIMEOUT.
	// 4. Envoy reports results back in an EndpointHealthResponse message.
	//    Envoy streams responses as often as the interval configured by the
	//    management server in HealthCheckSpecifier.
	// 5. The management Server collects health statuses for all endpoints in the
	//    cluster (for all clusters) and uses this information to construct
	//    EndpointDiscoveryResponse messages.
	// 6. Once Envoy has a list of upstream endpoints to send traffic to, it load
	//    balances traffic to them without additional health checking. It may
	//    use inline healthcheck (i.e. consider endpoint UNHEALTHY if connection
	//    failed to a particular endpoint to account for health status propagation
	//    delay between HDS and EDS).
	// By default, can_healthcheck is true. If can_healthcheck is false, Cluster
	// configuration may not contain HealthCheck message.
	// TODO(htuch): How is can_healthcheck communicated to CDS to ensure the above
	// invariant?
	// TODO(htuch): Add @amb67's diagram.
	StreamHealthCheck(ctx context.Context, opts ...grpc.CallOption) (HealthDiscoveryService_StreamHealthCheckClient, error)
	// TODO(htuch): Unlike the gRPC version, there is no stream-based binding of
	// request/response. Should we add an identifier to the HealthCheckSpecifier
	// to bind with the response?
	FetchHealthCheck(ctx context.Context, in *HealthCheckRequestOrEndpointHealthResponse, opts ...grpc.CallOption) (*HealthCheckSpecifier, error)
}

type healthDiscoveryServiceClient struct {
	cc *grpc.ClientConn
}

func NewHealthDiscoveryServiceClient(cc *grpc.ClientConn) HealthDiscoveryServiceClient {
	return &healthDiscoveryServiceClient{cc}
}

func (c *healthDiscoveryServiceClient) StreamHealthCheck(ctx context.Context, opts ...grpc.CallOption) (HealthDiscoveryService_StreamHealthCheckClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_HealthDiscoveryService_serviceDesc.Streams[0], c.cc, "/envoy.service.discovery.v2.HealthDiscoveryService/StreamHealthCheck", opts...)
	if err != nil {
		return nil, err
	}
	x := &healthDiscoveryServiceStreamHealthCheckClient{stream}
	return x, nil
}

type HealthDiscoveryService_StreamHealthCheckClient interface {
	Send(*HealthCheckRequestOrEndpointHealthResponse) error
	Recv() (*HealthCheckSpecifier, error)
	grpc.ClientStream
}

type healthDiscoveryServiceStreamHealthCheckClient struct {
	grpc.ClientStream
}

func (x *healthDiscoveryServiceStreamHealthCheckClient) Send(m *HealthCheckRequestOrEndpointHealthResponse) error {
	return x.ClientStream.SendMsg(m)
}

func (x *healthDiscoveryServiceStreamHealthCheckClient) Recv() (*HealthCheckSpecifier, error) {
	m := new(HealthCheckSpecifier)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *healthDiscoveryServiceClient) FetchHealthCheck(ctx context.Context, in *HealthCheckRequestOrEndpointHealthResponse, opts ...grpc.CallOption) (*HealthCheckSpecifier, error) {
	out := new(HealthCheckSpecifier)
	err := grpc.Invoke(ctx, "/envoy.service.discovery.v2.HealthDiscoveryService/FetchHealthCheck", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for HealthDiscoveryService service

type HealthDiscoveryServiceServer interface {
	// 1. Envoy starts up and if its can_healthcheck option in the static
	//    bootstrap config is enabled, sends HealthCheckRequest to the management
	//    server. It supplies its capabilities (which protocol it can health check
	//    with, what zone it resides in, etc.).
	// 2. In response to (1), the management server designates this Envoy as a
	//    healthchecker to health check a subset of all upstream hosts for a given
	//    cluster (for example upstream Host 1 and Host 2). It streams
	//    HealthCheckSpecifier messages with cluster related configuration for all
	//    clusters this Envoy is designated to health check. Subsequent
	//    HealthCheckSpecifier message will be sent on changes to:
	//    a. Endpoints to health checks
	//    b. Per cluster configuration change
	// 3. Envoy creates a health probe based on the HealthCheck config and sends
	//    it to endpoint(ip:port) of Host 1 and 2. Based on the HealthCheck
	//    configuration Envoy waits upon the arrival of the probe response and
	//    looks at the content of the response to decide whether the endpoint is
	//    healthy or not. If a response hasn’t been received within the timeout
	//    interval, the endpoint health status is considered TIMEOUT.
	// 4. Envoy reports results back in an EndpointHealthResponse message.
	//    Envoy streams responses as often as the interval configured by the
	//    management server in HealthCheckSpecifier.
	// 5. The management Server collects health statuses for all endpoints in the
	//    cluster (for all clusters) and uses this information to construct
	//    EndpointDiscoveryResponse messages.
	// 6. Once Envoy has a list of upstream endpoints to send traffic to, it load
	//    balances traffic to them without additional health checking. It may
	//    use inline healthcheck (i.e. consider endpoint UNHEALTHY if connection
	//    failed to a particular endpoint to account for health status propagation
	//    delay between HDS and EDS).
	// By default, can_healthcheck is true. If can_healthcheck is false, Cluster
	// configuration may not contain HealthCheck message.
	// TODO(htuch): How is can_healthcheck communicated to CDS to ensure the above
	// invariant?
	// TODO(htuch): Add @amb67's diagram.
	StreamHealthCheck(HealthDiscoveryService_StreamHealthCheckServer) error
	// TODO(htuch): Unlike the gRPC version, there is no stream-based binding of
	// request/response. Should we add an identifier to the HealthCheckSpecifier
	// to bind with the response?
	FetchHealthCheck(context.Context, *HealthCheckRequestOrEndpointHealthResponse) (*HealthCheckSpecifier, error)
}

func RegisterHealthDiscoveryServiceServer(s *grpc.Server, srv HealthDiscoveryServiceServer) {
	s.RegisterService(&_HealthDiscoveryService_serviceDesc, srv)
}

func _HealthDiscoveryService_StreamHealthCheck_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(HealthDiscoveryServiceServer).StreamHealthCheck(&healthDiscoveryServiceStreamHealthCheckServer{stream})
}

type HealthDiscoveryService_StreamHealthCheckServer interface {
	Send(*HealthCheckSpecifier) error
	Recv() (*HealthCheckRequestOrEndpointHealthResponse, error)
	grpc.ServerStream
}

type healthDiscoveryServiceStreamHealthCheckServer struct {
	grpc.ServerStream
}

func (x *healthDiscoveryServiceStreamHealthCheckServer) Send(m *HealthCheckSpecifier) error {
	return x.ServerStream.SendMsg(m)
}

func (x *healthDiscoveryServiceStreamHealthCheckServer) Recv() (*HealthCheckRequestOrEndpointHealthResponse, error) {
	m := new(HealthCheckRequestOrEndpointHealthResponse)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _HealthDiscoveryService_FetchHealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequestOrEndpointHealthResponse)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthDiscoveryServiceServer).FetchHealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/envoy.service.discovery.v2.HealthDiscoveryService/FetchHealthCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthDiscoveryServiceServer).FetchHealthCheck(ctx, req.(*HealthCheckRequestOrEndpointHealthResponse))
	}
	return interceptor(ctx, in, info, handler)
}

var _HealthDiscoveryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "envoy.service.discovery.v2.HealthDiscoveryService",
	HandlerType: (*HealthDiscoveryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FetchHealthCheck",
			Handler:    _HealthDiscoveryService_FetchHealthCheck_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamHealthCheck",
			Handler:       _HealthDiscoveryService_StreamHealthCheck_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "envoy/service/discovery/v2/hds.proto",
}

func init() { proto.RegisterFile("envoy/service/discovery/v2/hds.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 713 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x55, 0xc1, 0x6e, 0xd3, 0x4a,
	0x14, 0xcd, 0xa4, 0x7d, 0x8f, 0xf4, 0x26, 0x84, 0x74, 0x28, 0x25, 0x84, 0xaa, 0x2d, 0x56, 0x41,
	0x51, 0x11, 0x4e, 0x65, 0x84, 0x90, 0x8a, 0xd8, 0x90, 0xb4, 0x0a, 0x02, 0x95, 0x32, 0x29, 0xeb,
	0x68, 0xe2, 0x4c, 0x6b, 0x0b, 0xd7, 0x63, 0x3c, 0x93, 0x48, 0xd9, 0xb2, 0x43, 0x6c, 0x90, 0xba,
	0x64, 0xc3, 0x3f, 0xf0, 0x15, 0xac, 0xf9, 0x85, 0x7e, 0x08, 0xca, 0xcc, 0xd8, 0x75, 0x9b, 0x26,
	0xb4, 0x3b, 0x76, 0xf1, 0xcc, 0x39, 0xe7, 0x9e, 0x7b, 0xcf, 0xb5, 0x03, 0x1b, 0x2c, 0x1c, 0xf2,
	0x51, 0x43, 0xb0, 0x78, 0xe8, 0xbb, 0xac, 0xd1, 0xf7, 0x85, 0xcb, 0x87, 0x2c, 0x1e, 0x35, 0x86,
	0x4e, 0xc3, 0xeb, 0x0b, 0x3b, 0x8a, 0xb9, 0xe4, 0xb8, 0xa6, 0x50, 0xb6, 0x41, 0xd9, 0x29, 0xca,
	0x1e, 0x3a, 0xb5, 0x15, 0xad, 0x40, 0x23, 0x7f, 0xcc, 0x71, 0x79, 0xcc, 0x1a, 0x3d, 0x2a, 0x98,
	0x66, 0xd6, 0x36, 0x26, 0x6f, 0x3d, 0x46, 0x03, 0xe9, 0x75, 0x5d, 0x8f, 0xb9, 0x1f, 0x2f, 0x45,
	0xb1, 0xb0, 0x1f, 0x71, 0x3f, 0x94, 0xe9, 0x0f, 0x83, 0x5a, 0x39, 0xe2, 0xfc, 0x28, 0x60, 0x0a,
	0x46, 0xc3, 0x90, 0x4b, 0x2a, 0x7d, 0x1e, 0x1a, 0x8f, 0xb5, 0x55, 0x73, 0xab, 0x9e, 0x7a, 0x83,
	0xc3, 0x46, 0x7f, 0x10, 0x2b, 0x80, 0xbe, 0xb7, 0xbe, 0x23, 0x80, 0x26, 0x8d, 0x68, 0xcf, 0x0f,
	0x7c, 0x39, 0xc2, 0x2e, 0xdc, 0xc9, 0x1a, 0xe9, 0x2a, 0x90, 0xcb, 0x83, 0x2a, 0x5a, 0x9f, 0xab,
	0x97, 0x9d, 0x86, 0x3d, 0xbd, 0x65, 0xfb, 0x4c, 0xc6, 0xde, 0x37, 0x34, 0x72, 0x5b, 0xab, 0x35,
	0xc7, 0x62, 0xc9, 0xa1, 0x55, 0x87, 0x42, 0xf2, 0x1b, 0x17, 0x60, 0xbe, 0x7d, 0x70, 0xb0, 0x5f,
	0xc9, 0xe1, 0x1b, 0x30, 0x77, 0xd0, 0xdc, 0xaf, 0x20, 0xbc, 0x00, 0xff, 0x91, 0x9d, 0xd6, 0xeb,
	0x4e, 0x25, 0x6f, 0x7d, 0x41, 0x80, 0xdb, 0x67, 0x0a, 0x84, 0x7d, 0x1a, 0x30, 0x21, 0xf1, 0x63,
	0x98, 0x0f, 0x79, 0x9f, 0x55, 0xd1, 0x3a, 0xaa, 0x17, 0x9d, 0xbb, 0xc6, 0x14, 0x8d, 0xfc, 0xb1,
	0x8d, 0xf1, 0x34, 0xed, 0x3d, 0xde, 0x67, 0x44, 0x81, 0xf0, 0x2e, 0x80, 0x9b, 0x3a, 0xab, 0xe6,
	0x15, 0xe5, 0xd1, 0xd5, 0xfa, 0x20, 0x19, 0xa6, 0x75, 0x82, 0xa0, 0xbc, 0x63, 0x46, 0xaf, 0x3d,
	0xe1, 0x17, 0x50, 0x48, 0xc2, 0x30, 0x5e, 0xd6, 0xce, 0x7b, 0x49, 0xa3, 0x4a, 0x88, 0x24, 0x25,
	0xe0, 0x16, 0xdc, 0x34, 0xa3, 0x16, 0x92, 0xca, 0x81, 0x50, 0xd6, 0xca, 0x17, 0x15, 0x54, 0x37,
	0xba, 0x5c, 0x47, 0xc1, 0x48, 0xc9, 0xcb, 0x3c, 0x59, 0x1c, 0x96, 0xcf, 0x9b, 0x22, 0x4c, 0x44,
	0x3c, 0x14, 0x0c, 0x7f, 0x80, 0x4a, 0x52, 0x4b, 0x74, 0x35, 0x47, 0xa5, 0x58, 0x74, 0x36, 0x67,
	0x75, 0x7f, 0x41, 0xed, 0x56, 0xaa, 0xa1, 0x0f, 0xac, 0x6f, 0x79, 0xd8, 0x9c, 0x8c, 0xe4, 0x5d,
	0x3c, 0xc5, 0x45, 0x0f, 0x96, 0xce, 0x2d, 0x54, 0xac, 0xf1, 0x66, 0x5c, 0xf6, 0x2c, 0x27, 0x93,
	0x55, 0xda, 0x39, 0x82, 0xbd, 0xc9, 0x75, 0x08, 0xa1, 0x9a, 0xb8, 0x34, 0x8d, 0x76, 0x63, 0x53,
	0xdf, 0xe4, 0xed, 0x5c, 0xa3, 0x63, 0xc3, 0x6c, 0xe7, 0xc8, 0x32, 0xbb, 0xf4, 0xe6, 0x55, 0x19,
	0x4a, 0xa6, 0x8d, 0xae, 0x1c, 0x45, 0xcc, 0xfa, 0x8a, 0x60, 0xf1, 0x2d, 0x77, 0xe9, 0x78, 0x4d,
	0x12, 0x31, 0x81, 0x9f, 0x43, 0x21, 0x30, 0x87, 0xa6, 0xdb, 0xfb, 0x97, 0x44, 0x9b, 0xf0, 0x48,
	0x0a, 0xc6, 0x2f, 0x61, 0x21, 0x1d, 0x7a, 0x35, 0xaf, 0x12, 0xfb, 0xeb, 0x5a, 0x9d, 0x31, 0xac,
	0x5f, 0x08, 0x70, 0x33, 0x18, 0x08, 0xc9, 0xe2, 0xcc, 0x04, 0xf1, 0x03, 0x28, 0xb9, 0xfa, 0xb4,
	0x1b, 0xd2, 0x63, 0xfd, 0xee, 0x2c, 0x90, 0xa2, 0x39, 0xdb, 0xa3, 0xc7, 0x0c, 0x37, 0xd3, 0x8d,
	0x54, 0x59, 0x25, 0xc5, 0x57, 0xa7, 0x6e, 0xa4, 0x4e, 0xa1, 0x94, 0x89, 0x44, 0xe0, 0x37, 0x59,
	0xf7, 0x73, 0x4a, 0xe0, 0xc9, 0xac, 0xe9, 0x4f, 0x0c, 0x2e, 0xdb, 0xcb, 0x0f, 0x04, 0x4b, 0x99,
	0x52, 0x9d, 0x88, 0xb9, 0xfe, 0xa1, 0xcf, 0x62, 0xfc, 0x1e, 0x4a, 0x59, 0xab, 0x66, 0xb1, 0x67,
	0xae, 0xd3, 0xe4, 0x4c, 0x48, 0x31, 0xe3, 0x1c, 0x3f, 0x83, 0x82, 0x1f, 0x4a, 0x16, 0x0f, 0x69,
	0x60, 0xb6, 0xe6, 0x9e, 0xad, 0x3f, 0x9e, 0x76, 0xf2, 0xf1, 0xb4, 0x5b, 0xe6, 0xe3, 0x49, 0x52,
	0xa8, 0x73, 0x9a, 0x87, 0x65, 0xad, 0xd9, 0x4a, 0xaa, 0x75, 0x74, 0x79, 0x7c, 0x82, 0x60, 0xb1,
	0x23, 0x63, 0x46, 0x8f, 0xb3, 0x41, 0xec, 0x5e, 0x6f, 0xe7, 0xa7, 0xbd, 0x59, 0xb5, 0xad, 0x2b,
	0xea, 0xa4, 0x43, 0xb3, 0x72, 0x75, 0xb4, 0x85, 0xf0, 0x4f, 0x04, 0x95, 0x5d, 0x26, 0x5d, 0xef,
	0xdf, 0x30, 0xf5, 0xf0, 0xf3, 0xef, 0xd3, 0x93, 0xfc, 0x9a, 0x55, 0x1b, 0xff, 0xc7, 0xa5, 0xf0,
	0xed, 0x6c, 0xba, 0xdb, 0x68, 0xb3, 0xf7, 0xbf, 0xca, 0xe0, 0xe9, 0x9f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0xcf, 0xc8, 0xea, 0x50, 0x9a, 0x07, 0x00, 0x00,
}
