// Code generated by protoc-gen-go. DO NOT EDIT.
// source: cilium/npds.proto

package cilium

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import envoy_api_v2_core "github.com/cilium/cilium/pkg/envoy/envoy/api/v2/core"
import envoy_api_v2 "github.com/cilium/cilium/pkg/envoy/envoy/api/v2"
import envoy_api_v2_route "github.com/cilium/cilium/pkg/envoy/envoy/api/v2/route"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/lyft/protoc-gen-validate/validate"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// A subset of a network policy that is enforced by a filter on the network
// flows to/from associated hosts.
type NetworkPolicy struct {
	// The unique identifier of a network policy filter.
	// This uniquely identifies the subset of the network policy that is enforced
	// by the filter.
	// Required.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The unique identifier of the network policy this subset is part of.
	// Required.
	Policy uint64 `protobuf:"varint,2,opt,name=policy" json:"policy,omitempty"`
	// The part of the policy to be enforced at ingress by the filter.
	// Optional.
	Ingress *DirectionNetworkPolicy `protobuf:"bytes,3,opt,name=ingress" json:"ingress,omitempty"`
	// The part of the policy to be enforced at egress by the filter.
	// Optional.
	Egress *DirectionNetworkPolicy `protobuf:"bytes,4,opt,name=egress" json:"egress,omitempty"`
}

func (m *NetworkPolicy) Reset()                    { *m = NetworkPolicy{} }
func (m *NetworkPolicy) String() string            { return proto.CompactTextString(m) }
func (*NetworkPolicy) ProtoMessage()               {}
func (*NetworkPolicy) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

func (m *NetworkPolicy) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NetworkPolicy) GetPolicy() uint64 {
	if m != nil {
		return m.Policy
	}
	return 0
}

func (m *NetworkPolicy) GetIngress() *DirectionNetworkPolicy {
	if m != nil {
		return m.Ingress
	}
	return nil
}

func (m *NetworkPolicy) GetEgress() *DirectionNetworkPolicy {
	if m != nil {
		return m.Egress
	}
	return nil
}

// A network policy to be enforced on flows either to or from hosts.
type DirectionNetworkPolicy struct {
	// The set of per-port network policies, one per destination L4 port.
	// Every PortNetworkPolicy element in this set has a unique toPort.
	// Required and may not be empty.
	PerPortPolicies []*PortNetworkPolicy `protobuf:"bytes,1,rep,name=per_port_policies,json=perPortPolicies" json:"per_port_policies,omitempty"`
}

func (m *DirectionNetworkPolicy) Reset()                    { *m = DirectionNetworkPolicy{} }
func (m *DirectionNetworkPolicy) String() string            { return proto.CompactTextString(m) }
func (*DirectionNetworkPolicy) ProtoMessage()               {}
func (*DirectionNetworkPolicy) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *DirectionNetworkPolicy) GetPerPortPolicies() []*PortNetworkPolicy {
	if m != nil {
		return m.PerPortPolicies
	}
	return nil
}

// A network policy to be enforced on flows to a specific destination L4 port.
type PortNetworkPolicy struct {
	// The flows' destination L4 port number, as an unsigned 16-bit integer.
	// Required.
	Port uint32 `protobuf:"varint,1,opt,name=port" json:"port,omitempty"`
	// The flows' L4 transport protocol.
	// Required.
	Protocol envoy_api_v2_core.SocketAddress_Protocol `protobuf:"varint,2,opt,name=protocol,enum=envoy.api.v2.core.SocketAddress_Protocol" json:"protocol,omitempty"`
	// The network policy rules to be enforced on the flows to the port.
	// A flow is allowed if any rule matches it. If no rule matches the flow, it is denied.
	// Required and may not be empty.
	Rules []*PortNetworkPolicyRule `protobuf:"bytes,3,rep,name=rules" json:"rules,omitempty"`
}

func (m *PortNetworkPolicy) Reset()                    { *m = PortNetworkPolicy{} }
func (m *PortNetworkPolicy) String() string            { return proto.CompactTextString(m) }
func (*PortNetworkPolicy) ProtoMessage()               {}
func (*PortNetworkPolicy) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

func (m *PortNetworkPolicy) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *PortNetworkPolicy) GetProtocol() envoy_api_v2_core.SocketAddress_Protocol {
	if m != nil {
		return m.Protocol
	}
	return envoy_api_v2_core.SocketAddress_TCP
}

func (m *PortNetworkPolicy) GetRules() []*PortNetworkPolicyRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// A network policy rule, as a conjunction of predicates on L3-L7 flows.
// If all the predicates of a rule match a flow, the flow is allowed.
type PortNetworkPolicyRule struct {
	// The set of identifiers of policies of remote hosts that are allowed by this rule.
	// This predicate matches a flow if the identifier of the policy applied on the flow's remote
	// host is contained in this set. Required and may not be empty.
	RemotePolicies []uint64 `protobuf:"varint,1,rep,packed,name=remote_policies,json=remotePolicies" json:"remote_policies,omitempty"`
	// Types that are valid to be assigned to L7Rules:
	//	*PortNetworkPolicyRule_HttpRules
	L7Rules isPortNetworkPolicyRule_L7Rules `protobuf_oneof:"l7_rules"`
}

func (m *PortNetworkPolicyRule) Reset()                    { *m = PortNetworkPolicyRule{} }
func (m *PortNetworkPolicyRule) String() string            { return proto.CompactTextString(m) }
func (*PortNetworkPolicyRule) ProtoMessage()               {}
func (*PortNetworkPolicyRule) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

type isPortNetworkPolicyRule_L7Rules interface {
	isPortNetworkPolicyRule_L7Rules()
}

type PortNetworkPolicyRule_HttpRules struct {
	HttpRules *HttpNetworkPolicyRules `protobuf:"bytes,100,opt,name=http_rules,json=httpRules,oneof"`
}

func (*PortNetworkPolicyRule_HttpRules) isPortNetworkPolicyRule_L7Rules() {}

func (m *PortNetworkPolicyRule) GetL7Rules() isPortNetworkPolicyRule_L7Rules {
	if m != nil {
		return m.L7Rules
	}
	return nil
}

func (m *PortNetworkPolicyRule) GetRemotePolicies() []uint64 {
	if m != nil {
		return m.RemotePolicies
	}
	return nil
}

func (m *PortNetworkPolicyRule) GetHttpRules() *HttpNetworkPolicyRules {
	if x, ok := m.GetL7Rules().(*PortNetworkPolicyRule_HttpRules); ok {
		return x.HttpRules
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PortNetworkPolicyRule) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PortNetworkPolicyRule_OneofMarshaler, _PortNetworkPolicyRule_OneofUnmarshaler, _PortNetworkPolicyRule_OneofSizer, []interface{}{
		(*PortNetworkPolicyRule_HttpRules)(nil),
	}
}

func _PortNetworkPolicyRule_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PortNetworkPolicyRule)
	// l7_rules
	switch x := m.L7Rules.(type) {
	case *PortNetworkPolicyRule_HttpRules:
		b.EncodeVarint(100<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HttpRules); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PortNetworkPolicyRule.L7Rules has unexpected type %T", x)
	}
	return nil
}

func _PortNetworkPolicyRule_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PortNetworkPolicyRule)
	switch tag {
	case 100: // l7_rules.http_rules
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HttpNetworkPolicyRules)
		err := b.DecodeMessage(msg)
		m.L7Rules = &PortNetworkPolicyRule_HttpRules{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PortNetworkPolicyRule_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PortNetworkPolicyRule)
	// l7_rules
	switch x := m.L7Rules.(type) {
	case *PortNetworkPolicyRule_HttpRules:
		s := proto.Size(x.HttpRules)
		n += proto.SizeVarint(100<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A set of network policy rules enforced on HTTP requests.
type HttpNetworkPolicyRules struct {
	// The set of HTTP network policy rules.
	// If any rule matches a request, the request is allowed. Otherwise, it is denied.
	// Required and may not be empty.
	HttpRules []*HttpNetworkPolicyRule `protobuf:"bytes,1,rep,name=http_rules,json=httpRules" json:"http_rules,omitempty"`
}

func (m *HttpNetworkPolicyRules) Reset()                    { *m = HttpNetworkPolicyRules{} }
func (m *HttpNetworkPolicyRules) String() string            { return proto.CompactTextString(m) }
func (*HttpNetworkPolicyRules) ProtoMessage()               {}
func (*HttpNetworkPolicyRules) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4} }

func (m *HttpNetworkPolicyRules) GetHttpRules() []*HttpNetworkPolicyRule {
	if m != nil {
		return m.HttpRules
	}
	return nil
}

// An HTTP network policy rule, as a conjunction of predicates on HTTP requests.
// If all the predicates of a rule match an HTTP request, the request is allowed. Otherwise, it is
// denied.
type HttpNetworkPolicyRule struct {
	// A set of matchers on the HTTP request's headers' names and values.
	// If all the matchers in this set match an HTTP request, the request is allowed by this rule.
	// Otherwise, it is denied.
	//
	// Some special header names are:
	//
	// * *:uri*: The HTTP request's URI.
	// * *:method*: The HTTP request's method.
	// * *:authority*: Also maps to the HTTP 1.1 *Host* header.
	//
	// Optional. If empty, matches any HTTP request.
	Headers []*envoy_api_v2_route.HeaderMatcher `protobuf:"bytes,1,rep,name=headers" json:"headers,omitempty"`
}

func (m *HttpNetworkPolicyRule) Reset()                    { *m = HttpNetworkPolicyRule{} }
func (m *HttpNetworkPolicyRule) String() string            { return proto.CompactTextString(m) }
func (*HttpNetworkPolicyRule) ProtoMessage()               {}
func (*HttpNetworkPolicyRule) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{5} }

func (m *HttpNetworkPolicyRule) GetHeaders() []*envoy_api_v2_route.HeaderMatcher {
	if m != nil {
		return m.Headers
	}
	return nil
}

func init() {
	proto.RegisterType((*NetworkPolicy)(nil), "cilium.NetworkPolicy")
	proto.RegisterType((*DirectionNetworkPolicy)(nil), "cilium.DirectionNetworkPolicy")
	proto.RegisterType((*PortNetworkPolicy)(nil), "cilium.PortNetworkPolicy")
	proto.RegisterType((*PortNetworkPolicyRule)(nil), "cilium.PortNetworkPolicyRule")
	proto.RegisterType((*HttpNetworkPolicyRules)(nil), "cilium.HttpNetworkPolicyRules")
	proto.RegisterType((*HttpNetworkPolicyRule)(nil), "cilium.HttpNetworkPolicyRule")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for NetworkPolicyDiscoveryService service

type NetworkPolicyDiscoveryServiceClient interface {
	StreamNetworkPolicies(ctx context.Context, opts ...grpc.CallOption) (NetworkPolicyDiscoveryService_StreamNetworkPoliciesClient, error)
	FetchNetworkPolicies(ctx context.Context, in *envoy_api_v2.DiscoveryRequest, opts ...grpc.CallOption) (*envoy_api_v2.DiscoveryResponse, error)
}

type networkPolicyDiscoveryServiceClient struct {
	cc *grpc.ClientConn
}

func NewNetworkPolicyDiscoveryServiceClient(cc *grpc.ClientConn) NetworkPolicyDiscoveryServiceClient {
	return &networkPolicyDiscoveryServiceClient{cc}
}

func (c *networkPolicyDiscoveryServiceClient) StreamNetworkPolicies(ctx context.Context, opts ...grpc.CallOption) (NetworkPolicyDiscoveryService_StreamNetworkPoliciesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NetworkPolicyDiscoveryService_serviceDesc.Streams[0], c.cc, "/cilium.NetworkPolicyDiscoveryService/StreamNetworkPolicies", opts...)
	if err != nil {
		return nil, err
	}
	x := &networkPolicyDiscoveryServiceStreamNetworkPoliciesClient{stream}
	return x, nil
}

type NetworkPolicyDiscoveryService_StreamNetworkPoliciesClient interface {
	Send(*envoy_api_v2.DiscoveryRequest) error
	Recv() (*envoy_api_v2.DiscoveryResponse, error)
	grpc.ClientStream
}

type networkPolicyDiscoveryServiceStreamNetworkPoliciesClient struct {
	grpc.ClientStream
}

func (x *networkPolicyDiscoveryServiceStreamNetworkPoliciesClient) Send(m *envoy_api_v2.DiscoveryRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *networkPolicyDiscoveryServiceStreamNetworkPoliciesClient) Recv() (*envoy_api_v2.DiscoveryResponse, error) {
	m := new(envoy_api_v2.DiscoveryResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *networkPolicyDiscoveryServiceClient) FetchNetworkPolicies(ctx context.Context, in *envoy_api_v2.DiscoveryRequest, opts ...grpc.CallOption) (*envoy_api_v2.DiscoveryResponse, error) {
	out := new(envoy_api_v2.DiscoveryResponse)
	err := grpc.Invoke(ctx, "/cilium.NetworkPolicyDiscoveryService/FetchNetworkPolicies", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for NetworkPolicyDiscoveryService service

type NetworkPolicyDiscoveryServiceServer interface {
	StreamNetworkPolicies(NetworkPolicyDiscoveryService_StreamNetworkPoliciesServer) error
	FetchNetworkPolicies(context.Context, *envoy_api_v2.DiscoveryRequest) (*envoy_api_v2.DiscoveryResponse, error)
}

func RegisterNetworkPolicyDiscoveryServiceServer(s *grpc.Server, srv NetworkPolicyDiscoveryServiceServer) {
	s.RegisterService(&_NetworkPolicyDiscoveryService_serviceDesc, srv)
}

func _NetworkPolicyDiscoveryService_StreamNetworkPolicies_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NetworkPolicyDiscoveryServiceServer).StreamNetworkPolicies(&networkPolicyDiscoveryServiceStreamNetworkPoliciesServer{stream})
}

type NetworkPolicyDiscoveryService_StreamNetworkPoliciesServer interface {
	Send(*envoy_api_v2.DiscoveryResponse) error
	Recv() (*envoy_api_v2.DiscoveryRequest, error)
	grpc.ServerStream
}

type networkPolicyDiscoveryServiceStreamNetworkPoliciesServer struct {
	grpc.ServerStream
}

func (x *networkPolicyDiscoveryServiceStreamNetworkPoliciesServer) Send(m *envoy_api_v2.DiscoveryResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *networkPolicyDiscoveryServiceStreamNetworkPoliciesServer) Recv() (*envoy_api_v2.DiscoveryRequest, error) {
	m := new(envoy_api_v2.DiscoveryRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _NetworkPolicyDiscoveryService_FetchNetworkPolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(envoy_api_v2.DiscoveryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkPolicyDiscoveryServiceServer).FetchNetworkPolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cilium.NetworkPolicyDiscoveryService/FetchNetworkPolicies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkPolicyDiscoveryServiceServer).FetchNetworkPolicies(ctx, req.(*envoy_api_v2.DiscoveryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _NetworkPolicyDiscoveryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cilium.NetworkPolicyDiscoveryService",
	HandlerType: (*NetworkPolicyDiscoveryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FetchNetworkPolicies",
			Handler:    _NetworkPolicyDiscoveryService_FetchNetworkPolicies_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamNetworkPolicies",
			Handler:       _NetworkPolicyDiscoveryService_StreamNetworkPolicies_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "cilium/npds.proto",
}

func init() { proto.RegisterFile("cilium/npds.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 597 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x94, 0xcf, 0x6e, 0xd3, 0x40,
	0x10, 0xc6, 0xbb, 0x89, 0x9b, 0xa6, 0x53, 0xda, 0xaa, 0x2b, 0x5a, 0x4c, 0x45, 0xd3, 0x60, 0x2e,
	0x69, 0x0f, 0x36, 0x32, 0xe2, 0x8f, 0xca, 0xa1, 0x22, 0x2a, 0x28, 0x17, 0x50, 0x70, 0x39, 0x71,
	0x20, 0x72, 0xed, 0x51, 0xb2, 0x8a, 0xe3, 0x35, 0xeb, 0x8d, 0x51, 0xae, 0x15, 0x4f, 0x50, 0x8e,
	0x3c, 0x03, 0x2f, 0x80, 0x38, 0xf0, 0x0e, 0xbc, 0x02, 0x17, 0x9e, 0xa2, 0xc8, 0x6b, 0x3b, 0xb0,
	0x6a, 0x2a, 0x71, 0xe0, 0x12, 0x79, 0x33, 0xdf, 0xef, 0x9b, 0x9d, 0x99, 0xdd, 0x85, 0xad, 0x80,
	0x45, 0x6c, 0x3a, 0x71, 0xe2, 0x24, 0x4c, 0xed, 0x44, 0x70, 0xc9, 0x69, 0xa3, 0xf8, 0x6b, 0x77,
	0x1f, 0xe3, 0x8c, 0xcf, 0x1c, 0x3f, 0x61, 0x4e, 0xe6, 0x3a, 0x01, 0x17, 0xe8, 0xf8, 0x61, 0x28,
	0x30, 0x2d, 0x85, 0xbb, 0x77, 0x34, 0x41, 0xc8, 0xd2, 0x80, 0x67, 0x28, 0x66, 0x65, 0xb4, 0xa5,
	0x45, 0x05, 0x9f, 0x4a, 0x2c, 0x7e, 0x2b, 0x7a, 0xc8, 0xf9, 0x30, 0x42, 0x25, 0xf0, 0xe3, 0x98,
	0x4b, 0x5f, 0x32, 0x1e, 0x57, 0xde, 0xb7, 0x32, 0x3f, 0x62, 0xa1, 0x2f, 0xd1, 0xa9, 0x3e, 0x8a,
	0x80, 0xf5, 0x85, 0xc0, 0xfa, 0x2b, 0x94, 0x1f, 0xb8, 0x18, 0xf7, 0x79, 0xc4, 0x82, 0x19, 0xa5,
	0x60, 0xc4, 0xfe, 0x04, 0x4d, 0xd2, 0x26, 0x9d, 0x55, 0x4f, 0x7d, 0xd3, 0x1d, 0x68, 0x24, 0x2a,
	0x6a, 0xd6, 0xda, 0xa4, 0x63, 0x78, 0xe5, 0x8a, 0x3e, 0x81, 0x15, 0x16, 0x0f, 0xf3, 0x1a, 0xcc,
	0x7a, 0x9b, 0x74, 0xd6, 0xdc, 0x96, 0x5d, 0x54, 0x6b, 0x9f, 0x30, 0x81, 0x41, 0xbe, 0x03, 0xcd,
	0xdc, 0xab, 0xe4, 0xf4, 0x11, 0x34, 0xb0, 0x00, 0x8d, 0x7f, 0x02, 0x4b, 0xb5, 0x35, 0x86, 0x9d,
	0xc5, 0x0a, 0xfa, 0x1a, 0xb6, 0x12, 0x14, 0x83, 0x84, 0x0b, 0x39, 0x50, 0xdb, 0x63, 0x98, 0x9a,
	0xa4, 0x5d, 0xef, 0xac, 0xb9, 0xb7, 0x2b, 0xf3, 0x3e, 0x17, 0x52, 0xa3, 0xba, 0xf0, 0xf5, 0xd7,
	0xf7, 0xfa, 0xf2, 0x05, 0xa9, 0x35, 0x89, 0xb7, 0x99, 0xa0, 0xc8, 0x15, 0xfd, 0x92, 0xb6, 0xbe,
	0x11, 0xd8, 0xba, 0x82, 0xd0, 0x7d, 0x30, 0xf2, 0x24, 0xaa, 0x41, 0xeb, 0xdd, 0xb5, 0xdc, 0xa0,
	0x71, 0x68, 0x98, 0x97, 0x97, 0x75, 0x4f, 0x05, 0xe8, 0x73, 0x68, 0xaa, 0xe6, 0x06, 0x3c, 0x52,
	0xfd, 0xda, 0x70, 0x0f, 0x6c, 0x35, 0x3d, 0xdb, 0x4f, 0x98, 0x9d, 0xb9, 0x76, 0x3e, 0x7c, 0xfb,
	0x94, 0x07, 0x63, 0x94, 0xcf, 0xca, 0x23, 0xd0, 0x2f, 0x01, 0x6f, 0x8e, 0xd2, 0x63, 0x58, 0x16,
	0xd3, 0x08, 0xf3, 0xd6, 0xe6, 0x45, 0xec, 0x5d, 0x5b, 0x84, 0x37, 0x8d, 0x50, 0x2b, 0xa4, 0xe0,
	0xac, 0xcf, 0x04, 0xb6, 0x17, 0x8a, 0xe9, 0x43, 0xd8, 0x14, 0x38, 0xe1, 0x12, 0xf5, 0x4e, 0x19,
	0xdd, 0x1b, 0xb9, 0xcb, 0xca, 0x05, 0x31, 0x9a, 0xc4, 0x24, 0xde, 0x46, 0x21, 0xaa, 0xfa, 0x41,
	0x8f, 0x01, 0x46, 0x52, 0x26, 0x83, 0x62, 0x5b, 0xa1, 0x3e, 0xb8, 0x9e, 0x94, 0xc9, 0x95, 0x4c,
	0x69, 0x6f, 0xc9, 0x5b, 0xcd, 0x19, 0xb5, 0xe8, 0x02, 0x34, 0xa3, 0xc7, 0x05, 0x6e, 0x9d, 0xc1,
	0xce, 0x62, 0x84, 0xf6, 0xb4, 0x34, 0x44, 0xaf, 0x7e, 0x21, 0xa3, 0x55, 0xff, 0x27, 0x9f, 0xf5,
	0x06, 0xb6, 0x17, 0xea, 0xe9, 0x53, 0x58, 0x19, 0xa1, 0x1f, 0xa2, 0xa8, 0xfc, 0xef, 0xea, 0x13,
	0x2a, 0x6e, 0x56, 0x4f, 0x49, 0x5e, 0xfa, 0x32, 0x18, 0xa1, 0xf0, 0x2a, 0xc2, 0xfd, 0x58, 0x83,
	0x3d, 0xcd, 0xf2, 0xa4, 0xba, 0xab, 0xa7, 0x28, 0x32, 0x16, 0x20, 0x7d, 0x07, 0xdb, 0xa7, 0x52,
	0xa0, 0x3f, 0xf9, 0x5b, 0x96, 0x77, 0xb0, 0xa5, 0xa7, 0x99, 0x83, 0x1e, 0xbe, 0x9f, 0x62, 0x2a,
	0x77, 0xf7, 0xaf, 0x8d, 0xa7, 0x09, 0x8f, 0x53, 0xb4, 0x96, 0x3a, 0xe4, 0x3e, 0xa1, 0xe7, 0x04,
	0x6e, 0xbe, 0x40, 0x19, 0x8c, 0xfe, 0xbb, 0xff, 0xc1, 0xf9, 0x8f, 0x9f, 0x9f, 0x6a, 0xf7, 0xac,
	0x96, 0xf6, 0x06, 0x1d, 0xc5, 0x45, 0x9e, 0xf9, 0x71, 0x39, 0x22, 0x87, 0xdd, 0xe6, 0xdb, 0xf2,
	0x69, 0x3b, 0x6b, 0xa8, 0x33, 0xfb, 0xe0, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x20, 0xca, 0x0e,
	0xc9, 0xfe, 0x04, 0x00, 0x00,
}
