// Code generated by protoc-gen-go. DO NOT EDIT.
// source: cilium/npds.proto

package cilium

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import envoy_api_v2_core1 "github.com/cilium/cilium/pkg/envoy/envoy/api/v2/core"
import envoy_api_v2 "github.com/cilium/cilium/pkg/envoy/envoy/api/v2"
import envoy_api_v2_route "github.com/cilium/cilium/pkg/envoy/envoy/api/v2/route"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/lyft/protoc-gen-validate/validate"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// A network policy that is enforced by a filter on the network flows to/from
// associated hosts.
type NetworkPolicy struct {
	// The unique identifier of the network policy.
	// Required.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The policy identifier associated with the network policy. Corresponds to
	// remote_policies entries in PortNetworkPolicyRule.
	// Required.
	Policy uint64 `protobuf:"varint,2,opt,name=policy" json:"policy,omitempty"`
	// The part of the policy to be enforced at ingress by the filter, as a set
	// of per-port network policies, one per destination L4 port.
	// Every PortNetworkPolicy element in this set has a unique port / protocol
	// combination.
	// Optional. If empty, all flows in this direction are denied.
	IngressPerPortPolicies []*PortNetworkPolicy `protobuf:"bytes,3,rep,name=ingress_per_port_policies,json=ingressPerPortPolicies" json:"ingress_per_port_policies,omitempty"`
	// The part of the policy to be enforced at egress by the filter, as a set
	// of per-port network policies, one per destination L4 port.
	// Every PortNetworkPolicy element in this set has a unique port / protocol
	// combination.
	// Optional. If empty, all flows in this direction are denied.
	EgressPerPortPolicies []*PortNetworkPolicy `protobuf:"bytes,4,rep,name=egress_per_port_policies,json=egressPerPortPolicies" json:"egress_per_port_policies,omitempty"`
}

func (m *NetworkPolicy) Reset()                    { *m = NetworkPolicy{} }
func (m *NetworkPolicy) String() string            { return proto.CompactTextString(m) }
func (*NetworkPolicy) ProtoMessage()               {}
func (*NetworkPolicy) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{0} }

func (m *NetworkPolicy) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NetworkPolicy) GetPolicy() uint64 {
	if m != nil {
		return m.Policy
	}
	return 0
}

func (m *NetworkPolicy) GetIngressPerPortPolicies() []*PortNetworkPolicy {
	if m != nil {
		return m.IngressPerPortPolicies
	}
	return nil
}

func (m *NetworkPolicy) GetEgressPerPortPolicies() []*PortNetworkPolicy {
	if m != nil {
		return m.EgressPerPortPolicies
	}
	return nil
}

// A network policy to whitelist flows to a specific destination L4 port,
// as a conjunction of predicates on L3/L4/L7 flows.
// If all the predicates of a policy match a flow, the flow is whitelisted.
type PortNetworkPolicy struct {
	// The flows' destination L4 port number, as an unsigned 16-bit integer.
	// If 0, all destination L4 port numbers are matched by this predicate.
	Port uint32 `protobuf:"varint,1,opt,name=port" json:"port,omitempty"`
	// The flows' L4 transport protocol.
	// Required.
	Protocol envoy_api_v2_core1.SocketAddress_Protocol `protobuf:"varint,2,opt,name=protocol,enum=envoy.api.v2.core.SocketAddress_Protocol" json:"protocol,omitempty"`
	// The network policy rules to be enforced on the flows to the port.
	// Optional. A flow is matched by this predicate if either the set of
	// rules is empty or any of the rules matches it.
	Rules []*PortNetworkPolicyRule `protobuf:"bytes,3,rep,name=rules" json:"rules,omitempty"`
}

func (m *PortNetworkPolicy) Reset()                    { *m = PortNetworkPolicy{} }
func (m *PortNetworkPolicy) String() string            { return proto.CompactTextString(m) }
func (*PortNetworkPolicy) ProtoMessage()               {}
func (*PortNetworkPolicy) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{1} }

func (m *PortNetworkPolicy) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *PortNetworkPolicy) GetProtocol() envoy_api_v2_core1.SocketAddress_Protocol {
	if m != nil {
		return m.Protocol
	}
	return envoy_api_v2_core1.SocketAddress_TCP
}

func (m *PortNetworkPolicy) GetRules() []*PortNetworkPolicyRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// A network policy rule, as a conjunction of predicates on L3/L7 flows.
// If all the predicates of a rule match a flow, the flow is matched by the
// rule.
type PortNetworkPolicyRule struct {
	// The set of identifiers of policies of remote hosts.
	// A flow is matched by this predicate if the identifier of the policy
	// applied on the flow's remote host is contained in this set.
	// Optional. If not specified, any remote host is matched by this predicate.
	RemotePolicies []uint64 `protobuf:"varint,1,rep,packed,name=remote_policies,json=remotePolicies" json:"remote_policies,omitempty"`
	// Optional. If not specified, any L7 request is matched by this predicate.
	//
	// Types that are valid to be assigned to L7Rules:
	//	*PortNetworkPolicyRule_HttpRules
	//	*PortNetworkPolicyRule_KafkaRules
	L7Rules isPortNetworkPolicyRule_L7Rules `protobuf_oneof:"l7_rules"`
}

func (m *PortNetworkPolicyRule) Reset()                    { *m = PortNetworkPolicyRule{} }
func (m *PortNetworkPolicyRule) String() string            { return proto.CompactTextString(m) }
func (*PortNetworkPolicyRule) ProtoMessage()               {}
func (*PortNetworkPolicyRule) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{2} }

type isPortNetworkPolicyRule_L7Rules interface {
	isPortNetworkPolicyRule_L7Rules()
}

type PortNetworkPolicyRule_HttpRules struct {
	HttpRules *HttpNetworkPolicyRules `protobuf:"bytes,100,opt,name=http_rules,json=httpRules,oneof"`
}
type PortNetworkPolicyRule_KafkaRules struct {
	KafkaRules *KafkaNetworkPolicyRules `protobuf:"bytes,101,opt,name=kafka_rules,json=kafkaRules,oneof"`
}

func (*PortNetworkPolicyRule_HttpRules) isPortNetworkPolicyRule_L7Rules()  {}
func (*PortNetworkPolicyRule_KafkaRules) isPortNetworkPolicyRule_L7Rules() {}

func (m *PortNetworkPolicyRule) GetL7Rules() isPortNetworkPolicyRule_L7Rules {
	if m != nil {
		return m.L7Rules
	}
	return nil
}

func (m *PortNetworkPolicyRule) GetRemotePolicies() []uint64 {
	if m != nil {
		return m.RemotePolicies
	}
	return nil
}

func (m *PortNetworkPolicyRule) GetHttpRules() *HttpNetworkPolicyRules {
	if x, ok := m.GetL7Rules().(*PortNetworkPolicyRule_HttpRules); ok {
		return x.HttpRules
	}
	return nil
}

func (m *PortNetworkPolicyRule) GetKafkaRules() *KafkaNetworkPolicyRules {
	if x, ok := m.GetL7Rules().(*PortNetworkPolicyRule_KafkaRules); ok {
		return x.KafkaRules
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PortNetworkPolicyRule) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PortNetworkPolicyRule_OneofMarshaler, _PortNetworkPolicyRule_OneofUnmarshaler, _PortNetworkPolicyRule_OneofSizer, []interface{}{
		(*PortNetworkPolicyRule_HttpRules)(nil),
		(*PortNetworkPolicyRule_KafkaRules)(nil),
	}
}

func _PortNetworkPolicyRule_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PortNetworkPolicyRule)
	// l7_rules
	switch x := m.L7Rules.(type) {
	case *PortNetworkPolicyRule_HttpRules:
		b.EncodeVarint(100<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HttpRules); err != nil {
			return err
		}
	case *PortNetworkPolicyRule_KafkaRules:
		b.EncodeVarint(101<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.KafkaRules); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PortNetworkPolicyRule.L7Rules has unexpected type %T", x)
	}
	return nil
}

func _PortNetworkPolicyRule_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PortNetworkPolicyRule)
	switch tag {
	case 100: // l7_rules.http_rules
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HttpNetworkPolicyRules)
		err := b.DecodeMessage(msg)
		m.L7Rules = &PortNetworkPolicyRule_HttpRules{msg}
		return true, err
	case 101: // l7_rules.kafka_rules
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KafkaNetworkPolicyRules)
		err := b.DecodeMessage(msg)
		m.L7Rules = &PortNetworkPolicyRule_KafkaRules{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PortNetworkPolicyRule_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PortNetworkPolicyRule)
	// l7_rules
	switch x := m.L7Rules.(type) {
	case *PortNetworkPolicyRule_HttpRules:
		s := proto.Size(x.HttpRules)
		n += proto.SizeVarint(100<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PortNetworkPolicyRule_KafkaRules:
		s := proto.Size(x.KafkaRules)
		n += proto.SizeVarint(101<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A set of network policy rules that match HTTP requests.
type HttpNetworkPolicyRules struct {
	// The set of HTTP network policy rules.
	// An HTTP request is matched if any of its rules matches the request.
	// Required and may not be empty.
	HttpRules []*HttpNetworkPolicyRule `protobuf:"bytes,1,rep,name=http_rules,json=httpRules" json:"http_rules,omitempty"`
}

func (m *HttpNetworkPolicyRules) Reset()                    { *m = HttpNetworkPolicyRules{} }
func (m *HttpNetworkPolicyRules) String() string            { return proto.CompactTextString(m) }
func (*HttpNetworkPolicyRules) ProtoMessage()               {}
func (*HttpNetworkPolicyRules) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{3} }

func (m *HttpNetworkPolicyRules) GetHttpRules() []*HttpNetworkPolicyRule {
	if m != nil {
		return m.HttpRules
	}
	return nil
}

// An HTTP network policy rule, as a conjunction of predicates on HTTP requests.
// If all the predicates of a rule match an HTTP request, the request is allowed. Otherwise, it is
// denied.
type HttpNetworkPolicyRule struct {
	// A set of matchers on the HTTP request's headers' names and values.
	// If all the matchers in this set match an HTTP request, the request is allowed by this rule.
	// Otherwise, it is denied.
	//
	// Some special header names are:
	//
	// * *:uri*: The HTTP request's URI.
	// * *:method*: The HTTP request's method.
	// * *:authority*: Also maps to the HTTP 1.1 *Host* header.
	//
	// Optional. If empty, matches any HTTP request.
	Headers []*envoy_api_v2_route.HeaderMatcher `protobuf:"bytes,1,rep,name=headers" json:"headers,omitempty"`
}

func (m *HttpNetworkPolicyRule) Reset()                    { *m = HttpNetworkPolicyRule{} }
func (m *HttpNetworkPolicyRule) String() string            { return proto.CompactTextString(m) }
func (*HttpNetworkPolicyRule) ProtoMessage()               {}
func (*HttpNetworkPolicyRule) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{4} }

func (m *HttpNetworkPolicyRule) GetHeaders() []*envoy_api_v2_route.HeaderMatcher {
	if m != nil {
		return m.Headers
	}
	return nil
}

// A set of network policy rules that match Kafka requests.
type KafkaNetworkPolicyRules struct {
	// The set of Kafka network policy rules.
	// A Kafka request is matched if any of its rules matches the request.
	// Required and may not be empty.
	KafkaRules []*KafkaNetworkPolicyRule `protobuf:"bytes,1,rep,name=kafka_rules,json=kafkaRules" json:"kafka_rules,omitempty"`
}

func (m *KafkaNetworkPolicyRules) Reset()                    { *m = KafkaNetworkPolicyRules{} }
func (m *KafkaNetworkPolicyRules) String() string            { return proto.CompactTextString(m) }
func (*KafkaNetworkPolicyRules) ProtoMessage()               {}
func (*KafkaNetworkPolicyRules) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{5} }

func (m *KafkaNetworkPolicyRules) GetKafkaRules() []*KafkaNetworkPolicyRule {
	if m != nil {
		return m.KafkaRules
	}
	return nil
}

// A Kafka network policy rule, as a conjunction of predicates on Kafka requests.
// If all the predicates of a rule match a Kafka request, the request is allowed. Otherwise, it is
// denied.
type KafkaNetworkPolicyRule struct {
	// The Kafka request's API key.
	// If <0, all Kafka requests are matched by this predicate.
	ApiKey int32 `protobuf:"varint,1,opt,name=api_key,json=apiKey" json:"api_key,omitempty"`
	// The Kafka request's API version.
	// If <0, all Kafka requests are matched by this predicate.
	ApiVersion int32 `protobuf:"varint,2,opt,name=api_version,json=apiVersion" json:"api_version,omitempty"`
	// The Kafka request's topic.
	// Optional. If not specified, all Kafka requests are matched by this predicate.
	// If specified, this predicates only matches requests that contain this topic, and never
	// matches requests that don't contain any topic.
	Topic string `protobuf:"bytes,3,opt,name=topic" json:"topic,omitempty"`
	// The Kafka request's client ID.
	// Optional. If not specified, all Kafka requests are matched by this predicate.
	// If specified, this predicates only matches requests that contain this client ID, and never
	// matches requests that don't contain any client ID.
	ClientId string `protobuf:"bytes,4,opt,name=client_id,json=clientId" json:"client_id,omitempty"`
}

func (m *KafkaNetworkPolicyRule) Reset()                    { *m = KafkaNetworkPolicyRule{} }
func (m *KafkaNetworkPolicyRule) String() string            { return proto.CompactTextString(m) }
func (*KafkaNetworkPolicyRule) ProtoMessage()               {}
func (*KafkaNetworkPolicyRule) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{6} }

func (m *KafkaNetworkPolicyRule) GetApiKey() int32 {
	if m != nil {
		return m.ApiKey
	}
	return 0
}

func (m *KafkaNetworkPolicyRule) GetApiVersion() int32 {
	if m != nil {
		return m.ApiVersion
	}
	return 0
}

func (m *KafkaNetworkPolicyRule) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *KafkaNetworkPolicyRule) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func init() {
	proto.RegisterType((*NetworkPolicy)(nil), "cilium.NetworkPolicy")
	proto.RegisterType((*PortNetworkPolicy)(nil), "cilium.PortNetworkPolicy")
	proto.RegisterType((*PortNetworkPolicyRule)(nil), "cilium.PortNetworkPolicyRule")
	proto.RegisterType((*HttpNetworkPolicyRules)(nil), "cilium.HttpNetworkPolicyRules")
	proto.RegisterType((*HttpNetworkPolicyRule)(nil), "cilium.HttpNetworkPolicyRule")
	proto.RegisterType((*KafkaNetworkPolicyRules)(nil), "cilium.KafkaNetworkPolicyRules")
	proto.RegisterType((*KafkaNetworkPolicyRule)(nil), "cilium.KafkaNetworkPolicyRule")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for NetworkPolicyDiscoveryService service

type NetworkPolicyDiscoveryServiceClient interface {
	StreamNetworkPolicies(ctx context.Context, opts ...grpc.CallOption) (NetworkPolicyDiscoveryService_StreamNetworkPoliciesClient, error)
	FetchNetworkPolicies(ctx context.Context, in *envoy_api_v2.DiscoveryRequest, opts ...grpc.CallOption) (*envoy_api_v2.DiscoveryResponse, error)
}

type networkPolicyDiscoveryServiceClient struct {
	cc *grpc.ClientConn
}

func NewNetworkPolicyDiscoveryServiceClient(cc *grpc.ClientConn) NetworkPolicyDiscoveryServiceClient {
	return &networkPolicyDiscoveryServiceClient{cc}
}

func (c *networkPolicyDiscoveryServiceClient) StreamNetworkPolicies(ctx context.Context, opts ...grpc.CallOption) (NetworkPolicyDiscoveryService_StreamNetworkPoliciesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NetworkPolicyDiscoveryService_serviceDesc.Streams[0], c.cc, "/cilium.NetworkPolicyDiscoveryService/StreamNetworkPolicies", opts...)
	if err != nil {
		return nil, err
	}
	x := &networkPolicyDiscoveryServiceStreamNetworkPoliciesClient{stream}
	return x, nil
}

type NetworkPolicyDiscoveryService_StreamNetworkPoliciesClient interface {
	Send(*envoy_api_v2.DiscoveryRequest) error
	Recv() (*envoy_api_v2.DiscoveryResponse, error)
	grpc.ClientStream
}

type networkPolicyDiscoveryServiceStreamNetworkPoliciesClient struct {
	grpc.ClientStream
}

func (x *networkPolicyDiscoveryServiceStreamNetworkPoliciesClient) Send(m *envoy_api_v2.DiscoveryRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *networkPolicyDiscoveryServiceStreamNetworkPoliciesClient) Recv() (*envoy_api_v2.DiscoveryResponse, error) {
	m := new(envoy_api_v2.DiscoveryResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *networkPolicyDiscoveryServiceClient) FetchNetworkPolicies(ctx context.Context, in *envoy_api_v2.DiscoveryRequest, opts ...grpc.CallOption) (*envoy_api_v2.DiscoveryResponse, error) {
	out := new(envoy_api_v2.DiscoveryResponse)
	err := grpc.Invoke(ctx, "/cilium.NetworkPolicyDiscoveryService/FetchNetworkPolicies", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for NetworkPolicyDiscoveryService service

type NetworkPolicyDiscoveryServiceServer interface {
	StreamNetworkPolicies(NetworkPolicyDiscoveryService_StreamNetworkPoliciesServer) error
	FetchNetworkPolicies(context.Context, *envoy_api_v2.DiscoveryRequest) (*envoy_api_v2.DiscoveryResponse, error)
}

func RegisterNetworkPolicyDiscoveryServiceServer(s *grpc.Server, srv NetworkPolicyDiscoveryServiceServer) {
	s.RegisterService(&_NetworkPolicyDiscoveryService_serviceDesc, srv)
}

func _NetworkPolicyDiscoveryService_StreamNetworkPolicies_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NetworkPolicyDiscoveryServiceServer).StreamNetworkPolicies(&networkPolicyDiscoveryServiceStreamNetworkPoliciesServer{stream})
}

type NetworkPolicyDiscoveryService_StreamNetworkPoliciesServer interface {
	Send(*envoy_api_v2.DiscoveryResponse) error
	Recv() (*envoy_api_v2.DiscoveryRequest, error)
	grpc.ServerStream
}

type networkPolicyDiscoveryServiceStreamNetworkPoliciesServer struct {
	grpc.ServerStream
}

func (x *networkPolicyDiscoveryServiceStreamNetworkPoliciesServer) Send(m *envoy_api_v2.DiscoveryResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *networkPolicyDiscoveryServiceStreamNetworkPoliciesServer) Recv() (*envoy_api_v2.DiscoveryRequest, error) {
	m := new(envoy_api_v2.DiscoveryRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _NetworkPolicyDiscoveryService_FetchNetworkPolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(envoy_api_v2.DiscoveryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkPolicyDiscoveryServiceServer).FetchNetworkPolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cilium.NetworkPolicyDiscoveryService/FetchNetworkPolicies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkPolicyDiscoveryServiceServer).FetchNetworkPolicies(ctx, req.(*envoy_api_v2.DiscoveryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _NetworkPolicyDiscoveryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cilium.NetworkPolicyDiscoveryService",
	HandlerType: (*NetworkPolicyDiscoveryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FetchNetworkPolicies",
			Handler:    _NetworkPolicyDiscoveryService_FetchNetworkPolicies_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamNetworkPolicies",
			Handler:       _NetworkPolicyDiscoveryService_StreamNetworkPolicies_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "cilium/npds.proto",
}

func init() { proto.RegisterFile("cilium/npds.proto", fileDescriptor3) }

var fileDescriptor3 = []byte{
	// 713 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0xcd, 0x6e, 0xd3, 0x48,
	0x1c, 0xef, 0xe4, 0xab, 0xe9, 0x44, 0xed, 0xaa, 0xb3, 0x9b, 0xd4, 0x8d, 0xb6, 0x49, 0xd6, 0xcb,
	0x21, 0xad, 0x14, 0xa7, 0x4a, 0x0f, 0x15, 0xe5, 0x80, 0x1a, 0x01, 0x0a, 0xaa, 0x40, 0x91, 0x5b,
	0x71, 0x00, 0xd1, 0x68, 0x6a, 0xff, 0xdb, 0x8c, 0xe2, 0x78, 0xcc, 0x78, 0x12, 0x14, 0x8e, 0x15,
	0x4f, 0x00, 0x2f, 0xc2, 0x99, 0x53, 0xdf, 0x81, 0x33, 0x37, 0x38, 0xf0, 0x14, 0x45, 0x1e, 0xdb,
	0x69, 0xad, 0x3a, 0x70, 0xe1, 0x12, 0x65, 0xfc, 0xfb, 0xf8, 0x7f, 0xce, 0xe0, 0x75, 0x8b, 0x39,
	0x6c, 0x32, 0x6e, 0xbb, 0x9e, 0xed, 0x1b, 0x9e, 0xe0, 0x92, 0x93, 0x42, 0xf8, 0xa9, 0x5a, 0x07,
	0x77, 0xca, 0x67, 0x6d, 0xea, 0xb1, 0xf6, 0xb4, 0xd3, 0xb6, 0xb8, 0x80, 0x36, 0xb5, 0x6d, 0x01,
	0x7e, 0x44, 0xac, 0xfe, 0x9b, 0x20, 0xd8, 0xcc, 0xb7, 0xf8, 0x14, 0xc4, 0x2c, 0x42, 0x6b, 0x09,
	0x54, 0xf0, 0x89, 0x84, 0xf0, 0x37, 0x56, 0x5f, 0x70, 0x7e, 0xe1, 0x80, 0x22, 0x50, 0xd7, 0xe5,
	0x92, 0x4a, 0xc6, 0xdd, 0xd8, 0x7b, 0x63, 0x4a, 0x1d, 0x66, 0x53, 0x09, 0xed, 0xf8, 0x4f, 0x08,
	0xe8, 0xdf, 0x11, 0x5e, 0x7d, 0x0e, 0xf2, 0x2d, 0x17, 0xa3, 0x3e, 0x77, 0x98, 0x35, 0x23, 0x04,
	0xe7, 0x5c, 0x3a, 0x06, 0x0d, 0x35, 0x50, 0x73, 0xc5, 0x54, 0xff, 0x49, 0x05, 0x17, 0x3c, 0x85,
	0x6a, 0x99, 0x06, 0x6a, 0xe6, 0xcc, 0xe8, 0x44, 0x4e, 0xf0, 0x26, 0x73, 0x2f, 0x82, 0x1a, 0x06,
	0x1e, 0x88, 0x81, 0xc7, 0x85, 0x1c, 0x28, 0x88, 0x81, 0xaf, 0x65, 0x1b, 0xd9, 0x66, 0xa9, 0xb3,
	0x69, 0x84, 0xf5, 0x1b, 0x7d, 0x2e, 0x64, 0x22, 0x92, 0x59, 0x89, 0xb4, 0x7d, 0x10, 0x01, 0xd8,
	0x8f, 0x84, 0xc4, 0xc4, 0x1a, 0x2c, 0x32, 0xcd, 0xfd, 0xce, 0xb4, 0x0c, 0x69, 0x9e, 0xfa, 0x27,
	0x84, 0xd7, 0xef, 0x90, 0x49, 0x1d, 0xe7, 0x02, 0x7b, 0x55, 0xeb, 0x6a, 0xb7, 0xf4, 0xf9, 0xc7,
	0x55, 0xb6, 0xb0, 0x93, 0xd3, 0xae, 0xaf, 0xb3, 0xa6, 0x02, 0xc8, 0x63, 0x5c, 0x54, 0x7d, 0xb2,
	0xb8, 0xa3, 0x4a, 0x5f, 0xeb, 0x6c, 0x1b, 0x6a, 0x10, 0x06, 0xf5, 0x98, 0x31, 0xed, 0x18, 0xc1,
	0x1c, 0x8d, 0x63, 0x6e, 0x8d, 0x40, 0x1e, 0x46, 0xd3, 0xec, 0x47, 0x02, 0x73, 0x2e, 0x25, 0x7b,
	0x38, 0x2f, 0x26, 0xce, 0xbc, 0x27, 0x5b, 0x8b, 0xd3, 0x9f, 0x38, 0x60, 0x86, 0x5c, 0xfd, 0x2b,
	0xc2, 0xe5, 0x54, 0x02, 0xd9, 0xc3, 0x7f, 0x09, 0x18, 0x73, 0x09, 0x37, 0x7d, 0x41, 0x8d, 0x6c,
	0x33, 0xd7, 0xc5, 0x41, 0x05, 0xf9, 0x0f, 0x28, 0xa3, 0x21, 0x73, 0x2d, 0xa4, 0xcc, 0xbb, 0xfa,
	0x10, 0xe3, 0xa1, 0x94, 0xde, 0x20, 0x4c, 0xc4, 0x6e, 0xa0, 0x66, 0xa9, 0x53, 0x8b, 0x13, 0xe9,
	0x49, 0xe9, 0xdd, 0x89, 0xe3, 0xf7, 0x96, 0xcc, 0x95, 0x40, 0xa3, 0x0e, 0xa4, 0x8b, 0x4b, 0x23,
	0x7a, 0x3e, 0xa2, 0x91, 0x03, 0x28, 0x87, 0x7a, 0xec, 0x70, 0x14, 0x40, 0xa9, 0x16, 0x58, 0xa9,
	0xd4, 0xa9, 0x8b, 0x71, 0xd1, 0xd9, 0x0f, 0x0d, 0xf4, 0x33, 0x5c, 0x49, 0x0f, 0x4b, 0x7a, 0x89,
	0x54, 0x51, 0xb2, 0x67, 0xa9, 0x9a, 0x9b, 0xca, 0x8b, 0xe8, 0x56, 0xce, 0xfa, 0x09, 0x2e, 0xa7,
	0xf2, 0xc9, 0x03, 0xbc, 0x3c, 0x04, 0x6a, 0x83, 0x88, 0xfd, 0xff, 0x4b, 0xce, 0x35, 0xbc, 0x5a,
	0x3d, 0x45, 0x79, 0x46, 0xa5, 0x35, 0x04, 0x61, 0xc6, 0x0a, 0xfd, 0x1c, 0x6f, 0x2c, 0x28, 0x97,
	0x1c, 0x25, 0x9b, 0x14, 0x7a, 0xd7, 0x7e, 0xdd, 0xa4, 0x44, 0xf2, 0xb7, 0xba, 0xa5, 0x5f, 0x21,
	0x5c, 0x49, 0x97, 0x90, 0x0d, 0xbc, 0x4c, 0x3d, 0x36, 0x18, 0xc1, 0x4c, 0x2d, 0x6f, 0xde, 0x2c,
	0x50, 0x8f, 0x1d, 0x41, 0xb0, 0xd2, 0xa5, 0x00, 0x98, 0x82, 0xf0, 0x19, 0x77, 0xd5, 0xd2, 0xe6,
	0x4d, 0x4c, 0x3d, 0xf6, 0x22, 0xfc, 0x12, 0xec, 0xa2, 0xe4, 0x1e, 0xb3, 0xb4, 0x6c, 0x70, 0xc1,
	0xbb, 0x5b, 0x41, 0x6c, 0x4d, 0x54, 0xb4, 0x6b, 0xd4, 0x59, 0x3f, 0x7d, 0x45, 0x5b, 0xef, 0x0e,
	0x5b, 0x2f, 0x77, 0x5b, 0xf7, 0x8d, 0x41, 0xeb, 0xf5, 0xce, 0x3d, 0x33, 0xe4, 0x92, 0x7d, 0xbc,
	0x62, 0x39, 0x0c, 0x5c, 0x39, 0x60, 0xb6, 0x96, 0x53, 0xc2, 0x6a, 0x20, 0x2c, 0x8b, 0xbf, 0xd3,
	0x54, 0xc5, 0x90, 0xfc, 0xd4, 0xee, 0xbc, 0xcf, 0xe0, 0xad, 0x44, 0xf6, 0x8f, 0xe2, 0x77, 0xed,
	0x18, 0xc4, 0x94, 0x59, 0x40, 0x4e, 0x71, 0xf9, 0x58, 0x0a, 0xa0, 0xe3, 0xdb, 0xb4, 0x60, 0x61,
	0x6b, 0xc9, 0x89, 0xcc, 0x85, 0x26, 0xbc, 0x99, 0x80, 0x2f, 0xab, 0xf5, 0x85, 0xb8, 0xef, 0x71,
	0xd7, 0x07, 0x7d, 0xa9, 0x89, 0x76, 0x11, 0xb9, 0x44, 0xf8, 0x9f, 0x27, 0x20, 0xad, 0xe1, 0x1f,
	0xf7, 0xdf, 0xbe, 0xfc, 0xf2, 0xed, 0x63, 0xe6, 0x7f, 0xbd, 0x96, 0x78, 0xaf, 0x0f, 0xdc, 0x30,
	0xce, 0xfc, 0x6e, 0x1e, 0xa0, 0x9d, 0xb3, 0x82, 0x7a, 0x0a, 0xf6, 0x7e, 0x06, 0x00, 0x00, 0xff,
	0xff, 0xb4, 0x6f, 0x74, 0x2e, 0x20, 0x06, 0x00, 0x00,
}
