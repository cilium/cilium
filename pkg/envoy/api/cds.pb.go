// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api/cds.proto

package envoy_api_v2

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf2 "github.com/golang/protobuf/ptypes/duration"
import google_protobuf "github.com/golang/protobuf/ptypes/wrappers"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// The service discovery type to use for resolving the cluster.
type Cluster_DiscoveryType int32

const (
	Cluster_STATIC       Cluster_DiscoveryType = 0
	Cluster_STRICT_DNS   Cluster_DiscoveryType = 1
	Cluster_LOGICAL_DNS  Cluster_DiscoveryType = 2
	Cluster_EDS          Cluster_DiscoveryType = 3
	Cluster_ORIGINAL_DST Cluster_DiscoveryType = 4
)

var Cluster_DiscoveryType_name = map[int32]string{
	0: "STATIC",
	1: "STRICT_DNS",
	2: "LOGICAL_DNS",
	3: "EDS",
	4: "ORIGINAL_DST",
}
var Cluster_DiscoveryType_value = map[string]int32{
	"STATIC":       0,
	"STRICT_DNS":   1,
	"LOGICAL_DNS":  2,
	"EDS":          3,
	"ORIGINAL_DST": 4,
}

func (x Cluster_DiscoveryType) String() string {
	return proto.EnumName(Cluster_DiscoveryType_name, int32(x))
}
func (Cluster_DiscoveryType) EnumDescriptor() ([]byte, []int) { return fileDescriptor5, []int{2, 0} }

// The load balancer type to use when picking a host in the cluster.
type Cluster_LbPolicy int32

const (
	Cluster_ROUND_ROBIN     Cluster_LbPolicy = 0
	Cluster_LEAST_REQUEST   Cluster_LbPolicy = 1
	Cluster_RING_HASH       Cluster_LbPolicy = 2
	Cluster_RANDOM          Cluster_LbPolicy = 3
	Cluster_ORIGINAL_DST_LB Cluster_LbPolicy = 4
)

var Cluster_LbPolicy_name = map[int32]string{
	0: "ROUND_ROBIN",
	1: "LEAST_REQUEST",
	2: "RING_HASH",
	3: "RANDOM",
	4: "ORIGINAL_DST_LB",
}
var Cluster_LbPolicy_value = map[string]int32{
	"ROUND_ROBIN":     0,
	"LEAST_REQUEST":   1,
	"RING_HASH":       2,
	"RANDOM":          3,
	"ORIGINAL_DST_LB": 4,
}

func (x Cluster_LbPolicy) String() string {
	return proto.EnumName(Cluster_LbPolicy_name, int32(x))
}
func (Cluster_LbPolicy) EnumDescriptor() ([]byte, []int) { return fileDescriptor5, []int{2, 1} }

// The DNS IP address resolution policy. The options are v4_only, v6_only, and
// auto. If this setting is not specified, the value defaults to v4_only. When
// v4_only is selected, the DNS resolver will only perform a lookup for
// addresses in the IPv4 family. If v6_only is selected, the DNS resolver will
// only perform a lookup for addresses in the IPv6 family. If auto is
// specified, the DNS resolver will first perform a lookup for addresses in
// the IPv6 family and fallback to a lookup for addresses in the IPv4 family.
// For cluster types other than strict_dns and logical_dns, this setting is
// ignored.
type Cluster_DnsLookupFamily int32

const (
	Cluster_AUTO    Cluster_DnsLookupFamily = 0
	Cluster_V4_ONLY Cluster_DnsLookupFamily = 1
	Cluster_V6_ONLY Cluster_DnsLookupFamily = 2
)

var Cluster_DnsLookupFamily_name = map[int32]string{
	0: "AUTO",
	1: "V4_ONLY",
	2: "V6_ONLY",
}
var Cluster_DnsLookupFamily_value = map[string]int32{
	"AUTO":    0,
	"V4_ONLY": 1,
	"V6_ONLY": 2,
}

func (x Cluster_DnsLookupFamily) String() string {
	return proto.EnumName(Cluster_DnsLookupFamily_name, int32(x))
}
func (Cluster_DnsLookupFamily) EnumDescriptor() ([]byte, []int) { return fileDescriptor5, []int{2, 2} }

// An extensible structure containing the address Envoy should bind to when establishing upstream
// connections.
type UpstreamBindConfig struct {
	// The address Envoy should bind to when establishing upstream connections.
	SourceAddress *Address `protobuf:"bytes,1,opt,name=source_address,json=sourceAddress" json:"source_address,omitempty"`
}

func (m *UpstreamBindConfig) Reset()                    { *m = UpstreamBindConfig{} }
func (m *UpstreamBindConfig) String() string            { return proto.CompactTextString(m) }
func (*UpstreamBindConfig) ProtoMessage()               {}
func (*UpstreamBindConfig) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{0} }

func (m *UpstreamBindConfig) GetSourceAddress() *Address {
	if m != nil {
		return m.SourceAddress
	}
	return nil
}

// Circuit breaking settings can be specified individually for each defined
// priority.
type CircuitBreakers struct {
	Thresholds []*CircuitBreakers_Thresholds `protobuf:"bytes,1,rep,name=thresholds" json:"thresholds,omitempty"`
}

func (m *CircuitBreakers) Reset()                    { *m = CircuitBreakers{} }
func (m *CircuitBreakers) String() string            { return proto.CompactTextString(m) }
func (*CircuitBreakers) ProtoMessage()               {}
func (*CircuitBreakers) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{1} }

func (m *CircuitBreakers) GetThresholds() []*CircuitBreakers_Thresholds {
	if m != nil {
		return m.Thresholds
	}
	return nil
}

type CircuitBreakers_Thresholds struct {
	Priority RoutingPriority `protobuf:"varint,1,opt,name=priority,enum=envoy.api.v2.RoutingPriority" json:"priority,omitempty"`
	// The maximum number of connections that Envoy will make to the upstream
	// cluster. If not specified, the default is 1024. See the circuit
	// breaking overview for more information.
	MaxConnections *google_protobuf.UInt32Value `protobuf:"bytes,2,opt,name=max_connections,json=maxConnections" json:"max_connections,omitempty"`
	// The maximum number of pending requests that Envoy will allow to the
	// upstream cluster. If not specified, the default is 1024. See the circuit
	// breaking overview for more information.
	MaxPendingRequests *google_protobuf.UInt32Value `protobuf:"bytes,3,opt,name=max_pending_requests,json=maxPendingRequests" json:"max_pending_requests,omitempty"`
	// The maximum number of parallel requests that Envoy will make to the
	// upstream cluster. If not specified, the default is 1024. See the circuit
	// breaking overview for more information.
	MaxRequests *google_protobuf.UInt32Value `protobuf:"bytes,4,opt,name=max_requests,json=maxRequests" json:"max_requests,omitempty"`
	// The maximum number of parallel retries that Envoy will allow to the
	// upstream cluster. If not specified, the default is 3. See the circuit
	// breaking overview for more information.
	MaxRetries *google_protobuf.UInt32Value `protobuf:"bytes,5,opt,name=max_retries,json=maxRetries" json:"max_retries,omitempty"`
}

func (m *CircuitBreakers_Thresholds) Reset()                    { *m = CircuitBreakers_Thresholds{} }
func (m *CircuitBreakers_Thresholds) String() string            { return proto.CompactTextString(m) }
func (*CircuitBreakers_Thresholds) ProtoMessage()               {}
func (*CircuitBreakers_Thresholds) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{1, 0} }

func (m *CircuitBreakers_Thresholds) GetPriority() RoutingPriority {
	if m != nil {
		return m.Priority
	}
	return RoutingPriority_DEFAULT
}

func (m *CircuitBreakers_Thresholds) GetMaxConnections() *google_protobuf.UInt32Value {
	if m != nil {
		return m.MaxConnections
	}
	return nil
}

func (m *CircuitBreakers_Thresholds) GetMaxPendingRequests() *google_protobuf.UInt32Value {
	if m != nil {
		return m.MaxPendingRequests
	}
	return nil
}

func (m *CircuitBreakers_Thresholds) GetMaxRequests() *google_protobuf.UInt32Value {
	if m != nil {
		return m.MaxRequests
	}
	return nil
}

func (m *CircuitBreakers_Thresholds) GetMaxRetries() *google_protobuf.UInt32Value {
	if m != nil {
		return m.MaxRetries
	}
	return nil
}

type Cluster struct {
	// Supplies the name of the cluster which must be unique across all clusters.
	// The cluster name is used when emitting statistics. The cluster name can be
	// at most 60 characters long, and must not contain :.
	Name             string                    `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Type             Cluster_DiscoveryType     `protobuf:"varint,2,opt,name=type,enum=envoy.api.v2.Cluster_DiscoveryType" json:"type,omitempty"`
	EdsClusterConfig *Cluster_EdsClusterConfig `protobuf:"bytes,3,opt,name=eds_cluster_config,json=edsClusterConfig" json:"eds_cluster_config,omitempty"`
	// The timeout for new network connections to hosts in the cluster.
	ConnectTimeout *google_protobuf2.Duration `protobuf:"bytes,4,opt,name=connect_timeout,json=connectTimeout" json:"connect_timeout,omitempty"`
	// Soft limit on size of the clusterâ€™s connections read and write buffers. If
	// unspecified, an implementation defined default is applied (1MiB).
	PerConnectionBufferLimitBytes *google_protobuf.UInt32Value `protobuf:"bytes,5,opt,name=per_connection_buffer_limit_bytes,json=perConnectionBufferLimitBytes" json:"per_connection_buffer_limit_bytes,omitempty"`
	LbPolicy                      Cluster_LbPolicy             `protobuf:"varint,6,opt,name=lb_policy,json=lbPolicy,enum=envoy.api.v2.Cluster_LbPolicy" json:"lb_policy,omitempty"`
	// If the service discovery type is static, strict_dns or logical_dns, then
	// hosts is required.
	Hosts []*Address `protobuf:"bytes,7,rep,name=hosts" json:"hosts,omitempty"`
	// Optional active health checking configuration for the cluster. If no
	// configuration is specified no health checking will be done and all cluster
	// members will be considered healthy at all times.
	HealthChecks []*HealthCheck `protobuf:"bytes,8,rep,name=health_checks,json=healthChecks" json:"health_checks,omitempty"`
	// Optional maximum requests for a single upstream connection. This parameter
	// is respected by both the HTTP/1.1 and HTTP/2 connection pool
	// implementations. If not specified, there is no limit. Setting this
	// parameter to 1 will effectively disable keep alive.
	MaxRequestsPerConnection *google_protobuf.UInt32Value `protobuf:"bytes,9,opt,name=max_requests_per_connection,json=maxRequestsPerConnection" json:"max_requests_per_connection,omitempty"`
	// Optional circuit breaking settings for the cluster.
	CircuitBreakers *CircuitBreakers `protobuf:"bytes,10,opt,name=circuit_breakers,json=circuitBreakers" json:"circuit_breakers,omitempty"`
	// The TLS configuration for connections to the upstream cluster. If no TLS
	// configuration is specified, TLS will not be used for new connections.
	TlsContext *UpstreamTlsContext `protobuf:"bytes,11,opt,name=tls_context,json=tlsContext" json:"tls_context,omitempty"`
	// Types that are valid to be assigned to ProtocolOptions:
	//	*Cluster_TcpProtocolOptions
	//	*Cluster_HttpProtocolOptions
	//	*Cluster_Http2ProtocolOptions
	//	*Cluster_GrpcProtocolOptions
	ProtocolOptions isCluster_ProtocolOptions `protobuf_oneof:"protocol_options"`
	// If the dns refresh rate is specified and the cluster type is either
	// strict_dns, or logical_dns, this value is used as the clusterâ€™s dns refresh
	// rate. If this setting is not specified, the value defaults to 5000. For
	// cluster types other than strict_dns and logical_dns this setting is
	// ignored.
	DnsRefreshRate  *google_protobuf2.Duration `protobuf:"bytes,16,opt,name=dns_refresh_rate,json=dnsRefreshRate" json:"dns_refresh_rate,omitempty"`
	DnsLookupFamily Cluster_DnsLookupFamily    `protobuf:"varint,17,opt,name=dns_lookup_family,json=dnsLookupFamily,enum=envoy.api.v2.Cluster_DnsLookupFamily" json:"dns_lookup_family,omitempty"`
	// If DNS resolvers are specified and the cluster type is either strict_dns,
	// or logical_dns, this value is used to specify the clusterâ€™s dns resolvers.
	// If this setting is not specified, the value defaults to the default
	// resolver, which uses /etc/resolv.conf for configuration. For cluster types
	// other than strict_dns and logical_dns this setting is ignored.
	DnsResolvers     []*Address                `protobuf:"bytes,18,rep,name=dns_resolvers,json=dnsResolvers" json:"dns_resolvers,omitempty"`
	OutlierDetection *Cluster_OutlierDetection `protobuf:"bytes,19,opt,name=outlier_detection,json=outlierDetection" json:"outlier_detection,omitempty"`
	// The interval for removing stale hosts from a cluster type
	// original_dst.  Hosts are considered stale if they have not been used
	// as upstream destinations during this interval.  New hosts are added
	// to original destination clusters on demand as new connections are
	// redirected to Envoy, causing the number of hosts in the cluster to
	// grow over time.  Hosts that are not stale (they are actively used as
	// destinations) are kept in the cluster, which allows connections to
	// them remain open, saving the latency that would otherwise be spent
	// on opening new connections.  If this setting is not specified, the
	// value defaults to 5000ms. For cluster types other than original_dst
	// this setting is ignored.
	CleanupInterval *google_protobuf2.Duration `protobuf:"bytes,20,opt,name=cleanup_interval,json=cleanupInterval" json:"cleanup_interval,omitempty"`
	// Optional configuration used to bind newly established upstream connections.
	// This overrides any bind_config specified in the bootstrap proto.
	// If the addres and port are empty, no bind will be performed.
	UpstreamBindConfig *BindConfig `protobuf:"bytes,21,opt,name=upstream_bind_config,json=upstreamBindConfig" json:"upstream_bind_config,omitempty"`
	// Cluster can operate both HTTP1.1 and HTTP2 connections and the protocol
	// is chosen based on the downstream protocol, if any.  In case there is no
	// downstream connection, this option will be ignored.
	AutoHttp2 bool `protobuf:"varint,25,opt,name=auto_http2,json=autoHttp2" json:"auto_http2,omitempty"`
}

func (m *Cluster) Reset()                    { *m = Cluster{} }
func (m *Cluster) String() string            { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()               {}
func (*Cluster) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{2} }

type isCluster_ProtocolOptions interface {
	isCluster_ProtocolOptions()
}

type Cluster_TcpProtocolOptions struct {
	TcpProtocolOptions *TcpProtocolOptions `protobuf:"bytes,12,opt,name=tcp_protocol_options,json=tcpProtocolOptions,oneof"`
}
type Cluster_HttpProtocolOptions struct {
	HttpProtocolOptions *Http1ProtocolOptions `protobuf:"bytes,13,opt,name=http_protocol_options,json=httpProtocolOptions,oneof"`
}
type Cluster_Http2ProtocolOptions struct {
	Http2ProtocolOptions *Http2ProtocolOptions `protobuf:"bytes,14,opt,name=http2_protocol_options,json=http2ProtocolOptions,oneof"`
}
type Cluster_GrpcProtocolOptions struct {
	GrpcProtocolOptions *GrpcProtocolOptions `protobuf:"bytes,15,opt,name=grpc_protocol_options,json=grpcProtocolOptions,oneof"`
}

func (*Cluster_TcpProtocolOptions) isCluster_ProtocolOptions()   {}
func (*Cluster_HttpProtocolOptions) isCluster_ProtocolOptions()  {}
func (*Cluster_Http2ProtocolOptions) isCluster_ProtocolOptions() {}
func (*Cluster_GrpcProtocolOptions) isCluster_ProtocolOptions()  {}

func (m *Cluster) GetProtocolOptions() isCluster_ProtocolOptions {
	if m != nil {
		return m.ProtocolOptions
	}
	return nil
}

func (m *Cluster) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Cluster) GetType() Cluster_DiscoveryType {
	if m != nil {
		return m.Type
	}
	return Cluster_STATIC
}

func (m *Cluster) GetEdsClusterConfig() *Cluster_EdsClusterConfig {
	if m != nil {
		return m.EdsClusterConfig
	}
	return nil
}

func (m *Cluster) GetConnectTimeout() *google_protobuf2.Duration {
	if m != nil {
		return m.ConnectTimeout
	}
	return nil
}

func (m *Cluster) GetPerConnectionBufferLimitBytes() *google_protobuf.UInt32Value {
	if m != nil {
		return m.PerConnectionBufferLimitBytes
	}
	return nil
}

func (m *Cluster) GetLbPolicy() Cluster_LbPolicy {
	if m != nil {
		return m.LbPolicy
	}
	return Cluster_ROUND_ROBIN
}

func (m *Cluster) GetHosts() []*Address {
	if m != nil {
		return m.Hosts
	}
	return nil
}

func (m *Cluster) GetHealthChecks() []*HealthCheck {
	if m != nil {
		return m.HealthChecks
	}
	return nil
}

func (m *Cluster) GetMaxRequestsPerConnection() *google_protobuf.UInt32Value {
	if m != nil {
		return m.MaxRequestsPerConnection
	}
	return nil
}

func (m *Cluster) GetCircuitBreakers() *CircuitBreakers {
	if m != nil {
		return m.CircuitBreakers
	}
	return nil
}

func (m *Cluster) GetTlsContext() *UpstreamTlsContext {
	if m != nil {
		return m.TlsContext
	}
	return nil
}

func (m *Cluster) GetTcpProtocolOptions() *TcpProtocolOptions {
	if x, ok := m.GetProtocolOptions().(*Cluster_TcpProtocolOptions); ok {
		return x.TcpProtocolOptions
	}
	return nil
}

func (m *Cluster) GetHttpProtocolOptions() *Http1ProtocolOptions {
	if x, ok := m.GetProtocolOptions().(*Cluster_HttpProtocolOptions); ok {
		return x.HttpProtocolOptions
	}
	return nil
}

func (m *Cluster) GetHttp2ProtocolOptions() *Http2ProtocolOptions {
	if x, ok := m.GetProtocolOptions().(*Cluster_Http2ProtocolOptions); ok {
		return x.Http2ProtocolOptions
	}
	return nil
}

func (m *Cluster) GetGrpcProtocolOptions() *GrpcProtocolOptions {
	if x, ok := m.GetProtocolOptions().(*Cluster_GrpcProtocolOptions); ok {
		return x.GrpcProtocolOptions
	}
	return nil
}

func (m *Cluster) GetDnsRefreshRate() *google_protobuf2.Duration {
	if m != nil {
		return m.DnsRefreshRate
	}
	return nil
}

func (m *Cluster) GetDnsLookupFamily() Cluster_DnsLookupFamily {
	if m != nil {
		return m.DnsLookupFamily
	}
	return Cluster_AUTO
}

func (m *Cluster) GetDnsResolvers() []*Address {
	if m != nil {
		return m.DnsResolvers
	}
	return nil
}

func (m *Cluster) GetOutlierDetection() *Cluster_OutlierDetection {
	if m != nil {
		return m.OutlierDetection
	}
	return nil
}

func (m *Cluster) GetCleanupInterval() *google_protobuf2.Duration {
	if m != nil {
		return m.CleanupInterval
	}
	return nil
}

func (m *Cluster) GetUpstreamBindConfig() *BindConfig {
	if m != nil {
		return m.UpstreamBindConfig
	}
	return nil
}

func (m *Cluster) GetAutoHttp2() bool {
	if m != nil {
		return m.AutoHttp2
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Cluster) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Cluster_OneofMarshaler, _Cluster_OneofUnmarshaler, _Cluster_OneofSizer, []interface{}{
		(*Cluster_TcpProtocolOptions)(nil),
		(*Cluster_HttpProtocolOptions)(nil),
		(*Cluster_Http2ProtocolOptions)(nil),
		(*Cluster_GrpcProtocolOptions)(nil),
	}
}

func _Cluster_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Cluster)
	// protocol_options
	switch x := m.ProtocolOptions.(type) {
	case *Cluster_TcpProtocolOptions:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TcpProtocolOptions); err != nil {
			return err
		}
	case *Cluster_HttpProtocolOptions:
		b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HttpProtocolOptions); err != nil {
			return err
		}
	case *Cluster_Http2ProtocolOptions:
		b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Http2ProtocolOptions); err != nil {
			return err
		}
	case *Cluster_GrpcProtocolOptions:
		b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GrpcProtocolOptions); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Cluster.ProtocolOptions has unexpected type %T", x)
	}
	return nil
}

func _Cluster_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Cluster)
	switch tag {
	case 12: // protocol_options.tcp_protocol_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TcpProtocolOptions)
		err := b.DecodeMessage(msg)
		m.ProtocolOptions = &Cluster_TcpProtocolOptions{msg}
		return true, err
	case 13: // protocol_options.http_protocol_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Http1ProtocolOptions)
		err := b.DecodeMessage(msg)
		m.ProtocolOptions = &Cluster_HttpProtocolOptions{msg}
		return true, err
	case 14: // protocol_options.http2_protocol_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Http2ProtocolOptions)
		err := b.DecodeMessage(msg)
		m.ProtocolOptions = &Cluster_Http2ProtocolOptions{msg}
		return true, err
	case 15: // protocol_options.grpc_protocol_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GrpcProtocolOptions)
		err := b.DecodeMessage(msg)
		m.ProtocolOptions = &Cluster_GrpcProtocolOptions{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Cluster_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Cluster)
	// protocol_options
	switch x := m.ProtocolOptions.(type) {
	case *Cluster_TcpProtocolOptions:
		s := proto.Size(x.TcpProtocolOptions)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Cluster_HttpProtocolOptions:
		s := proto.Size(x.HttpProtocolOptions)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Cluster_Http2ProtocolOptions:
		s := proto.Size(x.Http2ProtocolOptions)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Cluster_GrpcProtocolOptions:
		s := proto.Size(x.GrpcProtocolOptions)
		n += proto.SizeVarint(15<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Only valid when discovery type is EDS.
type Cluster_EdsClusterConfig struct {
	EdsConfig *ConfigSource `protobuf:"bytes,1,opt,name=eds_config,json=edsConfig" json:"eds_config,omitempty"`
	// Optional alternative to cluster name to present to EDS. This does not
	// have the same restrictions as cluster name, i.e. it may be arbritary
	// length and contain ':'.
	ServiceName string `protobuf:"bytes,2,opt,name=service_name,json=serviceName" json:"service_name,omitempty"`
}

func (m *Cluster_EdsClusterConfig) Reset()                    { *m = Cluster_EdsClusterConfig{} }
func (m *Cluster_EdsClusterConfig) String() string            { return proto.CompactTextString(m) }
func (*Cluster_EdsClusterConfig) ProtoMessage()               {}
func (*Cluster_EdsClusterConfig) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{2, 0} }

func (m *Cluster_EdsClusterConfig) GetEdsConfig() *ConfigSource {
	if m != nil {
		return m.EdsConfig
	}
	return nil
}

func (m *Cluster_EdsClusterConfig) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

// If specified, outlier detection will be enabled for this upstream cluster.
type Cluster_OutlierDetection struct {
	// The number of consecutive 5xx responses before a consecutive 5xx ejection
	// occurs. Defaults to 5.
	Consecutive_5Xx *google_protobuf.UInt32Value `protobuf:"bytes,1,opt,name=consecutive_5xx,json=consecutive5xx" json:"consecutive_5xx,omitempty"`
	// The time interval between ejection analysis sweeps. This can result in
	// both new ejections as well as hosts being returned to service. Defaults
	// to 10000ms or 10s.
	Interval *google_protobuf2.Duration `protobuf:"bytes,2,opt,name=interval" json:"interval,omitempty"`
	// The base time that a host is ejected for. The real time is equal to the
	// base time multiplied by the number of times the host has been ejected.
	// Defaults to 30000ms or 30s.
	BaseEjectionTime *google_protobuf2.Duration `protobuf:"bytes,3,opt,name=base_ejection_time,json=baseEjectionTime" json:"base_ejection_time,omitempty"`
	// The maximum % of an upstream cluster that can be ejected due to outlier
	// detection. Defaults to 10%.
	MaxEjectionPercent *google_protobuf.UInt32Value `protobuf:"bytes,4,opt,name=max_ejection_percent,json=maxEjectionPercent" json:"max_ejection_percent,omitempty"`
	// The % chance that a host will be actually ejected when an outlier status
	// is detected through consecutive 5xx. This setting can be used to disable
	// ejection or to ramp it up slowly. Defaults to 100.
	EnforcingConsecutive_5Xx *google_protobuf.UInt32Value `protobuf:"bytes,5,opt,name=enforcing_consecutive_5xx,json=enforcingConsecutive5xx" json:"enforcing_consecutive_5xx,omitempty"`
	// The % chance that a host will be actually ejected when an outlier status
	// is detected through success rate statistics. This setting can be used to
	// disable ejection or to ramp it up slowly. Defaults to 100.
	EnforcingSuccessRate *google_protobuf.UInt32Value `protobuf:"bytes,6,opt,name=enforcing_success_rate,json=enforcingSuccessRate" json:"enforcing_success_rate,omitempty"`
	// The number of hosts in a cluster that must have enough request volume to
	// detect success rate outliers. If the number of hosts is less than this
	// setting, outlier detection via success rate statistics is not performed
	// for any host in the cluster. Defaults to 5.
	SuccessRateMinimumHosts *google_protobuf.UInt32Value `protobuf:"bytes,7,opt,name=success_rate_minimum_hosts,json=successRateMinimumHosts" json:"success_rate_minimum_hosts,omitempty"`
	// The minimum number of total requests that must be collected in one
	// interval (as defined by the interval duration above) to include this host
	// in success rate based outlier detection. If the volume is lower than this
	// setting, outlier detection via success rate statistics is not performed
	// for that host. Defaults to 100.
	SuccessRateRequestVolume *google_protobuf.UInt32Value `protobuf:"bytes,8,opt,name=success_rate_request_volume,json=successRateRequestVolume" json:"success_rate_request_volume,omitempty"`
	// This factor is used to determine the ejection threshold for success rate
	// outlier ejection. The ejection threshold is the difference between the
	// mean success rate, and the product of this factor and the standard
	// deviation of the mean success rate: mean - (stdev *
	// success_rate_stdev_factor). This factor is divided by a thousand to get a
	// double. That is, if the desired factor is 1.9, the runtime value should
	// be 1900. Defaults to 1900.
	SuccessRateStdevFactor *google_protobuf.UInt32Value `protobuf:"bytes,9,opt,name=success_rate_stdev_factor,json=successRateStdevFactor" json:"success_rate_stdev_factor,omitempty"`
}

func (m *Cluster_OutlierDetection) Reset()                    { *m = Cluster_OutlierDetection{} }
func (m *Cluster_OutlierDetection) String() string            { return proto.CompactTextString(m) }
func (*Cluster_OutlierDetection) ProtoMessage()               {}
func (*Cluster_OutlierDetection) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{2, 1} }

func (m *Cluster_OutlierDetection) GetConsecutive_5Xx() *google_protobuf.UInt32Value {
	if m != nil {
		return m.Consecutive_5Xx
	}
	return nil
}

func (m *Cluster_OutlierDetection) GetInterval() *google_protobuf2.Duration {
	if m != nil {
		return m.Interval
	}
	return nil
}

func (m *Cluster_OutlierDetection) GetBaseEjectionTime() *google_protobuf2.Duration {
	if m != nil {
		return m.BaseEjectionTime
	}
	return nil
}

func (m *Cluster_OutlierDetection) GetMaxEjectionPercent() *google_protobuf.UInt32Value {
	if m != nil {
		return m.MaxEjectionPercent
	}
	return nil
}

func (m *Cluster_OutlierDetection) GetEnforcingConsecutive_5Xx() *google_protobuf.UInt32Value {
	if m != nil {
		return m.EnforcingConsecutive_5Xx
	}
	return nil
}

func (m *Cluster_OutlierDetection) GetEnforcingSuccessRate() *google_protobuf.UInt32Value {
	if m != nil {
		return m.EnforcingSuccessRate
	}
	return nil
}

func (m *Cluster_OutlierDetection) GetSuccessRateMinimumHosts() *google_protobuf.UInt32Value {
	if m != nil {
		return m.SuccessRateMinimumHosts
	}
	return nil
}

func (m *Cluster_OutlierDetection) GetSuccessRateRequestVolume() *google_protobuf.UInt32Value {
	if m != nil {
		return m.SuccessRateRequestVolume
	}
	return nil
}

func (m *Cluster_OutlierDetection) GetSuccessRateStdevFactor() *google_protobuf.UInt32Value {
	if m != nil {
		return m.SuccessRateStdevFactor
	}
	return nil
}

func init() {
	proto.RegisterType((*UpstreamBindConfig)(nil), "envoy.api.v2.UpstreamBindConfig")
	proto.RegisterType((*CircuitBreakers)(nil), "envoy.api.v2.CircuitBreakers")
	proto.RegisterType((*CircuitBreakers_Thresholds)(nil), "envoy.api.v2.CircuitBreakers.Thresholds")
	proto.RegisterType((*Cluster)(nil), "envoy.api.v2.Cluster")
	proto.RegisterType((*Cluster_EdsClusterConfig)(nil), "envoy.api.v2.Cluster.EdsClusterConfig")
	proto.RegisterType((*Cluster_OutlierDetection)(nil), "envoy.api.v2.Cluster.OutlierDetection")
	proto.RegisterEnum("envoy.api.v2.Cluster_DiscoveryType", Cluster_DiscoveryType_name, Cluster_DiscoveryType_value)
	proto.RegisterEnum("envoy.api.v2.Cluster_LbPolicy", Cluster_LbPolicy_name, Cluster_LbPolicy_value)
	proto.RegisterEnum("envoy.api.v2.Cluster_DnsLookupFamily", Cluster_DnsLookupFamily_name, Cluster_DnsLookupFamily_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ClusterDiscoveryService service

type ClusterDiscoveryServiceClient interface {
	StreamClusters(ctx context.Context, opts ...grpc.CallOption) (ClusterDiscoveryService_StreamClustersClient, error)
	FetchClusters(ctx context.Context, in *DiscoveryRequest, opts ...grpc.CallOption) (*DiscoveryResponse, error)
}

type clusterDiscoveryServiceClient struct {
	cc *grpc.ClientConn
}

func NewClusterDiscoveryServiceClient(cc *grpc.ClientConn) ClusterDiscoveryServiceClient {
	return &clusterDiscoveryServiceClient{cc}
}

func (c *clusterDiscoveryServiceClient) StreamClusters(ctx context.Context, opts ...grpc.CallOption) (ClusterDiscoveryService_StreamClustersClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ClusterDiscoveryService_serviceDesc.Streams[0], c.cc, "/envoy.api.v2.ClusterDiscoveryService/StreamClusters", opts...)
	if err != nil {
		return nil, err
	}
	x := &clusterDiscoveryServiceStreamClustersClient{stream}
	return x, nil
}

type ClusterDiscoveryService_StreamClustersClient interface {
	Send(*DiscoveryRequest) error
	Recv() (*DiscoveryResponse, error)
	grpc.ClientStream
}

type clusterDiscoveryServiceStreamClustersClient struct {
	grpc.ClientStream
}

func (x *clusterDiscoveryServiceStreamClustersClient) Send(m *DiscoveryRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *clusterDiscoveryServiceStreamClustersClient) Recv() (*DiscoveryResponse, error) {
	m := new(DiscoveryResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *clusterDiscoveryServiceClient) FetchClusters(ctx context.Context, in *DiscoveryRequest, opts ...grpc.CallOption) (*DiscoveryResponse, error) {
	out := new(DiscoveryResponse)
	err := grpc.Invoke(ctx, "/envoy.api.v2.ClusterDiscoveryService/FetchClusters", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ClusterDiscoveryService service

type ClusterDiscoveryServiceServer interface {
	StreamClusters(ClusterDiscoveryService_StreamClustersServer) error
	FetchClusters(context.Context, *DiscoveryRequest) (*DiscoveryResponse, error)
}

func RegisterClusterDiscoveryServiceServer(s *grpc.Server, srv ClusterDiscoveryServiceServer) {
	s.RegisterService(&_ClusterDiscoveryService_serviceDesc, srv)
}

func _ClusterDiscoveryService_StreamClusters_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ClusterDiscoveryServiceServer).StreamClusters(&clusterDiscoveryServiceStreamClustersServer{stream})
}

type ClusterDiscoveryService_StreamClustersServer interface {
	Send(*DiscoveryResponse) error
	Recv() (*DiscoveryRequest, error)
	grpc.ServerStream
}

type clusterDiscoveryServiceStreamClustersServer struct {
	grpc.ServerStream
}

func (x *clusterDiscoveryServiceStreamClustersServer) Send(m *DiscoveryResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *clusterDiscoveryServiceStreamClustersServer) Recv() (*DiscoveryRequest, error) {
	m := new(DiscoveryRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ClusterDiscoveryService_FetchClusters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiscoveryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterDiscoveryServiceServer).FetchClusters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/envoy.api.v2.ClusterDiscoveryService/FetchClusters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterDiscoveryServiceServer).FetchClusters(ctx, req.(*DiscoveryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ClusterDiscoveryService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "envoy.api.v2.ClusterDiscoveryService",
	HandlerType: (*ClusterDiscoveryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FetchClusters",
			Handler:    _ClusterDiscoveryService_FetchClusters_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamClusters",
			Handler:       _ClusterDiscoveryService_StreamClusters_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "api/cds.proto",
}

func init() { proto.RegisterFile("api/cds.proto", fileDescriptor5) }

var fileDescriptor5 = []byte{
	// 1455 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x96, 0x5b, 0x73, 0xdb, 0x36,
	0x16, 0xc7, 0x2d, 0xd9, 0xb1, 0xe5, 0x23, 0x4b, 0xa2, 0x11, 0xdb, 0xa1, 0x95, 0x38, 0x1b, 0x6b,
	0x67, 0x77, 0x3c, 0xbb, 0x33, 0xf2, 0xae, 0xb2, 0xde, 0x4e, 0xd2, 0xdb, 0xe8, 0xe2, 0xd8, 0xea,
	0x28, 0x92, 0x03, 0xc9, 0x71, 0xd2, 0xcc, 0x14, 0x43, 0x91, 0x90, 0xc4, 0x86, 0x22, 0x59, 0x02,
	0x54, 0xa5, 0xd7, 0x3e, 0xf7, 0xad, 0x5f, 0xa7, 0xdf, 0xa2, 0xef, 0x7d, 0xea, 0x4c, 0xfb, 0x31,
	0x3a, 0x00, 0x21, 0x59, 0x17, 0x5f, 0xf4, 0xd0, 0x37, 0xe2, 0xe0, 0xfc, 0x7f, 0x04, 0xff, 0x04,
	0xce, 0x01, 0xa4, 0x0c, 0xdf, 0x3e, 0x36, 0x2d, 0x96, 0xf7, 0x03, 0x8f, 0x7b, 0x68, 0x8b, 0xba,
	0x03, 0x6f, 0x94, 0x37, 0x7c, 0x3b, 0x3f, 0x28, 0x64, 0xb7, 0xc5, 0xa4, 0x61, 0x59, 0x01, 0x65,
	0x2a, 0x21, 0x9b, 0x16, 0xa1, 0xb6, 0xc1, 0xa8, 0x1a, 0xef, 0x89, 0x71, 0x8f, 0x1a, 0x0e, 0xef,
	0x11, 0xb3, 0x47, 0xcd, 0x8f, 0x2a, 0x8e, 0x44, 0x5c, 0x3e, 0x9a, 0x9e, 0xa3, 0x62, 0xbb, 0x22,
	0xc6, 0x1d, 0x46, 0x4c, 0xcf, 0xe5, 0x74, 0xc8, 0x55, 0xf8, 0x49, 0xd7, 0xf3, 0xba, 0x0e, 0x3d,
	0x96, 0x2f, 0x73, 0x5d, 0x8f, 0x1b, 0xdc, 0xf6, 0xdc, 0xf1, 0x0b, 0x9f, 0xaa, 0x59, 0x39, 0x6a,
	0x87, 0x9d, 0x63, 0x2b, 0x0c, 0x64, 0xc2, 0x6d, 0xf3, 0xdf, 0x07, 0x86, 0xef, 0xd3, 0x40, 0xe9,
	0x73, 0x18, 0xd0, 0xa5, 0xcf, 0x78, 0x40, 0x8d, 0x7e, 0xc9, 0x76, 0xad, 0xb2, 0xe7, 0x76, 0xec,
	0x2e, 0xfa, 0x0c, 0xd2, 0xcc, 0x0b, 0x03, 0x93, 0x12, 0xf5, 0x79, 0x7a, 0xec, 0x59, 0xec, 0x28,
	0x59, 0xd8, 0xcd, 0x4f, 0x1b, 0x90, 0x2f, 0x46, 0x93, 0x38, 0x15, 0x25, 0xab, 0x61, 0xee, 0xe7,
	0x55, 0xc8, 0x94, 0xed, 0xc0, 0x0c, 0x6d, 0x5e, 0x0a, 0xa8, 0xf1, 0x91, 0x06, 0x0c, 0x9d, 0x03,
	0xf0, 0x5e, 0x40, 0x59, 0xcf, 0x73, 0x2c, 0x41, 0x5b, 0x3d, 0x4a, 0x16, 0x8e, 0x66, 0x69, 0x73,
	0x92, 0x7c, 0x6b, 0x92, 0x8f, 0xa7, 0xb4, 0xd9, 0x5f, 0xe3, 0x00, 0xd7, 0x53, 0xe8, 0x05, 0x24,
	0xfc, 0xc0, 0xf6, 0x02, 0x9b, 0x8f, 0xe4, 0x22, 0xd3, 0x85, 0x83, 0x59, 0x2c, 0xf6, 0x42, 0x6e,
	0xbb, 0xdd, 0x0b, 0x95, 0x84, 0x27, 0xe9, 0xe8, 0x14, 0x32, 0x7d, 0x63, 0x28, 0xec, 0x76, 0xa9,
	0x29, 0x4d, 0xd5, 0xe3, 0xf2, 0x33, 0x9f, 0xe4, 0x23, 0xd7, 0xf2, 0x63, 0xd7, 0xf2, 0x97, 0x55,
	0x97, 0x3f, 0x2f, 0xbc, 0x35, 0x9c, 0x90, 0xe2, 0x74, 0xdf, 0x18, 0x96, 0xaf, 0x35, 0xa8, 0x0e,
	0x3b, 0x02, 0xe3, 0x53, 0xd7, 0xb2, 0xdd, 0x2e, 0x09, 0xe8, 0x77, 0x21, 0x65, 0x9c, 0xe9, 0xab,
	0x4b, 0xb0, 0x50, 0xdf, 0x18, 0x5e, 0x44, 0x42, 0xac, 0x74, 0xe8, 0x4b, 0xd8, 0x12, 0xbc, 0x09,
	0x67, 0x6d, 0x09, 0x4e, 0xb2, 0x6f, 0x0c, 0x27, 0x80, 0xcf, 0x21, 0x19, 0x01, 0x78, 0x60, 0x53,
	0xa6, 0x3f, 0x58, 0x42, 0x0f, 0x52, 0x2f, 0xf3, 0x73, 0x3f, 0xee, 0xc2, 0x46, 0xd9, 0x09, 0x19,
	0xa7, 0x01, 0x42, 0xb0, 0xe6, 0x1a, 0x7d, 0x2a, 0x9d, 0xdd, 0xc4, 0xf2, 0x19, 0x7d, 0x02, 0x6b,
	0x7c, 0xe4, 0x53, 0xe9, 0x55, 0xba, 0xf0, 0xf7, 0xb9, 0x9f, 0x18, 0x09, 0xf3, 0x15, 0x9b, 0x99,
	0xde, 0x80, 0x06, 0xa3, 0xd6, 0xc8, 0xa7, 0x58, 0x0a, 0x50, 0x0b, 0x10, 0xb5, 0x18, 0x31, 0xa3,
	0x14, 0xe1, 0x7b, 0xc7, 0xee, 0x2a, 0x9b, 0xfe, 0x79, 0x33, 0xe6, 0xd4, 0x62, 0xea, 0x31, 0xda,
	0x99, 0x58, 0xa3, 0x73, 0x11, 0x54, 0x82, 0x8c, 0xfa, 0x83, 0x84, 0xdb, 0x7d, 0xea, 0x85, 0x5c,
	0x39, 0xb6, 0xbf, 0xf0, 0xc5, 0x15, 0x75, 0x36, 0x70, 0x5a, 0x29, 0x5a, 0x91, 0x00, 0x75, 0xe0,
	0xd0, 0x8f, 0x56, 0xa4, 0xfe, 0x2a, 0x69, 0x87, 0x9d, 0x0e, 0x0d, 0x88, 0x63, 0xf7, 0x6d, 0x4e,
	0xda, 0x23, 0xbe, 0xa4, 0x8f, 0x07, 0xbe, 0x5c, 0x97, 0xa2, 0x94, 0x24, 0xa4, 0x26, 0x18, 0x25,
	0x81, 0x40, 0x9f, 0xc2, 0xa6, 0xd3, 0x26, 0xbe, 0xe7, 0xd8, 0xe6, 0x48, 0x5f, 0x97, 0xfe, 0x3d,
	0xbd, 0xf9, 0xc3, 0x6b, 0xed, 0x0b, 0x99, 0x85, 0x13, 0x8e, 0x7a, 0x42, 0xff, 0x86, 0x07, 0x3d,
	0x4f, 0x6c, 0x88, 0x0d, 0x79, 0x7a, 0x6e, 0x39, 0x8b, 0x51, 0x0e, 0xfa, 0x02, 0x52, 0xd3, 0x65,
	0x87, 0xe9, 0x09, 0x29, 0xda, 0x9f, 0x15, 0x9d, 0xcb, 0x94, 0xb2, 0xc8, 0xc0, 0x5b, 0xbd, 0xeb,
	0x01, 0x43, 0x1f, 0xe0, 0xf1, 0xf4, 0x26, 0x24, 0xb3, 0xf6, 0xe8, 0x9b, 0x4b, 0x78, 0xa1, 0x4f,
	0xed, 0xc9, 0x8b, 0x69, 0x5b, 0xd0, 0x39, 0x68, 0x66, 0x74, 0xd8, 0x49, 0x5b, 0x9d, 0x76, 0x1d,
	0x24, 0xf1, 0xe0, 0xce, 0x92, 0x80, 0x33, 0xe6, 0x5c, 0x59, 0x29, 0x42, 0x72, 0xaa, 0x62, 0xea,
	0x49, 0x09, 0x79, 0x36, 0x0b, 0x19, 0xd7, 0xb7, 0x96, 0xc3, 0xca, 0x51, 0x1e, 0x06, 0x3e, 0x79,
	0x46, 0x2d, 0xd8, 0xe1, 0xa6, 0x4f, 0xc6, 0xc5, 0x98, 0x78, 0x7e, 0x54, 0x0a, 0xb6, 0x6e, 0x62,
	0xb5, 0x4c, 0xff, 0x42, 0x25, 0x36, 0xa2, 0xbc, 0xf3, 0x15, 0x8c, 0xf8, 0x42, 0x14, 0xbd, 0x83,
	0xdd, 0x1e, 0xe7, 0x37, 0x60, 0x53, 0x12, 0x9b, 0x9b, 0xfb, 0x0f, 0x9c, 0xfb, 0xff, 0x5d, 0x04,
	0x3f, 0x14, 0x88, 0x79, 0xf2, 0xd7, 0xb0, 0x27, 0xc2, 0x85, 0x45, 0x74, 0xfa, 0x36, 0x74, 0x61,
	0x11, 0xbd, 0xd3, 0xbb, 0x21, 0x8e, 0xae, 0x60, 0xb7, 0x1b, 0xf8, 0xe6, 0x22, 0x3a, 0x23, 0xd1,
	0x87, 0xb3, 0xe8, 0xb3, 0xc0, 0x37, 0x6f, 0x58, 0x74, 0x77, 0x31, 0x8c, 0xca, 0xa0, 0x59, 0x2e,
	0x23, 0x01, 0xed, 0x88, 0xc2, 0x4d, 0x02, 0x83, 0x53, 0x5d, 0xbb, 0xf7, 0x94, 0x5a, 0x2e, 0xc3,
	0x91, 0x02, 0x1b, 0x9c, 0xa2, 0x37, 0xb0, 0x2d, 0x20, 0x8e, 0xe7, 0x7d, 0x0c, 0x7d, 0xd2, 0x31,
	0xfa, 0xb6, 0x33, 0xd2, 0xb7, 0xe5, 0x29, 0xfa, 0xc7, 0x2d, 0x55, 0xc8, 0x65, 0x35, 0x99, 0xfd,
	0x4a, 0x26, 0xe3, 0x8c, 0x35, 0x1b, 0x40, 0x2f, 0x21, 0x15, 0xad, 0x8b, 0x79, 0xce, 0x40, 0x6c,
	0x43, 0x74, 0xd7, 0xd9, 0xda, 0x92, 0x0b, 0x52, 0xa9, 0xa8, 0x09, 0xdb, 0x5e, 0xc8, 0x1d, 0x9b,
	0x06, 0xc4, 0xa2, 0x5c, 0x1d, 0x8c, 0x87, 0x77, 0x55, 0xb3, 0x46, 0x94, 0x5e, 0x19, 0x67, 0x63,
	0xcd, 0x9b, 0x8b, 0xa0, 0x0a, 0x68, 0xa6, 0x43, 0x0d, 0x37, 0xf4, 0x89, 0xed, 0x72, 0x1a, 0x0c,
	0x0c, 0x47, 0xdf, 0xb9, 0xcf, 0xa8, 0x8c, 0x92, 0x54, 0x95, 0x02, 0x7d, 0x05, 0x3b, 0xa1, 0xda,
	0xf5, 0xa4, 0x6d, 0xbb, 0xd6, 0xb8, 0xd6, 0xee, 0x4a, 0x92, 0x3e, 0xbb, 0xba, 0xeb, 0xbe, 0x8f,
	0x51, 0xb8, 0x78, 0x17, 0x38, 0x00, 0x30, 0x42, 0xee, 0x11, 0xb9, 0x61, 0xf4, 0xfd, 0x67, 0xb1,
	0xa3, 0x04, 0xde, 0x14, 0x11, 0xb9, 0xb3, 0xb2, 0x3e, 0x68, 0xf3, 0x45, 0x1a, 0xbd, 0x00, 0x90,
	0x85, 0x3e, 0x7a, 0x69, 0x74, 0x75, 0xc8, 0xce, 0x59, 0x22, 0xe7, 0x9a, 0xf2, 0xde, 0x80, 0x37,
	0x45, 0x51, 0x8f, 0xa4, 0x87, 0xb0, 0xc5, 0x68, 0x30, 0xb0, 0x4d, 0x4a, 0x64, 0xe3, 0x89, 0xcb,
	0xc6, 0x93, 0x54, 0xb1, 0xba, 0xd1, 0xa7, 0xd9, 0x3f, 0x1e, 0x80, 0x36, 0xef, 0xa4, 0xe8, 0xe5,
	0xa6, 0xe7, 0x32, 0x6a, 0x86, 0xdc, 0x1e, 0x50, 0x72, 0x32, 0x1c, 0xaa, 0xf7, 0xde, 0xd3, 0xcb,
	0xa7, 0x44, 0x27, 0xc3, 0x21, 0x3a, 0x81, 0xc4, 0xc4, 0xf6, 0xf8, 0x7d, 0xb6, 0x4f, 0x52, 0xd1,
	0x19, 0x20, 0x71, 0xe9, 0x23, 0xf4, 0x5b, 0xd5, 0x3e, 0x44, 0x27, 0x52, 0x9d, 0xed, 0x0e, 0x80,
	0x26, 0x44, 0xa7, 0x4a, 0x23, 0x7a, 0xd1, 0xf8, 0x2e, 0x31, 0xe1, 0xf8, 0x34, 0x30, 0xa9, 0xcb,
	0x97, 0xba, 0x03, 0x88, 0xbb, 0xc4, 0x18, 0x76, 0x11, 0xe9, 0xd0, 0x3b, 0xd8, 0xa7, 0x6e, 0xc7,
	0x0b, 0x4c, 0x71, 0x33, 0x99, 0x37, 0x68, 0x99, 0x86, 0xf6, 0x68, 0x22, 0x2f, 0xcf, 0x3a, 0x85,
	0x61, 0xef, 0x9a, 0xcc, 0x42, 0xd3, 0xa4, 0x8c, 0x45, 0xe7, 0x7a, 0x7d, 0x09, 0xec, 0xce, 0x44,
	0xdb, 0x8c, 0xa4, 0xf2, 0x80, 0xbf, 0x87, 0xec, 0x34, 0x89, 0xf4, 0x6d, 0xd7, 0xee, 0x87, 0x7d,
	0x32, 0x6e, 0x7b, 0x4b, 0x2c, 0x97, 0x5d, 0xe3, 0x5e, 0x47, 0xea, 0x73, 0xd9, 0x0f, 0x3f, 0xc0,
	0xe3, 0x19, 0xb4, 0x6a, 0x6c, 0x64, 0xe0, 0x39, 0x61, 0x9f, 0xea, 0x89, 0x65, 0xfa, 0xd9, 0x14,
	0x5b, 0xf5, 0xb5, 0xb7, 0x52, 0x8d, 0xae, 0x60, 0x7f, 0x06, 0xce, 0xb8, 0x45, 0x07, 0xa4, 0x63,
	0x98, 0xdc, 0x0b, 0x96, 0x6a, 0x95, 0x7b, 0x53, 0xe8, 0xa6, 0x10, 0xbf, 0x92, 0xda, 0xdc, 0x15,
	0xa4, 0x66, 0x2e, 0x52, 0x08, 0x60, 0xbd, 0xd9, 0x2a, 0xb6, 0xaa, 0x65, 0x6d, 0x05, 0xa5, 0x01,
	0x9a, 0x2d, 0x5c, 0x2d, 0xb7, 0x48, 0xa5, 0xde, 0xd4, 0x62, 0x28, 0x03, 0xc9, 0x5a, 0xe3, 0xac,
	0x5a, 0x2e, 0xd6, 0x64, 0x20, 0x8e, 0x36, 0x60, 0xf5, 0xb4, 0xd2, 0xd4, 0x56, 0x91, 0x06, 0x5b,
	0x0d, 0x5c, 0x3d, 0xab, 0xd6, 0xc5, 0x54, 0xb3, 0xa5, 0xad, 0xe5, 0xbe, 0x81, 0xc4, 0xf8, 0x86,
	0x21, 0x74, 0xb8, 0x71, 0x59, 0xaf, 0x10, 0xdc, 0x28, 0x55, 0xeb, 0xda, 0x0a, 0xda, 0x86, 0x54,
	0xed, 0xb4, 0xd8, 0x6c, 0x11, 0x7c, 0xfa, 0xe6, 0xf2, 0xb4, 0xd9, 0xd2, 0x62, 0x28, 0x05, 0x9b,
	0xb8, 0x5a, 0x3f, 0x23, 0xe7, 0xc5, 0xe6, 0xb9, 0x16, 0x17, 0xcb, 0xc0, 0xc5, 0x7a, 0xa5, 0xf1,
	0x5a, 0x5b, 0x45, 0x0f, 0x21, 0x33, 0x0d, 0x27, 0xb5, 0x92, 0xb6, 0x96, 0x3b, 0x81, 0xcc, 0x5c,
	0xed, 0x45, 0x09, 0x58, 0x2b, 0x5e, 0xb6, 0x1a, 0xda, 0x0a, 0x4a, 0xc2, 0xc6, 0xdb, 0xff, 0x91,
	0x46, 0xbd, 0xf6, 0x5e, 0x8b, 0xc9, 0xc1, 0xff, 0xa3, 0x41, 0xbc, 0x84, 0x40, 0x9b, 0x6f, 0x3d,
	0x85, 0xdf, 0x63, 0xf0, 0x48, 0x95, 0x97, 0x89, 0x17, 0xcd, 0xa8, 0x1c, 0xa0, 0x2b, 0x48, 0x37,
	0x65, 0xbd, 0x52, 0x09, 0x0c, 0xcd, 0x5d, 0xa7, 0x26, 0x0a, 0xf5, 0xc3, 0xb2, 0x7f, 0xbb, 0x75,
	0x9e, 0xf9, 0x62, 0x83, 0xe7, 0x56, 0x8e, 0x62, 0xff, 0x89, 0x21, 0x06, 0xa9, 0x57, 0x94, 0x9b,
	0xbd, 0xbf, 0x8e, 0x7b, 0xf8, 0xc3, 0x2f, 0xbf, 0xfd, 0x14, 0x7f, 0x9c, 0xdb, 0x3b, 0x1e, 0x14,
	0x8e, 0xad, 0xf1, 0xf4, 0x4b, 0x75, 0x19, 0x66, 0x2f, 0x63, 0xff, 0x6a, 0xaf, 0xcb, 0x6f, 0x7f,
	0xfe, 0x67, 0x00, 0x00, 0x00, 0xff, 0xff, 0x50, 0xee, 0x6b, 0xb9, 0x75, 0x0e, 0x00, 0x00,
}
