// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api/filter/http_connection_manager.proto

/*
Package envoy_api_v2_filter is a generated protocol buffer package.

It is generated from these files:
	api/filter/http_connection_manager.proto

It has these top-level messages:
	Rds
	ComparisonFilter
	StatusCodeFilter
	DurationFilter
	NotHealthCheckFilter
	TraceableFilter
	RuntimeFilter
	AndFilter
	OrFilter
	AccessLogFilter
	HeaderSelection
	AccessLog
	HttpFilter
	HttpConnectionManager
*/
package envoy_api_v2_filter

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import envoy_api_v21 "api"
import envoy_api_v22 "api"
import envoy_api_v23 "api"
import google_protobuf2 "github.com/golang/protobuf/ptypes/duration"
import google_protobuf3 "github.com/golang/protobuf/ptypes/struct"
import google_protobuf "github.com/golang/protobuf/ptypes/wrappers"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Comparison operator.
type ComparisonFilter_Op int32

const (
	ComparisonFilter_EQ ComparisonFilter_Op = 0
	ComparisonFilter_GE ComparisonFilter_Op = 1
)

var ComparisonFilter_Op_name = map[int32]string{
	0: "EQ",
	1: "GE",
}
var ComparisonFilter_Op_value = map[string]int32{
	"EQ": 0,
	"GE": 1,
}

func (x ComparisonFilter_Op) String() string {
	return proto.EnumName(ComparisonFilter_Op_name, int32(x))
}
func (ComparisonFilter_Op) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

type HttpConnectionManager_CodecType int32

const (
	// For every new connection, the connection manager will determine which
	// codec to use. This mode supports both ALPN for TLS listeners as well as
	// protocol inference for plaintext listeners. If ALPN data is available, it
	// is preferred, otherwise protocol inference is used. In almost all cases,
	// this is the right option to choose for this setting.
	HttpConnectionManager_AUTO HttpConnectionManager_CodecType = 0
	// The connection manager will assume that the client is speaking HTTP/1.1.
	HttpConnectionManager_HTTP1 HttpConnectionManager_CodecType = 1
	// The connection manager will assume that the client is speaking HTTP/2
	// (Envoy does not require HTTP/2 to take place over TLS or to use ALPN.
	// Prior knowledge is allowed).
	HttpConnectionManager_HTTP2 HttpConnectionManager_CodecType = 2
)

var HttpConnectionManager_CodecType_name = map[int32]string{
	0: "AUTO",
	1: "HTTP1",
	2: "HTTP2",
}
var HttpConnectionManager_CodecType_value = map[string]int32{
	"AUTO":  0,
	"HTTP1": 1,
	"HTTP2": 2,
}

func (x HttpConnectionManager_CodecType) String() string {
	return proto.EnumName(HttpConnectionManager_CodecType_name, int32(x))
}
func (HttpConnectionManager_CodecType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{13, 0}
}

// How to handle the x-forwarded-client-cert (XFCC) HTTP header.
type HttpConnectionManager_ForwardClientCertDetails int32

const (
	// Do not send the XFCC header to the next hop. This is the default value.
	HttpConnectionManager_SANITIZE HttpConnectionManager_ForwardClientCertDetails = 0
	// When the client connection is mTLS (Mutual TLS), forward the XFCC header
	// in the request.
	HttpConnectionManager_FORWARD_ONLY HttpConnectionManager_ForwardClientCertDetails = 1
	// When the client connection is mTLS, append the client certificate
	// information to the request’s XFCC header and forward it.
	HttpConnectionManager_APPEND_FORWARD HttpConnectionManager_ForwardClientCertDetails = 2
	// When the client connection is mTLS, reset the XFCC header with the client
	// certificate information and send it to the next hop.
	HttpConnectionManager_SANITIZE_SET HttpConnectionManager_ForwardClientCertDetails = 3
	// Always forward the XFCC header in the request, regardless of whether the
	// client connection is mTLS.
	HttpConnectionManager_ALWAYS_FORWARD_ONLY HttpConnectionManager_ForwardClientCertDetails = 4
)

var HttpConnectionManager_ForwardClientCertDetails_name = map[int32]string{
	0: "SANITIZE",
	1: "FORWARD_ONLY",
	2: "APPEND_FORWARD",
	3: "SANITIZE_SET",
	4: "ALWAYS_FORWARD_ONLY",
}
var HttpConnectionManager_ForwardClientCertDetails_value = map[string]int32{
	"SANITIZE":            0,
	"FORWARD_ONLY":        1,
	"APPEND_FORWARD":      2,
	"SANITIZE_SET":        3,
	"ALWAYS_FORWARD_ONLY": 4,
}

func (x HttpConnectionManager_ForwardClientCertDetails) String() string {
	return proto.EnumName(HttpConnectionManager_ForwardClientCertDetails_name, int32(x))
}
func (HttpConnectionManager_ForwardClientCertDetails) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{13, 1}
}

// Span name will be derived from operation_name.
type HttpConnectionManager_Tracing_OperationName int32

const (
	HttpConnectionManager_Tracing_INGRESS HttpConnectionManager_Tracing_OperationName = 0
	HttpConnectionManager_Tracing_EGRESS  HttpConnectionManager_Tracing_OperationName = 1
)

var HttpConnectionManager_Tracing_OperationName_name = map[int32]string{
	0: "INGRESS",
	1: "EGRESS",
}
var HttpConnectionManager_Tracing_OperationName_value = map[string]int32{
	"INGRESS": 0,
	"EGRESS":  1,
}

func (x HttpConnectionManager_Tracing_OperationName) String() string {
	return proto.EnumName(HttpConnectionManager_Tracing_OperationName_name, int32(x))
}
func (HttpConnectionManager_Tracing_OperationName) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{13, 0, 0}
}

type Rds struct {
	// Configuration source specifier for RDS.
	ConfigSource *envoy_api_v21.ConfigSource `protobuf:"bytes,1,opt,name=config_source,json=configSource" json:"config_source,omitempty"`
	// The name of the route configuration. This name will be passed to the RDS
	// API. This allows an Envoy configuration with multiple HTTP listeners (and
	// associated HTTP connection manager filters) to use different route
	// configurations.
	RouteConfigName string `protobuf:"bytes,2,opt,name=route_config_name,json=routeConfigName" json:"route_config_name,omitempty"`
}

func (m *Rds) Reset()                    { *m = Rds{} }
func (m *Rds) String() string            { return proto.CompactTextString(m) }
func (*Rds) ProtoMessage()               {}
func (*Rds) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Rds) GetConfigSource() *envoy_api_v21.ConfigSource {
	if m != nil {
		return m.ConfigSource
	}
	return nil
}

func (m *Rds) GetRouteConfigName() string {
	if m != nil {
		return m.RouteConfigName
	}
	return ""
}

// Filter on some integer comparison.
type ComparisonFilter struct {
	Op ComparisonFilter_Op `protobuf:"varint,1,opt,name=op,enum=envoy.api.v2.filter.ComparisonFilter_Op" json:"op,omitempty"`
	// Value to compare against.
	Value *envoy_api_v21.RuntimeUInt32 `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *ComparisonFilter) Reset()                    { *m = ComparisonFilter{} }
func (m *ComparisonFilter) String() string            { return proto.CompactTextString(m) }
func (*ComparisonFilter) ProtoMessage()               {}
func (*ComparisonFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ComparisonFilter) GetOp() ComparisonFilter_Op {
	if m != nil {
		return m.Op
	}
	return ComparisonFilter_EQ
}

func (m *ComparisonFilter) GetValue() *envoy_api_v21.RuntimeUInt32 {
	if m != nil {
		return m.Value
	}
	return nil
}

// Filters on HTTP response/status code.
type StatusCodeFilter struct {
	Comparison *ComparisonFilter `protobuf:"bytes,1,opt,name=comparison" json:"comparison,omitempty"`
}

func (m *StatusCodeFilter) Reset()                    { *m = StatusCodeFilter{} }
func (m *StatusCodeFilter) String() string            { return proto.CompactTextString(m) }
func (*StatusCodeFilter) ProtoMessage()               {}
func (*StatusCodeFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *StatusCodeFilter) GetComparison() *ComparisonFilter {
	if m != nil {
		return m.Comparison
	}
	return nil
}

// Filters on total request duration in milliseconds.
type DurationFilter struct {
	Comparison *ComparisonFilter `protobuf:"bytes,1,opt,name=comparison" json:"comparison,omitempty"`
}

func (m *DurationFilter) Reset()                    { *m = DurationFilter{} }
func (m *DurationFilter) String() string            { return proto.CompactTextString(m) }
func (*DurationFilter) ProtoMessage()               {}
func (*DurationFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *DurationFilter) GetComparison() *ComparisonFilter {
	if m != nil {
		return m.Comparison
	}
	return nil
}

// Filters for requests that are not health check requests. A health check
// request is marked by the health check filter.
type NotHealthCheckFilter struct {
}

func (m *NotHealthCheckFilter) Reset()                    { *m = NotHealthCheckFilter{} }
func (m *NotHealthCheckFilter) String() string            { return proto.CompactTextString(m) }
func (*NotHealthCheckFilter) ProtoMessage()               {}
func (*NotHealthCheckFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// Filters for requests that are traceable. See the tracing overview for more
// information on how a request becomes traceable.
type TraceableFilter struct {
}

func (m *TraceableFilter) Reset()                    { *m = TraceableFilter{} }
func (m *TraceableFilter) String() string            { return proto.CompactTextString(m) }
func (*TraceableFilter) ProtoMessage()               {}
func (*TraceableFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// Filters for random sampling of requests. Sampling pivots on the header
// x-request-id being present. If x-request-id is present, the filter will
// consistently sample across multiple hosts based on the runtime key value and
// the value extracted from x-request-id. If it is missing, the filter will
// randomly sample based on the runtime key value.
type RuntimeFilter struct {
	// Runtime key to get the percentage of requests to be sampled. This runtime
	// control is specified in the range 0-100 and defaults to 0.
	RuntimeKey string `protobuf:"bytes,1,opt,name=runtime_key,json=runtimeKey" json:"runtime_key,omitempty"`
}

func (m *RuntimeFilter) Reset()                    { *m = RuntimeFilter{} }
func (m *RuntimeFilter) String() string            { return proto.CompactTextString(m) }
func (*RuntimeFilter) ProtoMessage()               {}
func (*RuntimeFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *RuntimeFilter) GetRuntimeKey() string {
	if m != nil {
		return m.RuntimeKey
	}
	return ""
}

// Performs a logical “and” operation on the result of each filter in filters.
// Filters are evaluated sequentially and if one of them returns false, the
// filter returns false immediately.
type AndFilter struct {
	Filters []*AccessLogFilter `protobuf:"bytes,1,rep,name=filters" json:"filters,omitempty"`
}

func (m *AndFilter) Reset()                    { *m = AndFilter{} }
func (m *AndFilter) String() string            { return proto.CompactTextString(m) }
func (*AndFilter) ProtoMessage()               {}
func (*AndFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *AndFilter) GetFilters() []*AccessLogFilter {
	if m != nil {
		return m.Filters
	}
	return nil
}

// Performs a logical “or” operation on the result of each individual filter.
// Filters are evaluated sequentially and if one of them returns true, the
// filter returns true immediately.
type OrFilter struct {
	Filters []*AccessLogFilter `protobuf:"bytes,2,rep,name=filters" json:"filters,omitempty"`
}

func (m *OrFilter) Reset()                    { *m = OrFilter{} }
func (m *OrFilter) String() string            { return proto.CompactTextString(m) }
func (*OrFilter) ProtoMessage()               {}
func (*OrFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *OrFilter) GetFilters() []*AccessLogFilter {
	if m != nil {
		return m.Filters
	}
	return nil
}

type AccessLogFilter struct {
	// Types that are valid to be assigned to FilterSpecifier:
	//	*AccessLogFilter_StatusCodeFilter
	//	*AccessLogFilter_DurationFilter
	//	*AccessLogFilter_NotHealthCheckFilter
	//	*AccessLogFilter_TraceableFilter
	//	*AccessLogFilter_RuntimeFilter
	//	*AccessLogFilter_AndFilter
	//	*AccessLogFilter_OrFilter
	FilterSpecifier isAccessLogFilter_FilterSpecifier `protobuf_oneof:"filter_specifier"`
}

func (m *AccessLogFilter) Reset()                    { *m = AccessLogFilter{} }
func (m *AccessLogFilter) String() string            { return proto.CompactTextString(m) }
func (*AccessLogFilter) ProtoMessage()               {}
func (*AccessLogFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type isAccessLogFilter_FilterSpecifier interface {
	isAccessLogFilter_FilterSpecifier()
}

type AccessLogFilter_StatusCodeFilter struct {
	StatusCodeFilter *StatusCodeFilter `protobuf:"bytes,1,opt,name=status_code_filter,json=statusCodeFilter,oneof"`
}
type AccessLogFilter_DurationFilter struct {
	DurationFilter *DurationFilter `protobuf:"bytes,2,opt,name=duration_filter,json=durationFilter,oneof"`
}
type AccessLogFilter_NotHealthCheckFilter struct {
	NotHealthCheckFilter *NotHealthCheckFilter `protobuf:"bytes,3,opt,name=not_health_check_filter,json=notHealthCheckFilter,oneof"`
}
type AccessLogFilter_TraceableFilter struct {
	TraceableFilter *TraceableFilter `protobuf:"bytes,4,opt,name=traceable_filter,json=traceableFilter,oneof"`
}
type AccessLogFilter_RuntimeFilter struct {
	RuntimeFilter *RuntimeFilter `protobuf:"bytes,5,opt,name=runtime_filter,json=runtimeFilter,oneof"`
}
type AccessLogFilter_AndFilter struct {
	AndFilter *AndFilter `protobuf:"bytes,6,opt,name=and_filter,json=andFilter,oneof"`
}
type AccessLogFilter_OrFilter struct {
	OrFilter *OrFilter `protobuf:"bytes,7,opt,name=or_filter,json=orFilter,oneof"`
}

func (*AccessLogFilter_StatusCodeFilter) isAccessLogFilter_FilterSpecifier()     {}
func (*AccessLogFilter_DurationFilter) isAccessLogFilter_FilterSpecifier()       {}
func (*AccessLogFilter_NotHealthCheckFilter) isAccessLogFilter_FilterSpecifier() {}
func (*AccessLogFilter_TraceableFilter) isAccessLogFilter_FilterSpecifier()      {}
func (*AccessLogFilter_RuntimeFilter) isAccessLogFilter_FilterSpecifier()        {}
func (*AccessLogFilter_AndFilter) isAccessLogFilter_FilterSpecifier()            {}
func (*AccessLogFilter_OrFilter) isAccessLogFilter_FilterSpecifier()             {}

func (m *AccessLogFilter) GetFilterSpecifier() isAccessLogFilter_FilterSpecifier {
	if m != nil {
		return m.FilterSpecifier
	}
	return nil
}

func (m *AccessLogFilter) GetStatusCodeFilter() *StatusCodeFilter {
	if x, ok := m.GetFilterSpecifier().(*AccessLogFilter_StatusCodeFilter); ok {
		return x.StatusCodeFilter
	}
	return nil
}

func (m *AccessLogFilter) GetDurationFilter() *DurationFilter {
	if x, ok := m.GetFilterSpecifier().(*AccessLogFilter_DurationFilter); ok {
		return x.DurationFilter
	}
	return nil
}

func (m *AccessLogFilter) GetNotHealthCheckFilter() *NotHealthCheckFilter {
	if x, ok := m.GetFilterSpecifier().(*AccessLogFilter_NotHealthCheckFilter); ok {
		return x.NotHealthCheckFilter
	}
	return nil
}

func (m *AccessLogFilter) GetTraceableFilter() *TraceableFilter {
	if x, ok := m.GetFilterSpecifier().(*AccessLogFilter_TraceableFilter); ok {
		return x.TraceableFilter
	}
	return nil
}

func (m *AccessLogFilter) GetRuntimeFilter() *RuntimeFilter {
	if x, ok := m.GetFilterSpecifier().(*AccessLogFilter_RuntimeFilter); ok {
		return x.RuntimeFilter
	}
	return nil
}

func (m *AccessLogFilter) GetAndFilter() *AndFilter {
	if x, ok := m.GetFilterSpecifier().(*AccessLogFilter_AndFilter); ok {
		return x.AndFilter
	}
	return nil
}

func (m *AccessLogFilter) GetOrFilter() *OrFilter {
	if x, ok := m.GetFilterSpecifier().(*AccessLogFilter_OrFilter); ok {
		return x.OrFilter
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AccessLogFilter) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AccessLogFilter_OneofMarshaler, _AccessLogFilter_OneofUnmarshaler, _AccessLogFilter_OneofSizer, []interface{}{
		(*AccessLogFilter_StatusCodeFilter)(nil),
		(*AccessLogFilter_DurationFilter)(nil),
		(*AccessLogFilter_NotHealthCheckFilter)(nil),
		(*AccessLogFilter_TraceableFilter)(nil),
		(*AccessLogFilter_RuntimeFilter)(nil),
		(*AccessLogFilter_AndFilter)(nil),
		(*AccessLogFilter_OrFilter)(nil),
	}
}

func _AccessLogFilter_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AccessLogFilter)
	// filter_specifier
	switch x := m.FilterSpecifier.(type) {
	case *AccessLogFilter_StatusCodeFilter:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StatusCodeFilter); err != nil {
			return err
		}
	case *AccessLogFilter_DurationFilter:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DurationFilter); err != nil {
			return err
		}
	case *AccessLogFilter_NotHealthCheckFilter:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NotHealthCheckFilter); err != nil {
			return err
		}
	case *AccessLogFilter_TraceableFilter:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TraceableFilter); err != nil {
			return err
		}
	case *AccessLogFilter_RuntimeFilter:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RuntimeFilter); err != nil {
			return err
		}
	case *AccessLogFilter_AndFilter:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AndFilter); err != nil {
			return err
		}
	case *AccessLogFilter_OrFilter:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OrFilter); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AccessLogFilter.FilterSpecifier has unexpected type %T", x)
	}
	return nil
}

func _AccessLogFilter_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AccessLogFilter)
	switch tag {
	case 1: // filter_specifier.status_code_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StatusCodeFilter)
		err := b.DecodeMessage(msg)
		m.FilterSpecifier = &AccessLogFilter_StatusCodeFilter{msg}
		return true, err
	case 2: // filter_specifier.duration_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DurationFilter)
		err := b.DecodeMessage(msg)
		m.FilterSpecifier = &AccessLogFilter_DurationFilter{msg}
		return true, err
	case 3: // filter_specifier.not_health_check_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NotHealthCheckFilter)
		err := b.DecodeMessage(msg)
		m.FilterSpecifier = &AccessLogFilter_NotHealthCheckFilter{msg}
		return true, err
	case 4: // filter_specifier.traceable_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TraceableFilter)
		err := b.DecodeMessage(msg)
		m.FilterSpecifier = &AccessLogFilter_TraceableFilter{msg}
		return true, err
	case 5: // filter_specifier.runtime_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RuntimeFilter)
		err := b.DecodeMessage(msg)
		m.FilterSpecifier = &AccessLogFilter_RuntimeFilter{msg}
		return true, err
	case 6: // filter_specifier.and_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AndFilter)
		err := b.DecodeMessage(msg)
		m.FilterSpecifier = &AccessLogFilter_AndFilter{msg}
		return true, err
	case 7: // filter_specifier.or_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OrFilter)
		err := b.DecodeMessage(msg)
		m.FilterSpecifier = &AccessLogFilter_OrFilter{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AccessLogFilter_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AccessLogFilter)
	// filter_specifier
	switch x := m.FilterSpecifier.(type) {
	case *AccessLogFilter_StatusCodeFilter:
		s := proto.Size(x.StatusCodeFilter)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccessLogFilter_DurationFilter:
		s := proto.Size(x.DurationFilter)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccessLogFilter_NotHealthCheckFilter:
		s := proto.Size(x.NotHealthCheckFilter)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccessLogFilter_TraceableFilter:
		s := proto.Size(x.TraceableFilter)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccessLogFilter_RuntimeFilter:
		s := proto.Size(x.RuntimeFilter)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccessLogFilter_AndFilter:
		s := proto.Size(x.AndFilter)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccessLogFilter_OrFilter:
		s := proto.Size(x.OrFilter)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Extra headers to include when doing AccessLogs via proto format.
type HeaderSelection struct {
	// Request headers to include in the AccessLog.
	RequestHeaders []string `protobuf:"bytes,1,rep,name=request_headers,json=requestHeaders" json:"request_headers,omitempty"`
	// Response headers to include in the AccessLog.
	ResponseHeaders []string `protobuf:"bytes,2,rep,name=response_headers,json=responseHeaders" json:"response_headers,omitempty"`
}

func (m *HeaderSelection) Reset()                    { *m = HeaderSelection{} }
func (m *HeaderSelection) String() string            { return proto.CompactTextString(m) }
func (*HeaderSelection) ProtoMessage()               {}
func (*HeaderSelection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *HeaderSelection) GetRequestHeaders() []string {
	if m != nil {
		return m.RequestHeaders
	}
	return nil
}

func (m *HeaderSelection) GetResponseHeaders() []string {
	if m != nil {
		return m.ResponseHeaders
	}
	return nil
}

type AccessLog struct {
	// Destination location the access log is written to.
	//
	// Envoy supports logging to both RPC endpoints and local disk files.
	// Behavior is set by choosing which of these is used:
	//
	// Types that are valid to be assigned to Destination:
	//	*AccessLog_Path
	//	*AccessLog_Cluster
	Destination isAccessLog_Destination `protobuf_oneof:"destination"`
	// Content included in log entries.
	//
	// When logging to a file this is a format string which specifies what is
	// included.
	//
	// When logging to an RPC endpoint all of the named fields in accesslog.proto
	// are populated by default if the relevant data is available for the logged
	// request. Additional headers desired for logging can be specified in the
	// HeaderSelection.
	//
	// Types that are valid to be assigned to Content:
	//	*AccessLog_Format
	//	*AccessLog_Headers
	Content isAccessLog_Content `protobuf_oneof:"content"`
	// Filter which is used to determine if the access log needs to be written.
	Filter *AccessLogFilter `protobuf:"bytes,3,opt,name=filter" json:"filter,omitempty"`
}

func (m *AccessLog) Reset()                    { *m = AccessLog{} }
func (m *AccessLog) String() string            { return proto.CompactTextString(m) }
func (*AccessLog) ProtoMessage()               {}
func (*AccessLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type isAccessLog_Destination interface {
	isAccessLog_Destination()
}
type isAccessLog_Content interface {
	isAccessLog_Content()
}

type AccessLog_Path struct {
	Path string `protobuf:"bytes,1,opt,name=path,oneof"`
}
type AccessLog_Cluster struct {
	Cluster string `protobuf:"bytes,5,opt,name=cluster,oneof"`
}
type AccessLog_Format struct {
	Format string `protobuf:"bytes,2,opt,name=format,oneof"`
}
type AccessLog_Headers struct {
	Headers *HeaderSelection `protobuf:"bytes,4,opt,name=headers,oneof"`
}

func (*AccessLog_Path) isAccessLog_Destination()    {}
func (*AccessLog_Cluster) isAccessLog_Destination() {}
func (*AccessLog_Format) isAccessLog_Content()      {}
func (*AccessLog_Headers) isAccessLog_Content()     {}

func (m *AccessLog) GetDestination() isAccessLog_Destination {
	if m != nil {
		return m.Destination
	}
	return nil
}
func (m *AccessLog) GetContent() isAccessLog_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *AccessLog) GetPath() string {
	if x, ok := m.GetDestination().(*AccessLog_Path); ok {
		return x.Path
	}
	return ""
}

func (m *AccessLog) GetCluster() string {
	if x, ok := m.GetDestination().(*AccessLog_Cluster); ok {
		return x.Cluster
	}
	return ""
}

func (m *AccessLog) GetFormat() string {
	if x, ok := m.GetContent().(*AccessLog_Format); ok {
		return x.Format
	}
	return ""
}

func (m *AccessLog) GetHeaders() *HeaderSelection {
	if x, ok := m.GetContent().(*AccessLog_Headers); ok {
		return x.Headers
	}
	return nil
}

func (m *AccessLog) GetFilter() *AccessLogFilter {
	if m != nil {
		return m.Filter
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AccessLog) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AccessLog_OneofMarshaler, _AccessLog_OneofUnmarshaler, _AccessLog_OneofSizer, []interface{}{
		(*AccessLog_Path)(nil),
		(*AccessLog_Cluster)(nil),
		(*AccessLog_Format)(nil),
		(*AccessLog_Headers)(nil),
	}
}

func _AccessLog_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AccessLog)
	// destination
	switch x := m.Destination.(type) {
	case *AccessLog_Path:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Path)
	case *AccessLog_Cluster:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Cluster)
	case nil:
	default:
		return fmt.Errorf("AccessLog.Destination has unexpected type %T", x)
	}
	// content
	switch x := m.Content.(type) {
	case *AccessLog_Format:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Format)
	case *AccessLog_Headers:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Headers); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AccessLog.Content has unexpected type %T", x)
	}
	return nil
}

func _AccessLog_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AccessLog)
	switch tag {
	case 1: // destination.path
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Destination = &AccessLog_Path{x}
		return true, err
	case 5: // destination.cluster
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Destination = &AccessLog_Cluster{x}
		return true, err
	case 2: // content.format
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Content = &AccessLog_Format{x}
		return true, err
	case 4: // content.headers
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HeaderSelection)
		err := b.DecodeMessage(msg)
		m.Content = &AccessLog_Headers{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AccessLog_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AccessLog)
	// destination
	switch x := m.Destination.(type) {
	case *AccessLog_Path:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Path)))
		n += len(x.Path)
	case *AccessLog_Cluster:
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Cluster)))
		n += len(x.Cluster)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// content
	switch x := m.Content.(type) {
	case *AccessLog_Format:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Format)))
		n += len(x.Format)
	case *AccessLog_Headers:
		s := proto.Size(x.Headers)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type HttpFilter struct {
	// The name of the filter to instantiate. The name must match a supported
	// filter.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Filter specific configuration which depends on the filter being
	// instantiated. See the supported filters for further documentation.
	Config       *google_protobuf3.Struct `protobuf:"bytes,2,opt,name=config" json:"config,omitempty"`
	DeprecatedV1 *HttpFilter_DeprecatedV1 `protobuf:"bytes,3,opt,name=deprecated_v1,json=deprecatedV1" json:"deprecated_v1,omitempty"`
}

func (m *HttpFilter) Reset()                    { *m = HttpFilter{} }
func (m *HttpFilter) String() string            { return proto.CompactTextString(m) }
func (*HttpFilter) ProtoMessage()               {}
func (*HttpFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *HttpFilter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HttpFilter) GetConfig() *google_protobuf3.Struct {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *HttpFilter) GetDeprecatedV1() *HttpFilter_DeprecatedV1 {
	if m != nil {
		return m.DeprecatedV1
	}
	return nil
}

type HttpFilter_DeprecatedV1 struct {
	Type string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
}

func (m *HttpFilter_DeprecatedV1) Reset()                    { *m = HttpFilter_DeprecatedV1{} }
func (m *HttpFilter_DeprecatedV1) String() string            { return proto.CompactTextString(m) }
func (*HttpFilter_DeprecatedV1) ProtoMessage()               {}
func (*HttpFilter_DeprecatedV1) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12, 0} }

func (m *HttpFilter_DeprecatedV1) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type HttpConnectionManager struct {
	CodecType HttpConnectionManager_CodecType `protobuf:"varint,1,opt,name=codec_type,json=codecType,enum=envoy.api.v2.filter.HttpConnectionManager_CodecType" json:"codec_type,omitempty"`
	// The human readable prefix to use when emitting statistics for the
	// connection manager. See the statistics documentation for more information.
	StatPrefix string `protobuf:"bytes,2,opt,name=stat_prefix,json=statPrefix" json:"stat_prefix,omitempty"`
	// Types that are valid to be assigned to RouteSpecifier:
	//	*HttpConnectionManager_Rds
	//	*HttpConnectionManager_RouteConfig
	RouteSpecifier isHttpConnectionManager_RouteSpecifier `protobuf_oneof:"route_specifier"`
	// A list of individual HTTP filters that make up the filter chain for
	// requests made to the connection manager. Order matters as the filters are
	// processed sequentially as request events happen.
	HttpFilters []*HttpFilter `protobuf:"bytes,5,rep,name=http_filters,json=httpFilters" json:"http_filters,omitempty"`
	// Whether the connection manager manipulates the user-agent and
	// x-envoy-downstream-service-cluster headers. See the linked documentation
	// for more information. Defaults to false.
	AddUserAgent         *google_protobuf.BoolValue          `protobuf:"bytes,6,opt,name=add_user_agent,json=addUserAgent" json:"add_user_agent,omitempty"`
	Tracing              *HttpConnectionManager_Tracing      `protobuf:"bytes,7,opt,name=tracing" json:"tracing,omitempty"`
	HttpProtocolOptions  *envoy_api_v22.Http1ProtocolOptions `protobuf:"bytes,8,opt,name=http_protocol_options,json=httpProtocolOptions" json:"http_protocol_options,omitempty"`
	Http2ProtocolOptions *envoy_api_v22.Http2ProtocolOptions `protobuf:"bytes,9,opt,name=http2_protocol_options,json=http2ProtocolOptions" json:"http2_protocol_options,omitempty"`
	// An optional override that the connection manager will write to the server
	// header in responses. If not set, the default is envoy.
	ServerName string `protobuf:"bytes,10,opt,name=server_name,json=serverName" json:"server_name,omitempty"`
	// The idle timeout for connections managed by the connection manager. The
	// idle timeout is defined as the period in which there are no active
	// requests. If not set, there is no idle timeout. When the idle timeout is
	// reached the connection will be closed. If the connection is an HTTP/2
	// connection a drain sequence will occur prior to closing the connection. See
	// drain_timeout.
	IdleTimeout *google_protobuf2.Duration `protobuf:"bytes,11,opt,name=idle_timeout,json=idleTimeout" json:"idle_timeout,omitempty"`
	// The time that Envoy will wait between sending an HTTP/2 “shutdown
	// notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
	// This is used so that Envoy provides a grace period for new streams that
	// race with the final GOAWAY frame. During this grace period, Envoy will
	// continue to accept new streams. After the grace period, a final GOAWAY
	// frame is sent and Envoy will start refusing new streams. Draining occurs
	// both when a connection hits the idle timeout or during general server
	// draining. The default grace period is 5000 milliseconds (5 seconds) if this
	// option is not specified.
	DrainTimeout *google_protobuf2.Duration `protobuf:"bytes,12,opt,name=drain_timeout,json=drainTimeout" json:"drain_timeout,omitempty"`
	// Configuration for HTTP access logs emitted by the connection manager.
	AccessLog []*AccessLog `protobuf:"bytes,13,rep,name=access_log,json=accessLog" json:"access_log,omitempty"`
	// If set to true, the connection manager will use the real remote address of
	// the client connection when determining internal versus external origin and
	// manipulating various headers. If set to false or absent, the connection
	// manager will use the x-forwarded-for HTTP header. See the documentation for
	// x-forwarded-for, x-envoy-internal, and x-envoy-external-address for more
	// information.
	// TODO(mattklein123): Clean this up, see also discussion in
	// https://github.com/lyft/envoy/issues/794.
	UseRemoteAddress *google_protobuf.BoolValue `protobuf:"bytes,14,opt,name=use_remote_address,json=useRemoteAddress" json:"use_remote_address,omitempty"`
	// Whether the connection manager will generate the x-request-id header if it
	// does not exist. This defaults to true. Generating a random UUID4 is
	// expensive so in high throughput scenarios where this feature is not desired
	// it can be disabled.
	GenerateRequestId           *google_protobuf.BoolValue                         `protobuf:"bytes,15,opt,name=generate_request_id,json=generateRequestId" json:"generate_request_id,omitempty"`
	ForwardClientCertDetails    HttpConnectionManager_ForwardClientCertDetails     `protobuf:"varint,16,opt,name=forward_client_cert_details,json=forwardClientCertDetails,enum=envoy.api.v2.filter.HttpConnectionManager_ForwardClientCertDetails" json:"forward_client_cert_details,omitempty"`
	SetCurrentClientCertDetails *HttpConnectionManager_SetCurrentClientCertDetails `protobuf:"bytes,17,opt,name=set_current_client_cert_details,json=setCurrentClientCertDetails" json:"set_current_client_cert_details,omitempty"`
}

func (m *HttpConnectionManager) Reset()                    { *m = HttpConnectionManager{} }
func (m *HttpConnectionManager) String() string            { return proto.CompactTextString(m) }
func (*HttpConnectionManager) ProtoMessage()               {}
func (*HttpConnectionManager) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

type isHttpConnectionManager_RouteSpecifier interface {
	isHttpConnectionManager_RouteSpecifier()
}

type HttpConnectionManager_Rds struct {
	Rds *Rds `protobuf:"bytes,3,opt,name=rds,oneof"`
}
type HttpConnectionManager_RouteConfig struct {
	RouteConfig *envoy_api_v23.RouteConfiguration `protobuf:"bytes,4,opt,name=route_config,json=routeConfig,oneof"`
}

func (*HttpConnectionManager_Rds) isHttpConnectionManager_RouteSpecifier()         {}
func (*HttpConnectionManager_RouteConfig) isHttpConnectionManager_RouteSpecifier() {}

func (m *HttpConnectionManager) GetRouteSpecifier() isHttpConnectionManager_RouteSpecifier {
	if m != nil {
		return m.RouteSpecifier
	}
	return nil
}

func (m *HttpConnectionManager) GetCodecType() HttpConnectionManager_CodecType {
	if m != nil {
		return m.CodecType
	}
	return HttpConnectionManager_AUTO
}

func (m *HttpConnectionManager) GetStatPrefix() string {
	if m != nil {
		return m.StatPrefix
	}
	return ""
}

func (m *HttpConnectionManager) GetRds() *Rds {
	if x, ok := m.GetRouteSpecifier().(*HttpConnectionManager_Rds); ok {
		return x.Rds
	}
	return nil
}

func (m *HttpConnectionManager) GetRouteConfig() *envoy_api_v23.RouteConfiguration {
	if x, ok := m.GetRouteSpecifier().(*HttpConnectionManager_RouteConfig); ok {
		return x.RouteConfig
	}
	return nil
}

func (m *HttpConnectionManager) GetHttpFilters() []*HttpFilter {
	if m != nil {
		return m.HttpFilters
	}
	return nil
}

func (m *HttpConnectionManager) GetAddUserAgent() *google_protobuf.BoolValue {
	if m != nil {
		return m.AddUserAgent
	}
	return nil
}

func (m *HttpConnectionManager) GetTracing() *HttpConnectionManager_Tracing {
	if m != nil {
		return m.Tracing
	}
	return nil
}

func (m *HttpConnectionManager) GetHttpProtocolOptions() *envoy_api_v22.Http1ProtocolOptions {
	if m != nil {
		return m.HttpProtocolOptions
	}
	return nil
}

func (m *HttpConnectionManager) GetHttp2ProtocolOptions() *envoy_api_v22.Http2ProtocolOptions {
	if m != nil {
		return m.Http2ProtocolOptions
	}
	return nil
}

func (m *HttpConnectionManager) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

func (m *HttpConnectionManager) GetIdleTimeout() *google_protobuf2.Duration {
	if m != nil {
		return m.IdleTimeout
	}
	return nil
}

func (m *HttpConnectionManager) GetDrainTimeout() *google_protobuf2.Duration {
	if m != nil {
		return m.DrainTimeout
	}
	return nil
}

func (m *HttpConnectionManager) GetAccessLog() []*AccessLog {
	if m != nil {
		return m.AccessLog
	}
	return nil
}

func (m *HttpConnectionManager) GetUseRemoteAddress() *google_protobuf.BoolValue {
	if m != nil {
		return m.UseRemoteAddress
	}
	return nil
}

func (m *HttpConnectionManager) GetGenerateRequestId() *google_protobuf.BoolValue {
	if m != nil {
		return m.GenerateRequestId
	}
	return nil
}

func (m *HttpConnectionManager) GetForwardClientCertDetails() HttpConnectionManager_ForwardClientCertDetails {
	if m != nil {
		return m.ForwardClientCertDetails
	}
	return HttpConnectionManager_SANITIZE
}

func (m *HttpConnectionManager) GetSetCurrentClientCertDetails() *HttpConnectionManager_SetCurrentClientCertDetails {
	if m != nil {
		return m.SetCurrentClientCertDetails
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*HttpConnectionManager) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _HttpConnectionManager_OneofMarshaler, _HttpConnectionManager_OneofUnmarshaler, _HttpConnectionManager_OneofSizer, []interface{}{
		(*HttpConnectionManager_Rds)(nil),
		(*HttpConnectionManager_RouteConfig)(nil),
	}
}

func _HttpConnectionManager_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*HttpConnectionManager)
	// route_specifier
	switch x := m.RouteSpecifier.(type) {
	case *HttpConnectionManager_Rds:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Rds); err != nil {
			return err
		}
	case *HttpConnectionManager_RouteConfig:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RouteConfig); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("HttpConnectionManager.RouteSpecifier has unexpected type %T", x)
	}
	return nil
}

func _HttpConnectionManager_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*HttpConnectionManager)
	switch tag {
	case 3: // route_specifier.rds
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Rds)
		err := b.DecodeMessage(msg)
		m.RouteSpecifier = &HttpConnectionManager_Rds{msg}
		return true, err
	case 4: // route_specifier.route_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(envoy_api_v23.RouteConfiguration)
		err := b.DecodeMessage(msg)
		m.RouteSpecifier = &HttpConnectionManager_RouteConfig{msg}
		return true, err
	default:
		return false, nil
	}
}

func _HttpConnectionManager_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*HttpConnectionManager)
	// route_specifier
	switch x := m.RouteSpecifier.(type) {
	case *HttpConnectionManager_Rds:
		s := proto.Size(x.Rds)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *HttpConnectionManager_RouteConfig:
		s := proto.Size(x.RouteConfig)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type HttpConnectionManager_Tracing struct {
	OperationName HttpConnectionManager_Tracing_OperationName `protobuf:"varint,1,opt,name=operation_name,json=operationName,enum=envoy.api.v2.filter.HttpConnectionManager_Tracing_OperationName" json:"operation_name,omitempty"`
	// The header name is used to populate the tag name, and the header value is
	// used to populate the tag value. The tag is created if the specified
	// header name is present in the request’s headers.
	RequestHeadersForTags []string `protobuf:"bytes,2,rep,name=request_headers_for_tags,json=requestHeadersForTags" json:"request_headers_for_tags,omitempty"`
}

func (m *HttpConnectionManager_Tracing) Reset()         { *m = HttpConnectionManager_Tracing{} }
func (m *HttpConnectionManager_Tracing) String() string { return proto.CompactTextString(m) }
func (*HttpConnectionManager_Tracing) ProtoMessage()    {}
func (*HttpConnectionManager_Tracing) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{13, 0}
}

func (m *HttpConnectionManager_Tracing) GetOperationName() HttpConnectionManager_Tracing_OperationName {
	if m != nil {
		return m.OperationName
	}
	return HttpConnectionManager_Tracing_INGRESS
}

func (m *HttpConnectionManager_Tracing) GetRequestHeadersForTags() []string {
	if m != nil {
		return m.RequestHeadersForTags
	}
	return nil
}

// This field is valid only when forward_client_cert is append_forward or
// sanitize_set and the client connection is mTLS. It specifies the fields in
// the client certificate to be forwarded. Note that in the
// x-forwarded-client-cert header, Hash is always set, and By is always set
// when the client certificate presents the SAN value.
type HttpConnectionManager_SetCurrentClientCertDetails struct {
	Subject *google_protobuf.BoolValue `protobuf:"bytes,1,opt,name=subject" json:"subject,omitempty"`
	San     *google_protobuf.BoolValue `protobuf:"bytes,2,opt,name=san" json:"san,omitempty"`
}

func (m *HttpConnectionManager_SetCurrentClientCertDetails) Reset() {
	*m = HttpConnectionManager_SetCurrentClientCertDetails{}
}
func (m *HttpConnectionManager_SetCurrentClientCertDetails) String() string {
	return proto.CompactTextString(m)
}
func (*HttpConnectionManager_SetCurrentClientCertDetails) ProtoMessage() {}
func (*HttpConnectionManager_SetCurrentClientCertDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{13, 1}
}

func (m *HttpConnectionManager_SetCurrentClientCertDetails) GetSubject() *google_protobuf.BoolValue {
	if m != nil {
		return m.Subject
	}
	return nil
}

func (m *HttpConnectionManager_SetCurrentClientCertDetails) GetSan() *google_protobuf.BoolValue {
	if m != nil {
		return m.San
	}
	return nil
}

func init() {
	proto.RegisterType((*Rds)(nil), "envoy.api.v2.filter.Rds")
	proto.RegisterType((*ComparisonFilter)(nil), "envoy.api.v2.filter.ComparisonFilter")
	proto.RegisterType((*StatusCodeFilter)(nil), "envoy.api.v2.filter.StatusCodeFilter")
	proto.RegisterType((*DurationFilter)(nil), "envoy.api.v2.filter.DurationFilter")
	proto.RegisterType((*NotHealthCheckFilter)(nil), "envoy.api.v2.filter.NotHealthCheckFilter")
	proto.RegisterType((*TraceableFilter)(nil), "envoy.api.v2.filter.TraceableFilter")
	proto.RegisterType((*RuntimeFilter)(nil), "envoy.api.v2.filter.RuntimeFilter")
	proto.RegisterType((*AndFilter)(nil), "envoy.api.v2.filter.AndFilter")
	proto.RegisterType((*OrFilter)(nil), "envoy.api.v2.filter.OrFilter")
	proto.RegisterType((*AccessLogFilter)(nil), "envoy.api.v2.filter.AccessLogFilter")
	proto.RegisterType((*HeaderSelection)(nil), "envoy.api.v2.filter.HeaderSelection")
	proto.RegisterType((*AccessLog)(nil), "envoy.api.v2.filter.AccessLog")
	proto.RegisterType((*HttpFilter)(nil), "envoy.api.v2.filter.HttpFilter")
	proto.RegisterType((*HttpFilter_DeprecatedV1)(nil), "envoy.api.v2.filter.HttpFilter.DeprecatedV1")
	proto.RegisterType((*HttpConnectionManager)(nil), "envoy.api.v2.filter.HttpConnectionManager")
	proto.RegisterType((*HttpConnectionManager_Tracing)(nil), "envoy.api.v2.filter.HttpConnectionManager.Tracing")
	proto.RegisterType((*HttpConnectionManager_SetCurrentClientCertDetails)(nil), "envoy.api.v2.filter.HttpConnectionManager.SetCurrentClientCertDetails")
	proto.RegisterEnum("envoy.api.v2.filter.ComparisonFilter_Op", ComparisonFilter_Op_name, ComparisonFilter_Op_value)
	proto.RegisterEnum("envoy.api.v2.filter.HttpConnectionManager_CodecType", HttpConnectionManager_CodecType_name, HttpConnectionManager_CodecType_value)
	proto.RegisterEnum("envoy.api.v2.filter.HttpConnectionManager_ForwardClientCertDetails", HttpConnectionManager_ForwardClientCertDetails_name, HttpConnectionManager_ForwardClientCertDetails_value)
	proto.RegisterEnum("envoy.api.v2.filter.HttpConnectionManager_Tracing_OperationName", HttpConnectionManager_Tracing_OperationName_name, HttpConnectionManager_Tracing_OperationName_value)
}

func init() { proto.RegisterFile("api/filter/http_connection_manager.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1503 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xcf, 0x76, 0x1b, 0x3f,
	0x15, 0xf6, 0x38, 0x7f, 0x1c, 0x5f, 0xff, 0x9b, 0x28, 0x69, 0x6b, 0x1c, 0x68, 0x73, 0x06, 0x38,
	0xa4, 0xd0, 0xe3, 0x10, 0xb7, 0xe7, 0xc0, 0xa2, 0xb4, 0x75, 0x1c, 0xa7, 0x93, 0x36, 0xc4, 0xa9,
	0xec, 0xb4, 0x94, 0xcd, 0x1c, 0x65, 0x46, 0x76, 0x86, 0x3a, 0xa3, 0x41, 0xd2, 0xa4, 0x64, 0x09,
	0x6b, 0xb6, 0x3c, 0x03, 0xaf, 0xc2, 0x8e, 0x15, 0x0f, 0xc2, 0x1b, 0x70, 0x46, 0xd2, 0xb8, 0xb1,
	0xe3, 0x24, 0x0d, 0xe7, 0xb7, 0xb2, 0x74, 0x75, 0xbf, 0x4f, 0x57, 0xba, 0x9f, 0xee, 0x1d, 0xc3,
	0x16, 0x89, 0xc3, 0xed, 0x61, 0x38, 0x96, 0x94, 0x6f, 0x9f, 0x49, 0x19, 0x7b, 0x3e, 0x8b, 0x22,
	0xea, 0xcb, 0x90, 0x45, 0xde, 0x39, 0x89, 0xc8, 0x88, 0xf2, 0x66, 0xcc, 0x99, 0x64, 0x68, 0x8d,
	0x46, 0x17, 0xec, 0xb2, 0x49, 0xe2, 0xb0, 0x79, 0xd1, 0x6a, 0x6a, 0x48, 0xa3, 0x9a, 0xc2, 0x4f,
	0x89, 0xa0, 0xda, 0xa9, 0x81, 0xd2, 0xb9, 0x1a, 0xfa, 0x6c, 0x6c, 0x6c, 0x95, 0xd4, 0xc6, 0x03,
	0x61, 0xa6, 0x8f, 0x47, 0x8c, 0x8d, 0xc6, 0x54, 0x7b, 0x9d, 0x26, 0xc3, 0xed, 0x20, 0xe1, 0x24,
	0xdd, 0xcf, 0xac, 0xff, 0x78, 0x76, 0x5d, 0x48, 0x9e, 0xf8, 0xf2, 0x26, 0xf4, 0x57, 0x4e, 0xe2,
	0x98, 0x72, 0xc3, 0xee, 0x70, 0x58, 0xc0, 0x81, 0x40, 0xaf, 0xa1, 0xe2, 0xb3, 0x68, 0x18, 0x8e,
	0x3c, 0xc1, 0x12, 0xee, 0xd3, 0xba, 0xb5, 0x69, 0x6d, 0x95, 0x5a, 0x8d, 0xe6, 0xd4, 0x21, 0x3a,
	0xca, 0xa5, 0xaf, 0x3c, 0x70, 0xd9, 0xbf, 0x32, 0x43, 0xbf, 0x84, 0x55, 0xce, 0x12, 0x49, 0x3d,
	0x43, 0x13, 0x91, 0x73, 0x5a, 0xcf, 0x6f, 0x5a, 0x5b, 0x45, 0x5c, 0x53, 0x0b, 0x1a, 0x7b, 0x44,
	0xce, 0xa9, 0xf3, 0x0f, 0x0b, 0xec, 0x0e, 0x3b, 0x8f, 0x09, 0x0f, 0x05, 0x8b, 0xf6, 0xd5, 0xcd,
	0xa0, 0xdf, 0x42, 0x9e, 0xc5, 0x6a, 0xdb, 0x6a, 0x6b, 0xab, 0x39, 0xe7, 0xee, 0x9a, 0xb3, 0x90,
	0x66, 0x2f, 0xc6, 0x79, 0x16, 0xa3, 0x1d, 0x58, 0xba, 0x20, 0xe3, 0x44, 0x6f, 0x57, 0x6a, 0x6d,
	0x4c, 0x83, 0x71, 0x12, 0xc9, 0xf0, 0x9c, 0x9e, 0x1c, 0x44, 0xf2, 0x79, 0x0b, 0x6b, 0x4f, 0x67,
	0x1d, 0xf2, 0xbd, 0x18, 0x2d, 0x43, 0xbe, 0xfb, 0xc1, 0xce, 0xa5, 0xbf, 0x6f, 0xbb, 0xb6, 0xe5,
	0x7c, 0x06, 0xbb, 0x2f, 0x89, 0x4c, 0x44, 0x87, 0x05, 0xd4, 0x84, 0xd5, 0x05, 0xf0, 0x27, 0xfb,
	0x9a, 0x5b, 0xf9, 0xf9, 0x77, 0x85, 0x87, 0xaf, 0x00, 0x9d, 0x4f, 0x50, 0xdd, 0x33, 0x69, 0xfb,
	0x61, 0x89, 0x1f, 0xc2, 0xfa, 0x11, 0x93, 0x2e, 0x25, 0x63, 0x79, 0xd6, 0x39, 0xa3, 0xfe, 0x17,
	0xed, 0xe3, 0xac, 0x42, 0x6d, 0xc0, 0x89, 0x4f, 0xc9, 0xe9, 0xd8, 0x1c, 0xc5, 0xf9, 0x35, 0x54,
	0xcc, 0x65, 0x98, 0x10, 0x9e, 0x40, 0x89, 0x6b, 0x83, 0xf7, 0x85, 0x5e, 0xaa, 0x18, 0x8a, 0x18,
	0x8c, 0xe9, 0x3d, 0xbd, 0x74, 0xde, 0x43, 0xb1, 0x1d, 0x05, 0xc6, 0xfb, 0x15, 0x14, 0x74, 0x40,
	0xa2, 0x6e, 0x6d, 0x2e, 0x6c, 0x95, 0x5a, 0x3f, 0x9b, 0x1b, 0x6d, 0xdb, 0xf7, 0xa9, 0x10, 0x87,
	0x6c, 0x64, 0x82, 0xcd, 0x40, 0xce, 0x3b, 0x58, 0xe9, 0xf1, 0xeb, 0x5c, 0xf9, 0xff, 0x87, 0xeb,
	0xdf, 0x8b, 0x50, 0x9b, 0x59, 0x44, 0x27, 0x80, 0x84, 0xca, 0x9e, 0xe7, 0xb3, 0x80, 0x7a, 0xda,
	0xf5, 0xd6, 0x8b, 0x9d, 0x4d, 0xb6, 0x9b, 0xc3, 0xb6, 0x98, 0x15, 0xc0, 0x11, 0xd4, 0xb2, 0x07,
	0x97, 0x71, 0x6a, 0x9d, 0xfd, 0x74, 0x2e, 0xe7, 0x74, 0x96, 0xdd, 0x1c, 0xae, 0x06, 0xd3, 0x79,
	0x3f, 0x85, 0x47, 0x11, 0x93, 0xde, 0x99, 0xca, 0x98, 0xe7, 0xa7, 0x29, 0xcb, 0x78, 0x17, 0x14,
	0xef, 0xd3, 0xb9, 0xbc, 0xf3, 0x92, 0xec, 0xe6, 0xf0, 0x7a, 0x34, 0xc7, 0x8e, 0x3e, 0x80, 0x2d,
	0xb3, 0xe4, 0x67, 0xe4, 0x8b, 0x8a, 0x7c, 0xfe, 0x3d, 0xcf, 0x28, 0xc5, 0xcd, 0xe1, 0x9a, 0x9c,
	0x36, 0xa1, 0xf7, 0x50, 0xcd, 0xb4, 0x62, 0x08, 0x97, 0x14, 0xa1, 0x33, 0x97, 0x70, 0x4a, 0x67,
	0x6e, 0x0e, 0x57, 0xf8, 0x94, 0xf0, 0x5e, 0x03, 0x90, 0x28, 0xc8, 0x88, 0x96, 0x15, 0xd1, 0xe3,
	0xf9, 0x0a, 0xc8, 0xe4, 0xe7, 0xe6, 0x70, 0x91, 0x4c, 0xb4, 0xf8, 0x12, 0x8a, 0x8c, 0x67, 0xf8,
	0x82, 0xc2, 0xff, 0x64, 0x2e, 0x3e, 0x53, 0x9c, 0x9b, 0xc3, 0x2b, 0xcc, 0x8c, 0x77, 0x11, 0xd8,
	0x7a, 0xd9, 0x13, 0x31, 0xf5, 0xc3, 0x61, 0x48, 0xb9, 0x43, 0xa1, 0xe6, 0x52, 0x12, 0x50, 0xde,
	0xa7, 0x63, 0x5d, 0xce, 0xd1, 0x2f, 0xa0, 0xc6, 0xe9, 0x9f, 0x13, 0x2a, 0x54, 0xb6, 0x82, 0x4c,
	0xf8, 0x45, 0x5c, 0x35, 0x66, 0x0d, 0x10, 0xe8, 0x29, 0xd8, 0x9c, 0x8a, 0x98, 0x45, 0x82, 0x4e,
	0x3c, 0xf3, 0xca, 0xb3, 0x96, 0xd9, 0x8d, 0xab, 0xf3, 0x5f, 0x0b, 0x8a, 0x13, 0xe1, 0xa2, 0x75,
	0x58, 0x8c, 0x89, 0x3c, 0xd3, 0x2f, 0xcf, 0xcd, 0x61, 0x35, 0x43, 0x0d, 0x28, 0xf8, 0xe3, 0x44,
	0x64, 0x77, 0x9c, 0x2e, 0x64, 0x06, 0x54, 0x87, 0xe5, 0x21, 0xe3, 0xe7, 0x44, 0xea, 0xda, 0xea,
	0x5a, 0xd8, 0xcc, 0xd1, 0x1b, 0x28, 0x64, 0x7b, 0xdf, 0x96, 0xea, 0x99, 0x43, 0xba, 0x16, 0xce,
	0x60, 0xe8, 0x25, 0x2c, 0x4f, 0x09, 0xf1, 0xfb, 0xde, 0xa4, 0xc1, 0xec, 0x56, 0xa0, 0x14, 0x50,
	0x21, 0xc3, 0x48, 0x89, 0x7d, 0xb7, 0x08, 0x05, 0x9f, 0x45, 0x92, 0x46, 0xd2, 0xf9, 0x97, 0x05,
	0xe0, 0x4a, 0x19, 0x9b, 0xdc, 0x21, 0x58, 0x54, 0xcd, 0x41, 0x97, 0x1b, 0x35, 0x46, 0xdb, 0xb0,
	0xac, 0xfb, 0x86, 0x79, 0x5b, 0x8f, 0x9a, 0xba, 0x6d, 0x35, 0xb3, 0xb6, 0xd5, 0xec, 0xab, 0xa6,
	0x86, 0x8d, 0x1b, 0xfa, 0x00, 0x95, 0x80, 0xc6, 0x9c, 0xfa, 0x44, 0xd2, 0xc0, 0xbb, 0xd8, 0x31,
	0x21, 0x3f, 0x9b, 0x7f, 0xe6, 0xc9, 0xe6, 0xcd, 0xbd, 0x09, 0xe8, 0xe3, 0x0e, 0x2e, 0x07, 0x57,
	0x66, 0x0d, 0x07, 0xca, 0x57, 0x57, 0xd3, 0x38, 0xe5, 0x65, 0x3c, 0x89, 0x33, 0x1d, 0x3b, 0xff,
	0xac, 0xc2, 0x83, 0x94, 0xad, 0x33, 0x69, 0xfa, 0xbf, 0xd7, 0x3d, 0x1f, 0xf5, 0xd3, 0x72, 0x1e,
	0x50, 0xdf, 0x9b, 0x60, 0xaa, 0xad, 0x17, 0x37, 0x46, 0x73, 0x0d, 0xdf, 0x4c, 0x2b, 0x8e, 0x3f,
	0xb8, 0x8c, 0x29, 0x2e, 0xfa, 0xd9, 0x30, 0x2d, 0xd0, 0x69, 0x3d, 0xf2, 0x62, 0x4e, 0x87, 0xe1,
	0x5f, 0x4c, 0x3b, 0x85, 0xd4, 0x74, 0xac, 0x2c, 0xe8, 0x19, 0x2c, 0xf0, 0x40, 0x98, 0xc3, 0xd7,
	0xe7, 0x3f, 0xc5, 0x40, 0xb8, 0x39, 0x9c, 0xba, 0xa1, 0x2e, 0x94, 0xaf, 0xf6, 0x68, 0xa3, 0x93,
	0xcd, 0x99, 0x7e, 0xf9, 0xad, 0x59, 0x9b, 0xc2, 0xe5, 0xe6, 0x70, 0xe9, 0x4a, 0x0b, 0x47, 0xbb,
	0x50, 0x56, 0x5f, 0x3e, 0x59, 0x05, 0x5f, 0x52, 0x15, 0xfc, 0xc9, 0x1d, 0x57, 0x8f, 0x4b, 0x67,
	0x93, 0xb1, 0x40, 0x6f, 0xa0, 0x4a, 0x82, 0xc0, 0x4b, 0x04, 0xe5, 0x1e, 0x19, 0xd1, 0x48, 0x9a,
	0x2a, 0xd0, 0xb8, 0x96, 0xf8, 0x5d, 0xc6, 0xc6, 0x1f, 0xd3, 0xa6, 0x8d, 0xcb, 0x24, 0x08, 0x4e,
	0x04, 0xe5, 0xed, 0xd4, 0x1f, 0x1d, 0x42, 0x21, 0xad, 0x51, 0x61, 0x34, 0x32, 0x05, 0xa0, 0x75,
	0x8f, 0xdb, 0x1e, 0x68, 0x24, 0xce, 0x28, 0xd0, 0x47, 0x78, 0xa0, 0xce, 0x94, 0x7d, 0x8a, 0x79,
	0x2c, 0x4e, 0xfd, 0x45, 0x7d, 0x65, 0x5e, 0x95, 0x4b, 0x49, 0x77, 0x8e, 0x8d, 0x6b, 0x4f, 0x7b,
	0xe2, 0xb5, 0x94, 0x60, 0xc6, 0x88, 0xfe, 0x00, 0x0f, 0x53, 0x73, 0xeb, 0x3a, 0x71, 0xf1, 0x26,
	0xe2, 0xd6, 0x2c, 0xf1, 0xfa, 0xd9, 0x1c, 0xab, 0xd2, 0x06, 0xe5, 0x17, 0x94, 0xeb, 0x4f, 0x2d,
	0x30, 0xda, 0x50, 0xa6, 0xf4, 0x2b, 0x0b, 0xbd, 0x84, 0x72, 0x18, 0x8c, 0xa9, 0x97, 0xd6, 0x5d,
	0x96, 0xc8, 0x7a, 0x49, 0x6d, 0xf8, 0xa3, 0x6b, 0x17, 0x9c, 0x75, 0x2c, 0x5c, 0x4a, 0xdd, 0x07,
	0xda, 0x1b, 0xbd, 0x82, 0x4a, 0xc0, 0x49, 0x18, 0x4d, 0xe0, 0xe5, 0xbb, 0xe0, 0x65, 0xe5, 0x9f,
	0xe1, 0x7f, 0x07, 0x40, 0x54, 0xa5, 0xf0, 0xc6, 0x6c, 0x54, 0xaf, 0x28, 0x89, 0x3c, 0xbe, 0xbd,
	0xa0, 0xe0, 0x22, 0x99, 0x54, 0x46, 0x17, 0x50, 0x22, 0xa8, 0xc7, 0xe9, 0x39, 0x93, 0xd4, 0x23,
	0x41, 0xc0, 0xa9, 0x10, 0xf5, 0xea, 0x9d, 0x1a, 0xb1, 0x13, 0x41, 0xb1, 0x02, 0xb5, 0x35, 0x06,
	0xbd, 0x83, 0xb5, 0x11, 0x8d, 0x28, 0x27, 0x32, 0xa5, 0xd3, 0xe5, 0x3c, 0x0c, 0xea, 0xb5, 0x3b,
	0xa9, 0x56, 0x33, 0x18, 0xd6, 0xa8, 0x83, 0x00, 0xfd, 0xcd, 0x82, 0x8d, 0x21, 0xe3, 0x5f, 0x09,
	0x0f, 0x3c, 0x7f, 0x1c, 0xd2, 0x48, 0x7a, 0x3e, 0xe5, 0xd2, 0x0b, 0xa8, 0x24, 0xe1, 0x58, 0xd4,
	0x6d, 0xf5, 0xec, 0x3b, 0xf7, 0x10, 0xe2, 0xbe, 0x66, 0xeb, 0x28, 0xb2, 0x0e, 0xe5, 0x72, 0x4f,
	0x53, 0xe1, 0xfa, 0xf0, 0x86, 0x15, 0xf4, 0x77, 0x0b, 0x9e, 0x08, 0x2a, 0x3d, 0x3f, 0xe1, 0x5c,
	0x45, 0x30, 0x27, 0x90, 0x55, 0x75, 0xba, 0xfd, 0x7b, 0x04, 0xd2, 0xa7, 0xb2, 0xa3, 0x09, 0xaf,
	0xc7, 0xb2, 0x21, 0x6e, 0x5e, 0x6c, 0xfc, 0xc7, 0x82, 0x82, 0x79, 0x4e, 0x68, 0x04, 0x55, 0x16,
	0x53, 0xf3, 0xb1, 0x34, 0x29, 0xf2, 0xd5, 0xd6, 0x9b, 0xfb, 0x3f, 0xcd, 0x66, 0x2f, 0x23, 0x4a,
	0xc5, 0x8c, 0x2b, 0xec, 0xea, 0x14, 0xfd, 0x06, 0xea, 0x33, 0xad, 0xd9, 0x1b, 0x32, 0xee, 0x49,
	0x32, 0xca, 0x3a, 0xef, 0x83, 0xe9, 0x1e, 0xbd, 0xcf, 0xf8, 0x80, 0x8c, 0x84, 0xb3, 0x05, 0x95,
	0x29, 0x62, 0x54, 0x82, 0xc2, 0xc1, 0xd1, 0x5b, 0xdc, 0xed, 0xf7, 0xed, 0x1c, 0x02, 0x58, 0xee,
	0xea, 0xb1, 0xd5, 0xf8, 0xab, 0x05, 0x1b, 0xb7, 0x5c, 0x0a, 0x7a, 0x01, 0x05, 0x91, 0x9c, 0xfe,
	0x89, 0xfa, 0x72, 0xf2, 0x5f, 0xe9, 0x66, 0x2d, 0x65, 0xae, 0x69, 0xc1, 0x16, 0x24, 0x32, 0x5d,
	0xee, 0x36, 0x44, 0xea, 0xe6, 0xfc, 0x0a, 0x8a, 0x93, 0xbe, 0x80, 0x56, 0x60, 0xb1, 0x7d, 0x32,
	0xe8, 0xd9, 0x39, 0x54, 0x84, 0x25, 0x77, 0x30, 0x38, 0xde, 0xb1, 0xad, 0x6c, 0xd8, 0xb2, 0xf3,
	0xce, 0x25, 0xd4, 0x6f, 0x52, 0x13, 0x2a, 0xc3, 0x4a, 0xbf, 0x7d, 0x74, 0x30, 0x38, 0xf8, 0x63,
	0xd7, 0xce, 0x21, 0x1b, 0xca, 0xfb, 0x3d, 0xfc, 0xa9, 0x8d, 0xf7, 0xbc, 0xde, 0xd1, 0xe1, 0x67,
	0xdb, 0x42, 0x08, 0xaa, 0xed, 0xe3, 0xe3, 0xee, 0xd1, 0x9e, 0x67, 0x16, 0xec, 0x7c, 0xea, 0x95,
	0x61, 0xbc, 0x7e, 0x77, 0x60, 0x2f, 0xa0, 0x47, 0xb0, 0xd6, 0x3e, 0xfc, 0xd4, 0xfe, 0xdc, 0xf7,
	0xa6, 0xe0, 0x8b, 0xbb, 0xab, 0xa0, 0xff, 0xe3, 0x7d, 0xfb, 0x9e, 0x3a, 0x5d, 0x56, 0x67, 0x7a,
	0xfe, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xb1, 0x41, 0x61, 0x71, 0x30, 0x0f, 0x00, 0x00,
}
